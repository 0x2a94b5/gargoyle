--- kamikaze-7.09-src/target/linux/atheros-2.6/files/drivers/net/ar2313/ar2313.c	2007-09-20 04:54:09.000000000 -0400
+++ kamikaze-7.09-fonplus-src/target/linux/atheros-2.6/files/drivers/net/ar2313/ar2313.c	2008-11-29 22:36:39.000000000 -0500
@@ -1,8 +1,10 @@
 /*
  * ar2313.c: Linux driver for the Atheros AR231x Ethernet device.
  *
- * Copyright (C) 2004 by Sameer Dekate <sdekate@arubanetworks.com>
- * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Modified for foneraplus FON2201
+ *
+ * Copyright (C) 2004 Sameer Dekate <sdekate@arubanetworks.com>
+ * Copyright (C) 2006-2007 Imre Kaloz <kaloz@openwrt.org>
  * Copyright (C) 2006-2007 Felix Fietkau <nbd@openwrt.org>
  *
  * Thanks to Atheros for providing hardware and documentation
@@ -39,6 +41,7 @@
 #include <linux/ethtool.h>
 #include <linux/ctype.h>
 #include <linux/platform_device.h>
+#include <linux/if_vlan.h>
 
 #include <net/sock.h>
 #include <net/ip.h>
@@ -55,6 +58,12 @@
 #define AR2313_QUEUES                  (2*AR2313_PRIOS)
 #define AR2313_DESCR_ENTRIES           64
 
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define DO_VLAN 1
+#else
+#define DO_VLAN 0
+#endif
+
 #undef INDEX_DEBUG
 #define DEBUG     0
 #define DEBUG_TX  0
@@ -132,12 +141,13 @@
 #define RX_LOW_THRES	        ((3*RX_RING_SIZE)/4)
 #define CRC_LEN                 4
 #define RX_OFFSET               2
+#define VLAN_TRAILER_LEN	4
 
-#define AR2313_BUFSIZE		(AR2313_MTU + ETH_HLEN + CRC_LEN + RX_OFFSET)
+#define AR2313_BUFSIZE		(AR2313_MTU + ETH_HLEN + CRC_LEN + RX_OFFSET + VLAN_TRAILER_LEN)
 
 #ifdef MODULE
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Sameer Dekate <sdekate@arubanetworks.com>, Imre Kaloz <kaloz@openwrt.org>, Felix Fietkau <nbd@openwrt.org>");
+MODULE_AUTHOR
+	("Sameer Dekate <sdekate@arubanetworks.com>, Imre Kaloz <kaloz@openwrt.org>, Felix Fietkau <nbd@openwrt.org>");
 MODULE_DESCRIPTION("AR2313 Ethernet driver");
 #endif
 
@@ -158,6 +168,110 @@
 #define ERR(fmt, args...) printk("%s: " fmt, __func__, ##args)
 #endif
 
+#if DO_VLAN
+/*
+ * Marvell switches are too braindead to do real VLAN,
+ * so we have to deal with their custom crap here...
+ */
+
+static int marvell_find_vlan(struct ar2313_private *sp,
+							 struct sk_buff *skb)
+{
+	unsigned char *buf = skb->data + skb->len - 4;
+	int ret = -1;
+
+	/* Is this a Marvell trailer? */
+	if (*buf != 0x80)
+		return 0;
+
+	/* FIXME: ugly, ugly hack! */
+	switch (buf[1]) {
+	case 4:					/* Packet came from the WAN port */
+		ret = 1;
+		break;
+	default:					/* Packet probably came from LAN */
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static struct sk_buff *marvell_add_vlan(struct ar2313_private *sp,
+										struct sk_buff *skb)
+{
+	u8 *buf = NULL;
+	struct sk_buff *newskb;
+	u8 vid;
+
+	if (unlikely(skb->len < 16))
+		return skb;
+
+	vid = skb->data[15];
+
+	/* XXX: clean up this garbage! */
+	if (skb->len <= 64) {
+		newskb = skb_copy_expand(skb, skb_headroom(skb), 68, GFP_ATOMIC);
+		if (!newskb) {
+			if (net_ratelimit())
+				printk("%s: failed to expand skb!\n", sp->dev->name);
+			goto done;
+		}
+		dev_kfree_skb(skb);
+		skb = newskb;
+		buf = skb->data + 64;
+		skb->len = 68;
+		goto tag_move;
+	}
+	
+	if (unlikely(skb_tailroom(skb) < 4)) {
+		/* not enough tailroom:
+		 * remove the vlan tag by closing the gap between the ethernet header
+		 * and the rest of the packet */
+		memmove(skb->data + 12, skb->data + 16, skb->len - 16);
+		/* skb->nh.raw -= 4; */
+		buf = skb->data + skb->len - 4;
+		goto tag_append;
+	}
+
+tag_move:
+	/* move the ethernet header 4 bytes forward, overwriting the vlan tag */
+	memmove(skb->data + 4, skb->data, 12);
+	/* skb->mac.raw += 4; */
+	skb->data += 4;
+	skb->len -= 4;
+	
+tag_append:
+	buf = (buf ?: skb_put(skb, 4));
+	if (!buf)
+		return skb;
+
+	*((u32 *) buf) = vid ? cpu_to_be32(
+		(0x80 << 24) |
+		(0x10 << 16)
+	) : 0; 
+
+done:
+	return skb;
+}
+
+static void ar2313_vlan_rx_register(struct net_device *dev,
+									struct vlan_group *grp)
+{
+	struct ar2313_private *sp = (struct ar2313_private *) dev->priv;
+
+	sp->vlgrp = grp;
+}
+
+static void ar2313_vlan_rx_kill_vid(struct net_device *dev,
+									unsigned short vid)
+{
+	struct ar2313_private *sp = (struct ar2313_private *) dev->priv;
+
+/*	if (sp->vlgrp)
+		sp->vlgrp->vlan_devices[vid] = NULL; */
+}
+#endif
 
 int __init ar2313_probe(struct platform_device *pdev)
 {
@@ -267,6 +381,22 @@
 		return -ENODEV;
 	}
 
+	/* FIXME: does this work? */
+	printk("PHY ID: %04x:%04x\n", (u16) armiiread(dev, 0x1f, 1),
+		   (u16) armiiread(dev, 0x1f, 2));
+	if (armiiread(dev, 0x1f, 1) != -1)
+		sp->marvell = 1;
+	else
+		sp->phy = 1;
+
+#if DO_VLAN
+	if (sp->marvell) {
+		dev->features |= NETIF_F_HW_VLAN_RX;
+		dev->vlan_rx_register = ar2313_vlan_rx_register;
+		dev->vlan_rx_kill_vid = ar2313_vlan_rx_kill_vid;
+	}
+#endif
+
 	if (register_netdev(dev)) {
 		printk("%s: register_netdev failed\n", __func__);
 		return -1;
@@ -277,6 +407,49 @@
 		   dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
 		   dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5], dev->irq);
 
+	if (sp->marvell) {
+		int i;
+
+		printk("Initialising Marvell switch... ");
+
+		/* reset chip 
+		armiiwrite(dev, 0x1f, 0xa, 0xa130);
+		do {
+			udelay(1000);
+			i = armiiread(dev, sp->phy, 0xa);
+		} while (i & 0x8000);*/
+
+		/* configure MAC address */
+		armiiwrite(dev, sp->phy, 0x1,
+				   dev->dev_addr[0] << 8 | dev->dev_addr[1]);
+		armiiwrite(dev, sp->phy, 0x2,
+				   dev->dev_addr[2] << 8 | dev->dev_addr[3]);
+		armiiwrite(dev, sp->phy, 0x3,
+				   dev->dev_addr[4] << 8 | dev->dev_addr[5]);
+
+		/* set ports to forwarding */
+		armiiwrite(dev, 0x18, 0x4, 0x3);	/* port 0 */
+		armiiwrite(dev, 0x19, 0x4, 0x3);	/* port 1 */
+		armiiwrite(dev, 0x1a, 0x4, 0x3);	/* port 2 */
+		armiiwrite(dev, 0x1b, 0x4, 0x3);	/* port 3 */
+		armiiwrite(dev, 0x1c, 0x4, 0x3);	/* port 4 - WAN */
+		armiiwrite(dev, 0x1d, 0x4, 0x4103);	/* port 5 - connected to CPU */
+
+		/* put ports into vlans */
+		armiiwrite(dev, 0x18, 0x6, 0x2e);	/* port 0 */
+		armiiwrite(dev, 0x19, 0x6, 0x2d);	/* port 1 */
+		armiiwrite(dev, 0x1a, 0x6, 0x2b);	/* port 2 */
+		armiiwrite(dev, 0x1b, 0x6, 0x27);	/* port 3 */
+		armiiwrite(dev, 0x1c, 0x6, 0x1020);	/* port 4 - WAN */
+		armiiwrite(dev, 0x1d, 0x6, 0x0f);	/* port 5 - connected to CPU */
+
+		/* hmz */
+		for (i = 0; i <= 5; i++)
+			armiiwrite(dev, 0x18 + i, 11, 1 << i);
+
+		printk("done.\n");
+	}
+
 	/* start link poll timer */
 	ar2313_setup_timer(dev);
 
@@ -867,6 +1040,9 @@
 	u32 idx;
 	int pkts = 0;
 	int rval;
+#if DO_VLAN
+	int vlan_id;
+#endif
 
 	idx = sp->cur_rx;
 
@@ -927,7 +1103,15 @@
 				sp->stats.rx_bytes += skb->len;
 				skb->protocol = eth_type_trans(skb, dev);
 				/* pass the packet to upper layers */
-				netif_rx(skb);
+
+#if DO_VLAN
+				if ((sp->marvell = 1) && sp->vlgrp) {
+					vlan_id = marvell_find_vlan(sp, skb);
+					vlan_hwaccel_rx(skb, sp->vlgrp, vlan_id);
+				} else
+#endif
+
+					netif_rx(skb);
 
 				skb_new->dev = dev;
 				/* 16 bit align */
@@ -1177,6 +1361,10 @@
 	ar2313_descr_t *td;
 	u32 idx;
 
+#if DO_VLAN
+	if (sp->marvell)
+		skb = marvell_add_vlan(sp, skb);
+#endif
 	idx = sp->tx_prd;
 	td = &sp->tx_ring[idx];
 
--- kamikaze-7.09-src/target/linux/atheros-2.6/files/drivers/net/ar2313/ar2313.h	2007-09-20 04:54:08.000000000 -0400
+++ kamikaze-7.09-fonplus-src/target/linux/atheros-2.6/files/drivers/net/ar2313/ar2313.h	2008-11-29 22:36:39.000000000 -0500
@@ -8,7 +8,7 @@
 /*
  * probe link timer - 5 secs
  */
-#define LINK_TIMER    (5*HZ)
+#define LINK_TIMER    (5*HZ) 
 
 #define IS_DMA_TX_INT(X)   (((X) & (DMA_STATUS_TI)) != 0)
 #define IS_DMA_RX_INT(X)   (((X) & (DMA_STATUS_RI)) != 0)
@@ -22,13 +22,13 @@
 #define DSC_RING_ENTRIES_SIZE	(AR2313_DESCR_ENTRIES * sizeof(struct desc))
 #define DSC_NEXT(idx)	        ((idx + 1) & (AR2313_DESCR_ENTRIES - 1))
 
-static inline int tx_space(u32 csm, u32 prd)
+static inline int tx_space (u32 csm, u32 prd)
 {
 	return (csm - prd - 1) & (AR2313_DESCR_ENTRIES - 1);
 }
 
 #if MAX_SKB_FRAGS
-#define TX_RESERVED	(MAX_SKB_FRAGS+1)	/* +1 for message header */
+#define TX_RESERVED	(MAX_SKB_FRAGS+1) /* +1 for message header */
 #define tx_ring_full(csm, prd)	(tx_space(csm, prd) <= TX_RESERVED)
 #else
 #define tx_ring_full		0
@@ -51,16 +51,16 @@
 // New Combo structure for Both Eth0 AND eth1
 //
 typedef struct {
-	volatile unsigned int mac_control;	/* 0x00 */
-	volatile unsigned int mac_addr[2];	/* 0x04 - 0x08 */
-	volatile unsigned int mcast_table[2];	/* 0x0c - 0x10 */
-	volatile unsigned int mii_addr;	/* 0x14 */
-	volatile unsigned int mii_data;	/* 0x18 */
-	volatile unsigned int flow_control;	/* 0x1c */
-	volatile unsigned int vlan_tag;	/* 0x20 */
-	volatile unsigned int pad[7];	/* 0x24 - 0x3c */
-	volatile unsigned int ucast_table[8];	/* 0x40-0x5c */
-
+  volatile unsigned int mac_control;    /* 0x00 */
+  volatile unsigned int mac_addr[2];    /* 0x04 - 0x08*/
+  volatile unsigned int mcast_table[2]; /* 0x0c - 0x10 */
+  volatile unsigned int mii_addr;       /* 0x14 */
+  volatile unsigned int mii_data;       /* 0x18 */
+  volatile unsigned int flow_control;   /* 0x1c */
+  volatile unsigned int vlan_tag;       /* 0x20 */
+  volatile unsigned int pad[7];         /* 0x24 - 0x3c */
+  volatile unsigned int ucast_table[8]; /* 0x40-0x5c */
+  
 } ETHERNET_STRUCT;
 
 /********************************************************************
@@ -68,31 +68,31 @@
  ********************************************************************/
 
 typedef struct {
-	volatile unsigned int wdog_control;	/* 0x08 */
-	volatile unsigned int wdog_timer;	/* 0x0c */
-	volatile unsigned int misc_status;	/* 0x10 */
-	volatile unsigned int misc_mask;	/* 0x14 */
-	volatile unsigned int global_status;	/* 0x18 */
-	volatile unsigned int reserved;	/* 0x1c */
-	volatile unsigned int reset_control;	/* 0x20 */
+  volatile unsigned int wdog_control;		/* 0x08 */
+  volatile unsigned int wdog_timer;		/* 0x0c */
+  volatile unsigned int misc_status;		/* 0x10 */
+  volatile unsigned int misc_mask;		/* 0x14 */
+  volatile unsigned int global_status;		/* 0x18 */
+  volatile unsigned int reserved;		/* 0x1c */
+  volatile unsigned int reset_control;		/* 0x20 */
 } INTERRUPT;
 
 /********************************************************************
  * DMA controller
  ********************************************************************/
 typedef struct {
-	volatile unsigned int bus_mode;	/* 0x00 (CSR0) */
-	volatile unsigned int xmt_poll;	/* 0x04 (CSR1) */
-	volatile unsigned int rcv_poll;	/* 0x08 (CSR2) */
-	volatile unsigned int rcv_base;	/* 0x0c (CSR3) */
-	volatile unsigned int xmt_base;	/* 0x10 (CSR4) */
-	volatile unsigned int status;	/* 0x14 (CSR5) */
-	volatile unsigned int control;	/* 0x18 (CSR6) */
-	volatile unsigned int intr_ena;	/* 0x1c (CSR7) */
-	volatile unsigned int rcv_missed;	/* 0x20 (CSR8) */
-	volatile unsigned int reserved[11];	/* 0x24-0x4c (CSR9-19) */
-	volatile unsigned int cur_tx_buf_addr;	/* 0x50 (CSR20) */
-	volatile unsigned int cur_rx_buf_addr;	/* 0x50 (CSR21) */
+  volatile unsigned int bus_mode;        /* 0x00 (CSR0) */
+  volatile unsigned int xmt_poll;        /* 0x04 (CSR1) */
+  volatile unsigned int rcv_poll;        /* 0x08 (CSR2) */
+  volatile unsigned int rcv_base;        /* 0x0c (CSR3) */
+  volatile unsigned int xmt_base;        /* 0x10 (CSR4) */
+  volatile unsigned int status;          /* 0x14 (CSR5) */
+  volatile unsigned int control;         /* 0x18 (CSR6) */
+  volatile unsigned int intr_ena;        /* 0x1c (CSR7) */
+  volatile unsigned int rcv_missed;      /* 0x20 (CSR8) */
+  volatile unsigned int reserved[11];    /* 0x24-0x4c (CSR9-19) */
+  volatile unsigned int cur_tx_buf_addr; /* 0x50 (CSR20) */
+  volatile unsigned int cur_rx_buf_addr; /* 0x50 (CSR21) */
 } DMA;
 
 /*
@@ -105,69 +105,72 @@
  * Frequently accessed variables are put at the beginning of the
  * struct to help the compiler generate better/shorter code.
  */
-struct ar2313_private {
+struct ar2313_private
+{
 	struct net_device *dev;
-	int version;
-	u32 mb[2];
-
-	volatile ETHERNET_STRUCT *phy_regs;
-	volatile ETHERNET_STRUCT *eth_regs;
-	volatile DMA *dma_regs;
-	volatile u32 *int_regs;
+	int			version;
+	u32                     mb[2];
+	
+	volatile ETHERNET_STRUCT	*phy_regs;
+	volatile ETHERNET_STRUCT	*eth_regs;
+	volatile DMA			*dma_regs;
+	volatile u32		        *int_regs;
 	struct ar531x_eth *cfg;
 
-	spinlock_t lock;			/* Serialise access to device */
+	spinlock_t lock; 	/* Serialise access to device */
 
-	/* 
+	/*
 	 * RX and TX descriptors, must be adjacent
 	 */
-	ar2313_descr_t *rx_ring;
-	ar2313_descr_t *tx_ring;
+	ar2313_descr_t	        *rx_ring;
+	ar2313_descr_t	        *tx_ring;
 
 
-	struct sk_buff **rx_skb;
-	struct sk_buff **tx_skb;
+	struct sk_buff		**rx_skb;
+	struct sk_buff		**tx_skb;
 
-	/* 
+	/*
 	 * RX elements
 	 */
-	u32 rx_skbprd;
-	u32 cur_rx;
+	u32			rx_skbprd;
+	u32			cur_rx;
 
-	/* 
+	/*
 	 * TX elements
 	 */
-	u32 tx_prd;
-	u32 tx_csm;
+	u32			tx_prd;
+	u32		        tx_csm;
 
-	/* 
+	/*
 	 * Misc elements
 	 */
-	int board_idx;
-	char name[48];
+	int			board_idx;
+	char			name[48];
 	struct net_device_stats stats;
 	struct {
-		u32 address;
-		u32 length;
-		char *mapping;
+	    u32 address;
+	    u32 length;
+	    char *mapping;
 	} desc;
 
 
 	struct timer_list link_timer;
-	unsigned short phy;			/* merlot phy = 1, samsung phy = 0x1f */
+	unsigned short phy;  /* merlot phy = 1,  samsung phy = 0x1f */
 	unsigned short mac;
-	unsigned short link;		/* 0 - link down, 1 - link up */
+	unsigned short link; /* 0 - link down,  1 - link up */
 	u16 phyData;
 
 	struct tasklet_struct rx_tasklet;
 	int unloading;
+	int marvell;
+	struct vlan_group *vlgrp;
 };
 
 
 /*
  * Prototypes
  */
-static int ar2313_init(struct net_device *dev);
+static int  ar2313_init(struct net_device *dev);
 #ifdef TX_TIMEOUT
 static void ar2313_tx_timeout(struct net_device *dev);
 #endif
@@ -176,18 +179,17 @@
 #endif
 static int ar2313_restart(struct net_device *dev);
 #if DEBUG
-static void ar2313_dump_regs(struct net_device *dev);
+static void  ar2313_dump_regs(struct net_device *dev);
 #endif
 static void ar2313_load_rx_ring(struct net_device *dev, int bufs);
 static irqreturn_t ar2313_interrupt(int irq, void *dev_id);
-static int ar2313_open(struct net_device *dev);
-static int ar2313_start_xmit(struct sk_buff *skb, struct net_device *dev);
-static int ar2313_close(struct net_device *dev);
-static int ar2313_ioctl(struct net_device *dev, struct ifreq *ifr,
-						int cmd);
+static int  ar2313_open(struct net_device *dev);
+static int  ar2313_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static int  ar2313_close(struct net_device *dev);
+static int  ar2313_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 static void ar2313_init_cleanup(struct net_device *dev);
-static int ar2313_setup_timer(struct net_device *dev);
+static int  ar2313_setup_timer(struct net_device *dev);
 static void ar2313_link_timer_fn(unsigned long data);
 static void ar2313_check_link(struct net_device *dev);
 static struct net_device_stats *ar2313_get_stats(struct net_device *dev);
-#endif							/* _AR2313_H_ */
+#endif /* _AR2313_H_ */
--- kamikaze-7.09-src/package/base-files/files/etc/config/network	2007-09-20 04:54:42.000000000 -0400
+++ kamikaze-7.09-fonplus-src/package/base-files/files/etc/config/network	2008-11-29 22:36:39.000000000 -0500
@@ -1,5 +1,9 @@
 # Copyright (C) 2006 OpenWrt.org
 
+config switch eth0
+	option vlan0 "1 2 3 4 5*"
+	option vlan1 "0 5"
+
 config interface loopback
 	option ifname	lo
 	option proto	static
@@ -7,8 +11,14 @@
 	option netmask	255.0.0.0
 
 config interface lan
-	option ifname	eth0
-	option type 	bridge
+	option type	bridge
+	option ifname	"eth0.0 ath0"
 	option proto	static
 	option ipaddr	192.168.1.1
 	option netmask	255.255.255.0
+
+config interface wan
+	option ifname "eth0.1"
+	option proto dhcp
+#	option nameserver 208.67.222.222
+
