--- haserl-0.9.26/src/Makefile.am	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/Makefile.am 2	2013-06-02 15:34:46.000000000 -0400
@@ -46,7 +46,7 @@
 
 haserl_SOURCES = common.c common.h sliding_buffer.c sliding_buffer.h \
 		 h_error.c h_error.h h_script.c h_script.h rfc2388.c rfc2388.h \
-		 $(BASHSOURCE) $(LUASOURCE) haserl.c haserl.h
+		 $(BASHSOURCE) $(LUASOURCE) h_translate.c h_translate.h haserl.c haserl.h
 
 install-strip:
         $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
--- haserl-0.9.26 SRC/src/Makefile.in	2009-07-30 19:14:06.000000000 -0400
+++ haserl-0.9.26/src/Makefile.in	2013-06-02 23:23:48.000000000 -0400
@@ -50,7 +50,7 @@
 	sliding_buffer.h h_error.c h_error.h h_script.c h_script.h \
 	rfc2388.c rfc2388.h h_bash.c h_bash.h haserl_lualib.inc \
 	h_lua_common.c h_lua_common.h h_lua.c h_lua.h h_luac.c \
-	h_luac.h haserl.c haserl.h
+	h_luac.h h_translate.c h_translate.h haserl.c haserl.h
 @INCLUDE_BASHSHELL_TRUE@am__objects_1 = h_bash.$(OBJEXT)
 @INCLUDE_LUASHELL_TRUE@@USE_LUA_TRUE@am__objects_2 = h_lua.$(OBJEXT)
 @INCLUDE_LUACSHELL_TRUE@@USE_LUA_TRUE@am__objects_3 =  \
@@ -59,7 +59,7 @@
 @USE_LUA_TRUE@	$(am__objects_3)
 am_haserl_OBJECTS = common.$(OBJEXT) sliding_buffer.$(OBJEXT) \
 	h_error.$(OBJEXT) h_script.$(OBJEXT) rfc2388.$(OBJEXT) \
-	$(am__objects_1) $(am__objects_4) haserl.$(OBJEXT)
+	$(am__objects_1) $(am__objects_4) h_translate.$(OBJEXT) haserl.$(OBJEXT)
 haserl_OBJECTS = $(am_haserl_OBJECTS)
 haserl_LDADD = $(LDADD)
 DEFAULT_INCLUDES = -I.@am__isrc@
@@ -99,7 +99,7 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
+LDFLAGS = -luci -lericstools
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LN_S = @LN_S@
@@ -167,7 +167,7 @@
 @INCLUDE_BASHSHELL_TRUE@BASHSOURCE = h_bash.c h_bash.h
 haserl_SOURCES = common.c common.h sliding_buffer.c sliding_buffer.h \
 		 h_error.c h_error.h h_script.c h_script.h rfc2388.c rfc2388.h \
-		 $(BASHSOURCE) $(LUASOURCE) haserl.c haserl.h
+		 $(BASHSOURCE) $(LUASOURCE) h_translate.c h_translate.h haserl.c haserl.h
 
 all: config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-am
@@ -260,6 +260,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_lua_common.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_luac.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_script.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_translate.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/haserl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc2388.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sliding_buffer.Po@am__quote@
--- haserl-0.9.26/src/h_script.h	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/h_script.h	2013-06-02 15:38:18.000000000 -0400
@@ -20,7 +20,7 @@
 #ifdef BASHEXTENSIONS
 enum tag_t { HTML, RUN, INCLUDE, EVAL, COMMENT, IF, ELIF, ELSE, ENDIF, CASE, WHEN, OTHERWISE, ENDCASE, WHILE, ENDWHILE, UNTIL, ENDUNTIL, FOR, ENDFOR, UNLESS, ELUN, UNELSE, ENDUNLESS, NOOP };
 #else
-enum tag_t { HTML, RUN, INCLUDE, EVAL, COMMENT, NOOP };
+enum tag_t { HTML, RUN, INCLUDE, EVAL, COMMENT, TRANSLATE, NOOP };
 #endif
 
 
--- haserl-0.9.26/src/h_script.c	2009-04-27 14:35:03.000000000 -0400
+++ haserl-0.9.26/src/h_script.c	2013-06-02 15:39:59.000000000 -0400
@@ -34,6 +34,7 @@
 #include "common.h"
 #include "h_error.h"
 #include "h_script.h"
+#include "h_translate.h"
 #include "h_bash.h"
 #include "haserl.h"
 
@@ -42,7 +43,7 @@
    OTHERWISE, ENDCASE, WHILE, ENDWHILE, UNTIL, ENDUNTIL, FOR, ENDFOR,
    UNLESS, ELUN, UNELSE, ENDUNLESS, NOOP }; */
 #else
-/* HTML, RUN, INCLUDE, EVAL, COMMENT, NOOP */
+/* HTML, RUN, INCLUDE, EVAL, COMMENT, TRANSLATE, NOOP */
 #endif
 
 const char *g_tag[] = {
@@ -51,6 +52,7 @@
   "in",
   "=",
   "#",
+  "~"
 #ifdef BASHEXTENSIONS
   "if",
   "elif",
@@ -373,6 +375,12 @@
 	      me->buf = find_whitespace (me->buf);
 	      me->len = strlen (me->buf);
 	    }
+      else if (memcmp (cp, g_tag[TRANSLATE], 1) == 0)
+      {
+	      me->tag = TRANSLATE;
+	      me->buf = find_whitespace (me->buf);
+	      me->len = strlen (me->buf);
+      }
 #ifdef BASHEXTENSIONS
 	  else if (memcmp (cp, g_tag[IF], 2) == 0)
 	    {
@@ -545,6 +553,9 @@
 	case EVAL:
 	  shell_eval (buf, token->buf, token->len);
 	  break;
+	case TRANSLATE:
+	  lookup_key (buf, token->buf);
+	  break;
 #ifdef BASHEXTENSIONS
 	case IF:
 	  shell_if (buf, token->buf, token->len);
--- haserl-0.9.26/src/haserl.h	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/haserl.h	2013-06-02 21:10:11.000000000 -0400
@@ -19,6 +19,10 @@
   int acceptall;                /* true if we'll accept POST data on 
   					GETs and vice versa 		     */
   int silent;                   /* true if we never print errors             */
+    
+  char *webroot;                /* return value for uci get gargoyle.global.web_root */
+  char *fallback_lang;          /* return value for uci get gargoyle.global.fallback_lang */
+  char *active_lang;            /* return value for uci get gargoyle.global.language */
 } haserl_t;
 
 extern haserl_t global;
--- haserl-0.9.26 SRC/src/haserl.c	2009-07-30 19:06:22.000000000 -0400
+++ haserl-0.9.26/src/haserl.c	2013-06-03 00:19:43.000000000 -0400
@@ -58,6 +58,7 @@
 #ifdef INCLUDE_BASHSHELL
 #include "h_bash.h"
 #endif
+#include "h_translate.h"
 
 #ifdef USE_LUA
 #include <lua.h>
@@ -646,6 +647,11 @@
   global.cookie_prefix = "COOKIE_";
   global.nul_prefix = "";
 
+  uci_init();
+
+  global.webroot=uci_get("gargoyle", "global", "web_root");
+  global.fallback_lang=uci_get("gargoyle", "global", "fallback_lang");
+  global.active_lang=uci_get("gargoyle", "global", "language");
 }
 
 
@@ -897,7 +903,9 @@
 #endif
       shell_destroy ();
     }
-
+    //printf("%s\n", global.webroot);
+    //printf("%s\n", global.fallback_lang);
+    //printf("%s\n", global.active_lang);
 
   if (global.uploadlist)
     {

--- /dev/null	2013-06-02 22:59:24.000000000 -0400
+++ haserl-0.9.26/src/h_translate.h	2013-06-02 21:05:08.000000000 -0400
@@ -0,0 +1,29 @@
+/* --------------------------------------------------------------------------
+ * Copyright 2013 BashfulBladder (bashfulbladder@gmail.com)
+ * 
+ *   This file is patch to haserl to provide i18n translation for Gargoyle
+ *   router firmware.
+ *
+ *   This file is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License version 2,
+ *   as published by the Free Software Foundation.
+ *
+ *   This file is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with haserl.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ------------------------------------------------------------------------ */
+
+#ifndef H_TRANSLATE_H
+#define H_TRANSLATE_H
+
+void lookup_key (buffer_t *buf, char *key);
+
+void uci_init();
+char* uci_get(char* package, char* section, char* option);
+
+#endif
--- /dev/null	2013-06-03 18:18:50.000000000 -0400
+++ haserl-0.9.26/src/h_translate.c	2013-06-03 18:20:40.000000000 -0400
@@ -0,0 +1,280 @@
+/* --------------------------------------------------------------------------
+ * Copyright 2013 BashfulBladder (bashfulbladder@gmail.com)
+ *                Eric Bishop <eric@gargoyle-router.com>
+ * 
+ *   This file is patch to haserl to provide i18n translation for Gargoyle
+ *   router firmware.
+ *
+ *   This file is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License version 2,
+ *   as published by the Free Software Foundation.
+ *
+ *   This file is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with haserl.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ------------------------------------------------------------------------ */
+
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+
+
+#include "common.h"
+#include "h_translate.h"
+#include "h_bash.h"
+#include "h_script.h"
+#include "haserl.h"
+
+#include <erics_tools.h>
+#include <uci.h>
+
+#define strdup safe_strdup
+#define FOUND_VAL 1
+
+struct uci_context *ctx;
+struct uci_package *p;
+struct uci_element *e;
+
+int find_val_len(char *fdata, int frem) {
+    int i;
+    for (i=0; i<frem; i++) {
+        if (memcmp(fdata+i, "\x22\x3B\x0A",3) == 0) { // terminating ";\n
+            break;
+        }
+    }
+    return i;
+}
+
+//
+//  find_key_value searches the raw file contents for the key (appending with =" characters) & copies
+//  from the end of the appended key to very near the end of the line (omitting the ";\n at the end
+//
+//  NOTE: there aren't any checks to ensure this is somewhere at the beginning of the line
+//  NOTE2: a key of .Save would match an unintentional bw.info="the .csv backup file.Save & backup the data..."
+//
+int find_key_value(char *fdata, int flen, char *key, char *value) {
+    char key_proper[259];
+    int klen=strlen(key);
+    int i;
+    
+    memset(key_proper, 0, 259);
+    memset(value, 0, 4096);
+    if (key[0] != '.') {
+        key_proper[0]='.';
+    }
+    memcpy(key_proper+(key_proper[0]=='.'?1:0), key, klen);
+    memcpy(key_proper+(klen-1)+(key[0]=='.'?0:1), "=\"", 2);
+    
+    for (i=0; i<flen; i++) {
+        if (memcmp(fdata+i, key_proper, strlen(key_proper)-1) == 0) {
+            memcpy(value, fdata+i+strlen(key_proper), find_val_len(fdata+i, flen-i)-strlen(key_proper) );
+            return FOUND_VAL;
+        }
+    }
+    return 0;
+}
+
+//
+//  search_file opens the file, tests the first 3 bytes for UTF-8 BOM & reads the rest of the file into memory
+//
+int search_file(buffer_t *fpath, char* key, char* kval) {
+    FILE *lfile;
+    char *buf;
+    long int lf_len;
+    int ret_val=0;
+    
+    lfile = fopen((char *)fpath->data, "r");
+    if(lfile == NULL) return 0;
+    
+    fseek(lfile, 0L, SEEK_END);
+    lf_len = ftell(lfile);
+    if (lf_len > 51200) return 0;
+    fseek(lfile, 0L, SEEK_SET);
+    
+    buf = (char*)calloc(lf_len, sizeof(char));
+    if(buf == NULL) return 0;
+    
+    fread(buf, sizeof(char), 3, lfile);
+    if (memcmp (buf, "\xEF\xBB\xBF", 3) == 0) {
+        fread(buf+3, sizeof(char), lf_len-3, lfile);
+        ret_val=find_key_value(buf, (int)lf_len, key, kval);
+        
+    } else {
+        printf("  %s: %s\n", fpath->data, "No UTF-8 BOM");
+    }
+    fclose(lfile);
+    free(buf);
+    return ret_val;
+}
+
+//
+//  gen_lang_fpath takes the elements of the /www/i18n/lang/somefile.js & constructs the path in *buf.data
+//
+void gen_lang_fpath (buffer_t *buf, char *lang, char *jsfile) {
+    buffer_add (buf, global.webroot, strlen(global.webroot));
+    buffer_add (buf, "/i18n/", 6);
+    buffer_add (buf, lang, strlen(lang));
+    buffer_add (buf, "/", 1);
+    buffer_add (buf, jsfile, strlen(jsfile)+1); //null terminate
+}
+
+//
+// lets start off by saying that I don't have a good understanding of what happens in the bash scripts
+// but I tried:
+//   failed:fprintf(stdout, "%s", key);
+//   failed:buffer_add (buf, key, strlen(key));
+// so the immediate solution is to have bash echo the key, which does get the string inlined
+// bash_echo (buf, key, strlen(key));
+//
+// lookup_key get the ball rolling functioning like awk - finding the pattern in the file
+//   buf is a simple data holding struct; every other form used it...
+//   key is the contents of the <%~ (something) %> form - whatever is there = key
+//
+//  NOTE: key here takes 2 forms: <%~ SaveChanges %> & <%~ time.SaveChanges %>
+//    the first form will automatically default to strings.js (where common element names reside)
+//    the 2nd form is page-specific, that page.js is the file used to scan
+//  The key is searched for a period (.) & split around if present. The active language is searched first
+//  if the result is not found, the fallback_lang is searched next; if it still can't be found, echo the key back
+//  so no blank spaces in the UI are manifest from a wonky translation.
+//
+void lookup_key (buffer_t *buf, char *key) {
+    buffer_t fpath;
+    haserl_buffer_init (&fpath);
+    char page_split[256], key_split[256];
+    char* key_value = (char*)calloc(4096, sizeof(char));
+    char* split=strchr(key++, '.');
+    
+    if (key_value == NULL) {
+        printf("Bad allocation");
+        return;
+    }
+    memset(page_split, 0, 256);
+    if (split == NULL) {
+        gen_lang_fpath(&fpath, global.active_lang, "strings.js");
+        if (search_file(&fpath, key, key_value) == FOUND_VAL) {
+            bash_echo (buf, key_value, strlen(key_value));
+        } else {
+            buffer_reset(&fpath);
+            gen_lang_fpath(&fpath, global.fallback_lang, "strings.js");
+            if (search_file(&fpath, key, key_value) == FOUND_VAL) {
+                bash_echo (buf, key_value, strlen(key_value));
+            } else {
+                bash_echo (buf, key, strlen(key));
+            }
+        }
+    } else {
+        memset(page_split, 0, 256);
+        memset(key_split, 0, 256);
+        memcpy(page_split, key, split-key);
+        memcpy(key_split, split, strlen(split));
+        memcpy(page_split+(split-key), ".js", 3);
+               
+        gen_lang_fpath(&fpath, global.active_lang, page_split);
+        if (search_file(&fpath, key_split, key_value) == FOUND_VAL) {
+            bash_echo (buf, key_value, strlen(key_value));
+        } else {
+            buffer_reset(&fpath);
+            gen_lang_fpath(&fpath, global.fallback_lang, page_split);
+            if (search_file(&fpath, key_split, key_value) == FOUND_VAL) {
+                bash_echo (buf, key_value, strlen(key_value));
+            } else {
+                bash_echo (buf, key_split, strlen(key_split));
+            }
+        }
+    }
+    
+    buffer_destroy(&fpath);
+}
+
+/*****************************    from gargoyle_header_footer    *************************************************/
+//
+// this function dynamically allocates memory for
+// the option string, but since this program exits
+// almost immediately (after printing variable info)
+// the massive memory leak we're opening up shouldn't
+// cause any problems.  This is your reminder/warning
+// that this might be an issue if you use this code to
+// do anything fancy.
+char* get_option_value_string(struct uci_option* uopt)
+{
+	char* opt_str = NULL;
+	if(uopt->type == UCI_TYPE_STRING)
+	{
+		opt_str = strdup(uopt->v.string);
+	}
+	if(uopt->type == UCI_TYPE_LIST)
+	{
+		struct uci_element* e;
+		uci_foreach_element(&uopt->v.list, e)
+		{
+			if(opt_str == NULL)
+			{
+				opt_str = strdup(e->name);
+			}
+			else
+			{
+				char* tmp;
+				tmp = dynamic_strcat(3, opt_str, " ", e->name);
+				free(opt_str);
+				opt_str = tmp;
+			}
+		}
+	}
+    
+	/* escape backslash characters & quote characters so javascript can parse variables properly */
+	char* tmp = opt_str;
+	opt_str = dynamic_replace(opt_str, "\\", "\\\\");
+	free(tmp);
+	tmp = opt_str;
+	opt_str = dynamic_replace(opt_str, "\"", "\\\"");
+	free(tmp);
+    
+    
+	return opt_str;
+}
+
+int get_uci_option(struct uci_context* ctx, struct uci_element** e, struct uci_package *p, char* package_name, char* section_name, char* option_name)
+{
+	struct uci_ptr ptr;
+	char* lookup_str = dynamic_strcat(5, package_name, ".", section_name, ".", option_name);
+	int ret_value = uci_lookup_ptr(ctx, &ptr, lookup_str, 1);
+	if(ret_value == UCI_OK)
+	{
+		if( !(ptr.flags & UCI_LOOKUP_COMPLETE))
+		{
+			ret_value = UCI_ERR_NOTFOUND;
+		}
+		else
+		{
+			*e = (struct uci_element*)ptr.o;
+		}
+	}
+	free(lookup_str);
+    
+	return ret_value;
+}
+/******************************************************************************/
+
+
+void uci_init() {
+    ctx = uci_alloc_context();
+}
+
+char* uci_get(char* package, char* section, char* option) {
+    p = NULL;
+    e = NULL;
+    if(get_uci_option(ctx, &e, p, package, section, option) == UCI_OK)
+    {
+        return get_option_value_string(uci_to_option(e));
+    }
+    return NULL;
+}
