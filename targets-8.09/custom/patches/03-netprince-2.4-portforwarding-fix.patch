--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/603-netfilter_nat_pptp.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,2434 +0,0 @@
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/netfilter_ipv4/ip_conntrack.h
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-@@ -50,16 +50,19 @@ enum ip_conntrack_status {
- 
- #include <linux/netfilter_ipv4/ip_conntrack_tcp.h>
- #include <linux/netfilter_ipv4/ip_conntrack_icmp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
- 
- /* per conntrack: protocol private data */
- union ip_conntrack_proto {
- 	/* insert conntrack proto private data here */
- 	struct ip_ct_tcp tcp;
- 	struct ip_ct_icmp icmp;
-+	struct ip_ct_gre gre;
- };
- 
- union ip_conntrack_expect_proto {
- 	/* insert expect proto private data here */
-+	struct ip_ct_gre_expect gre;
- };
- 
- /* Add protocol helper include file here */
-@@ -67,6 +70,7 @@ union ip_conntrack_expect_proto {
- 
- #include <linux/netfilter_ipv4/ip_conntrack_ftp.h>
- #include <linux/netfilter_ipv4/ip_conntrack_irc.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
- 
- /* per expectation: application helper private data */
- union ip_conntrack_expect_help {
-@@ -74,6 +78,7 @@ union ip_conntrack_expect_help {
- 	struct ip_ct_amanda_expect exp_amanda_info;
- 	struct ip_ct_ftp_expect exp_ftp_info;
- 	struct ip_ct_irc_expect exp_irc_info;
-+	struct ip_ct_pptp_expect exp_pptp_info;
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
- 	union {
-@@ -87,14 +92,17 @@ union ip_conntrack_help {
- 	/* insert conntrack helper private data (master) here */
- 	struct ip_ct_ftp_master ct_ftp_info;
- 	struct ip_ct_irc_master ct_irc_info;
-+	struct ip_ct_pptp_master ct_pptp_info;
- };
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
- #include <linux/netfilter_ipv4/ip_nat.h>
-+#include <linux/netfilter_ipv4/ip_nat_pptp.h>
- 
- /* per conntrack: nat application helper private data */
- union ip_conntrack_nat_help {
- 	/* insert nat helper private data here */
-+	struct ip_nat_pptp nat_pptp_info;
- };
- #endif
- 
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
-@@ -0,0 +1,313 @@
-+/* PPTP constants and structs */
-+#ifndef _CONNTRACK_PPTP_H
-+#define _CONNTRACK_PPTP_H
-+
-+/* state of the control session */
-+enum pptp_ctrlsess_state {
-+	PPTP_SESSION_NONE,			/* no session present */
-+	PPTP_SESSION_ERROR,			/* some session error */
-+	PPTP_SESSION_STOPREQ,			/* stop_sess request seen */
-+	PPTP_SESSION_REQUESTED,			/* start_sess request seen */
-+	PPTP_SESSION_CONFIRMED,			/* session established */
-+};
-+
-+/* state of the call inside the control session */
-+enum pptp_ctrlcall_state {
-+	PPTP_CALL_NONE,
-+	PPTP_CALL_ERROR,
-+	PPTP_CALL_OUT_REQ,
-+	PPTP_CALL_OUT_CONF,
-+	PPTP_CALL_IN_REQ,
-+	PPTP_CALL_IN_REP,
-+	PPTP_CALL_IN_CONF,
-+	PPTP_CALL_CLEAR_REQ,
-+};
-+
-+
-+/* conntrack private data */
-+struct ip_ct_pptp_master {
-+	enum pptp_ctrlsess_state sstate;	/* session state */
-+
-+	/* everything below is going to be per-expectation in newnat,
-+	 * since there could be more than one call within one session */
-+	enum pptp_ctrlcall_state cstate;	/* call state */
-+	u_int16_t pac_call_id;			/* call id of PAC, host byte order */
-+	u_int16_t pns_call_id;			/* call id of PNS, host byte order */
-+};
-+
-+/* conntrack_expect private member */
-+struct ip_ct_pptp_expect {
-+	enum pptp_ctrlcall_state cstate; 	/* call state */
-+	u_int16_t pac_call_id;			/* call id of PAC */
-+	u_int16_t pns_call_id;			/* call id of PNS */
-+};
-+
-+
-+#ifdef __KERNEL__
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+DECLARE_LOCK_EXTERN(ip_pptp_lock);
-+
-+#define IP_CONNTR_PPTP		PPTP_CONTROL_PORT
-+
-+union pptp_ctrl_union {
-+                void				*rawreq;
-+		struct PptpStartSessionRequest	*sreq;
-+		struct PptpStartSessionReply	*srep;
-+		struct PptpStopSessionRequest	*streq;
-+		struct PptpStopSessionReply	*strep;
-+                struct PptpOutCallRequest       *ocreq;
-+                struct PptpOutCallReply         *ocack;
-+                struct PptpInCallRequest        *icreq;
-+                struct PptpInCallReply          *icack;
-+                struct PptpInCallConnected      *iccon;
-+		struct PptpClearCallRequest	*clrreq;
-+                struct PptpCallDisconnectNotify *disc;
-+                struct PptpWanErrorNotify       *wanerr;
-+                struct PptpSetLinkInfo          *setlink;
-+};
-+
-+
-+
-+#define PPTP_CONTROL_PORT	1723
-+
-+#define PPTP_PACKET_CONTROL	1
-+#define PPTP_PACKET_MGMT	2
-+
-+#define PPTP_MAGIC_COOKIE	0x1a2b3c4d
-+
-+struct pptp_pkt_hdr {
-+	__u16	packetLength;
-+	__u16	packetType;
-+	__u32	magicCookie;
-+};
-+
-+/* PptpControlMessageType values */
-+#define PPTP_START_SESSION_REQUEST	1
-+#define PPTP_START_SESSION_REPLY	2
-+#define PPTP_STOP_SESSION_REQUEST	3
-+#define PPTP_STOP_SESSION_REPLY		4
-+#define PPTP_ECHO_REQUEST		5
-+#define PPTP_ECHO_REPLY			6
-+#define PPTP_OUT_CALL_REQUEST		7
-+#define PPTP_OUT_CALL_REPLY		8
-+#define PPTP_IN_CALL_REQUEST		9
-+#define PPTP_IN_CALL_REPLY		10
-+#define PPTP_IN_CALL_CONNECT		11
-+#define PPTP_CALL_CLEAR_REQUEST		12
-+#define PPTP_CALL_DISCONNECT_NOTIFY	13
-+#define PPTP_WAN_ERROR_NOTIFY		14
-+#define PPTP_SET_LINK_INFO		15
-+
-+#define PPTP_MSG_MAX			15
-+
-+/* PptpGeneralError values */
-+#define PPTP_ERROR_CODE_NONE		0
-+#define PPTP_NOT_CONNECTED		1
-+#define PPTP_BAD_FORMAT			2
-+#define PPTP_BAD_VALUE			3
-+#define PPTP_NO_RESOURCE		4
-+#define PPTP_BAD_CALLID			5
-+#define PPTP_REMOVE_DEVICE_ERROR	6
-+
-+struct PptpControlHeader {
-+	__u16	messageType;
-+	__u16	reserved;
-+};
-+
-+/* FramingCapability Bitmap Values */
-+#define PPTP_FRAME_CAP_ASYNC		0x1
-+#define PPTP_FRAME_CAP_SYNC		0x2
-+
-+/* BearerCapability Bitmap Values */
-+#define PPTP_BEARER_CAP_ANALOG		0x1
-+#define PPTP_BEARER_CAP_DIGITAL		0x2
-+
-+struct PptpStartSessionRequest {
-+	__u16	protocolVersion;
-+	__u8	reserved1;
-+	__u8	reserved2;
-+	__u32	framingCapability;
-+	__u32	bearerCapability;
-+	__u16	maxChannels;
-+	__u16	firmwareRevision;
-+	__u8	hostName[64];
-+	__u8	vendorString[64];
-+};
-+
-+/* PptpStartSessionResultCode Values */
-+#define PPTP_START_OK			1
-+#define PPTP_START_GENERAL_ERROR	2
-+#define PPTP_START_ALREADY_CONNECTED	3
-+#define PPTP_START_NOT_AUTHORIZED	4
-+#define PPTP_START_UNKNOWN_PROTOCOL	5
-+
-+struct PptpStartSessionReply {
-+	__u16	protocolVersion;
-+	__u8	resultCode;
-+	__u8	generalErrorCode;
-+	__u32	framingCapability;
-+	__u32	bearerCapability;
-+	__u16	maxChannels;
-+	__u16	firmwareRevision;
-+	__u8	hostName[64];
-+	__u8	vendorString[64];
-+};
-+
-+/* PptpStopReasons */
-+#define PPTP_STOP_NONE			1
-+#define PPTP_STOP_PROTOCOL		2
-+#define PPTP_STOP_LOCAL_SHUTDOWN	3
-+
-+struct PptpStopSessionRequest {
-+	__u8	reason;
-+};
-+
-+/* PptpStopSessionResultCode */
-+#define PPTP_STOP_OK			1
-+#define PPTP_STOP_GENERAL_ERROR		2
-+
-+struct PptpStopSessionReply {
-+	__u8	resultCode;
-+	__u8	generalErrorCode;
-+};
-+
-+struct PptpEchoRequest {
-+	__u32 identNumber;
-+};
-+
-+/* PptpEchoReplyResultCode */
-+#define PPTP_ECHO_OK			1
-+#define PPTP_ECHO_GENERAL_ERROR		2
-+
-+struct PptpEchoReply {
-+	__u32	identNumber;
-+	__u8	resultCode;
-+	__u8	generalErrorCode;
-+	__u16	reserved;
-+};
-+
-+/* PptpFramingType */
-+#define PPTP_ASYNC_FRAMING		1
-+#define PPTP_SYNC_FRAMING		2
-+#define PPTP_DONT_CARE_FRAMING		3
-+
-+/* PptpCallBearerType */
-+#define PPTP_ANALOG_TYPE		1
-+#define PPTP_DIGITAL_TYPE		2
-+#define PPTP_DONT_CARE_BEARER_TYPE	3
-+
-+struct PptpOutCallRequest {
-+	__u16	callID;
-+	__u16	callSerialNumber;
-+	__u32	minBPS;
-+	__u32	maxBPS;
-+	__u32	bearerType;
-+	__u32	framingType;
-+	__u16	packetWindow;
-+	__u16	packetProcDelay;
-+	__u16	reserved1;
-+	__u16	phoneNumberLength;
-+	__u16	reserved2;
-+	__u8	phoneNumber[64];
-+	__u8	subAddress[64];
-+};
-+
-+/* PptpCallResultCode */
-+#define PPTP_OUTCALL_CONNECT		1
-+#define PPTP_OUTCALL_GENERAL_ERROR	2
-+#define PPTP_OUTCALL_NO_CARRIER		3
-+#define PPTP_OUTCALL_BUSY		4
-+#define PPTP_OUTCALL_NO_DIAL_TONE	5
-+#define PPTP_OUTCALL_TIMEOUT		6
-+#define PPTP_OUTCALL_DONT_ACCEPT	7
-+
-+struct PptpOutCallReply {
-+	__u16	callID;
-+	__u16	peersCallID;
-+	__u8	resultCode;
-+	__u8	generalErrorCode;
-+	__u16	causeCode;
-+	__u32	connectSpeed;
-+	__u16	packetWindow;
-+	__u16	packetProcDelay;
-+	__u32	physChannelID;
-+};
-+
-+struct PptpInCallRequest {
-+	__u16	callID;
-+	__u16	callSerialNumber;
-+	__u32	callBearerType;
-+	__u32	physChannelID;
-+	__u16	dialedNumberLength;
-+	__u16	dialingNumberLength;
-+	__u8	dialedNumber[64];
-+	__u8	dialingNumber[64];
-+	__u8	subAddress[64];
-+};
-+
-+/* PptpInCallResultCode */
-+#define PPTP_INCALL_ACCEPT		1
-+#define PPTP_INCALL_GENERAL_ERROR	2
-+#define PPTP_INCALL_DONT_ACCEPT		3
-+
-+struct PptpInCallReply {
-+	__u16	callID;
-+	__u16	peersCallID;
-+	__u8	resultCode;
-+	__u8	generalErrorCode;
-+	__u16	packetWindow;
-+	__u16	packetProcDelay;
-+	__u16	reserved;
-+};
-+
-+struct PptpInCallConnected {
-+	__u16	peersCallID;
-+	__u16	reserved;
-+	__u32	connectSpeed;
-+	__u16	packetWindow;
-+	__u16	packetProcDelay;
-+	__u32	callFramingType;
-+};
-+
-+struct PptpClearCallRequest {
-+	__u16	callID;
-+	__u16	reserved;
-+};
-+
-+struct PptpCallDisconnectNotify {
-+	__u16	callID;
-+	__u8	resultCode;
-+	__u8	generalErrorCode;
-+	__u16	causeCode;
-+	__u16	reserved;
-+	__u8	callStatistics[128];
-+};
-+
-+struct PptpWanErrorNotify {
-+	__u16	peersCallID;
-+	__u16	reserved;
-+	__u32	crcErrors;
-+	__u32	framingErrors;
-+	__u32	hardwareOverRuns;
-+	__u32	bufferOverRuns;
-+	__u32	timeoutErrors;
-+	__u32	alignmentErrors;
-+};
-+
-+struct PptpSetLinkInfo {
-+	__u16	peersCallID;
-+	__u16	reserved;
-+	__u32	sendAccm;
-+	__u32	recvAccm;
-+};
-+
-+
-+struct pptp_priv_data {
-+	__u16	call_id;
-+	__u16	mcall_id;
-+	__u16	pcall_id;
-+};
-+
-+#endif /* __KERNEL__ */
-+#endif /* _CONNTRACK_PPTP_H */
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h
-@@ -0,0 +1,123 @@
-+#ifndef _CONNTRACK_PROTO_GRE_H
-+#define _CONNTRACK_PROTO_GRE_H
-+#include <asm/byteorder.h>
-+
-+/* GRE PROTOCOL HEADER */
-+
-+/* GRE Version field */
-+#define GRE_VERSION_1701	0x0
-+#define GRE_VERSION_PPTP	0x1
-+
-+/* GRE Protocol field */
-+#define GRE_PROTOCOL_PPTP	0x880B
-+
-+/* GRE Flags */
-+#define GRE_FLAG_C		0x80
-+#define GRE_FLAG_R		0x40
-+#define GRE_FLAG_K		0x20
-+#define GRE_FLAG_S		0x10
-+#define GRE_FLAG_A		0x80
-+
-+#define GRE_IS_C(f)	((f)&GRE_FLAG_C)
-+#define GRE_IS_R(f)	((f)&GRE_FLAG_R)
-+#define GRE_IS_K(f)	((f)&GRE_FLAG_K)
-+#define GRE_IS_S(f)	((f)&GRE_FLAG_S)
-+#define GRE_IS_A(f)	((f)&GRE_FLAG_A)
-+
-+/* GRE is a mess: Four different standards */
-+struct gre_hdr {
-+#if defined(__LITTLE_ENDIAN_BITFIELD)
-+	__u16	rec:3,
-+		srr:1,
-+		seq:1,
-+		key:1,
-+		routing:1,
-+		csum:1,
-+		version:3,
-+		reserved:4,
-+		ack:1;
-+#elif defined(__BIG_ENDIAN_BITFIELD)
-+	__u16	csum:1,
-+		routing:1,
-+		key:1,
-+		seq:1,
-+		srr:1,
-+		rec:3,
-+		ack:1,
-+		reserved:4,
-+		version:3;
-+#else
-+#error "Adjust your <asm/byteorder.h> defines"
-+#endif
-+	__u16	protocol;
-+};
-+
-+/* modified GRE header for PPTP */
-+struct gre_hdr_pptp {
-+	__u8  flags;		/* bitfield */
-+	__u8  version;		/* should be GRE_VERSION_PPTP */
-+	__u16 protocol;		/* should be GRE_PROTOCOL_PPTP */
-+	__u16 payload_len;	/* size of ppp payload, not inc. gre header */
-+	__u16 call_id;		/* peer's call_id for this session */
-+	__u32 seq;		/* sequence number.  Present if S==1 */
-+	__u32 ack;		/* seq number of highest packet recieved by */
-+				/*  sender in this session */
-+};
-+
-+
-+/* this is part of ip_conntrack */
-+struct ip_ct_gre {
-+	unsigned int stream_timeout;
-+	unsigned int timeout;
-+};
-+
-+/* this is part of ip_conntrack_expect */
-+struct ip_ct_gre_expect {
-+	struct ip_ct_gre_keymap *keymap_orig, *keymap_reply;
-+};
-+
-+#ifdef __KERNEL__
-+struct ip_conntrack_expect;
-+
-+/* structure for original <-> reply keymap */
-+struct ip_ct_gre_keymap {
-+	struct list_head list;
-+
-+	struct ip_conntrack_tuple tuple;
-+};
-+
-+
-+/* add new tuple->key_reply pair to keymap */
-+int ip_ct_gre_keymap_add(struct ip_conntrack_expect *exp,
-+			 struct ip_conntrack_tuple *t,
-+			 int reply);
-+
-+/* change an existing keymap entry */
-+void ip_ct_gre_keymap_change(struct ip_ct_gre_keymap *km,
-+			     struct ip_conntrack_tuple *t);
-+
-+/* delete keymap entries */
-+void ip_ct_gre_keymap_destroy(struct ip_conntrack_expect *exp);
-+
-+
-+/* get pointer to gre key, if present */
-+static inline u_int32_t *gre_key(struct gre_hdr *greh)
-+{
-+	if (!greh->key)
-+		return NULL;
-+	if (greh->csum || greh->routing)
-+		return (u_int32_t *) (greh+sizeof(*greh)+4);
-+	return (u_int32_t *) (greh+sizeof(*greh));
-+}
-+
-+/* get pointer ot gre csum, if present */
-+static inline u_int16_t *gre_csum(struct gre_hdr *greh)
-+{
-+	if (!greh->csum)
-+		return NULL;
-+	return (u_int16_t *) (greh+sizeof(*greh));
-+}
-+
-+#endif /* __KERNEL__ */
-+
-+#endif /* _CONNTRACK_PROTO_GRE_H */
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_tuple.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/netfilter_ipv4/ip_conntrack_tuple.h
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_tuple.h
-@@ -14,7 +14,7 @@
- union ip_conntrack_manip_proto
- {
- 	/* Add other protocols here. */
--	u_int16_t all;
-+	u_int32_t all;
- 
- 	struct {
- 		u_int16_t port;
-@@ -25,6 +25,9 @@ union ip_conntrack_manip_proto
- 	struct {
- 		u_int16_t id;
- 	} icmp;
-+	struct {
-+		u_int32_t key;
-+	} gre;
- };
- 
- /* The manipulable part of the tuple. */
-@@ -44,7 +47,7 @@ struct ip_conntrack_tuple
- 		u_int32_t ip;
- 		union {
- 			/* Add other protocols here. */
--			u_int16_t all;
-+			u_int32_t all;
- 
- 			struct {
- 				u_int16_t port;
-@@ -55,6 +58,9 @@ struct ip_conntrack_tuple
- 			struct {
- 				u_int8_t type, code;
- 			} icmp;
-+			struct {
-+				u_int32_t key;
-+			} gre;
- 		} u;
- 
- 		/* The protocol. */
-@@ -80,10 +86,16 @@ enum ip_conntrack_dir
- #ifdef __KERNEL__
- 
- #define DUMP_TUPLE(tp)						\
--DEBUGP("tuple %p: %u %u.%u.%u.%u:%hu -> %u.%u.%u.%u:%hu\n",	\
-+DEBUGP("tuple %p: %u %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u\n",	\
-        (tp), (tp)->dst.protonum,				\
--       NIPQUAD((tp)->src.ip), ntohs((tp)->src.u.all),		\
--       NIPQUAD((tp)->dst.ip), ntohs((tp)->dst.u.all))
-+       NIPQUAD((tp)->src.ip), ntohl((tp)->src.u.all),		\
-+       NIPQUAD((tp)->dst.ip), ntohl((tp)->dst.u.all))
-+
-+#define DUMP_TUPLE_RAW(x) 						\
-+	DEBUGP("tuple %p: %u %u.%u.%u.%u:0x%08x -> %u.%u.%u.%u:0x%08x\n",\
-+	(x), (x)->dst.protonum,						\
-+	NIPQUAD((x)->src.ip), ntohl((x)->src.u.all), 			\
-+	NIPQUAD((x)->dst.ip), ntohl((x)->dst.u.all))
- 
- #define CTINFO2DIR(ctinfo) ((ctinfo) >= IP_CT_IS_REPLY ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL)
- 
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_nat_pptp.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_nat_pptp.h
-@@ -0,0 +1,11 @@
-+/* PPTP constants and structs */
-+#ifndef _NAT_PPTP_H
-+#define _NAT_PPTP_H
-+
-+/* conntrack private data */
-+struct ip_nat_pptp {
-+	u_int16_t pns_call_id;		/* NAT'ed PNS call id */
-+	u_int16_t pac_call_id;		/* NAT'ed PAC call id */
-+};
-+
-+#endif /* _NAT_PPTP_H */
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -10,6 +10,8 @@ if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ];
-   dep_tristate '  Amanda protocol support' CONFIG_IP_NF_AMANDA $CONFIG_IP_NF_CONNTRACK
-   dep_tristate '  TFTP protocol support' CONFIG_IP_NF_TFTP $CONFIG_IP_NF_CONNTRACK
-   dep_tristate '  IRC protocol support' CONFIG_IP_NF_IRC $CONFIG_IP_NF_CONNTRACK
-+  dep_tristate '  GRE protocol support' CONFIG_IP_NF_CT_PROTO_GRE $CONFIG_IP_NF_CONNTRACK
-+  dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
- fi
- 
- if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-@@ -63,6 +65,20 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-       define_bool CONFIG_IP_NF_NAT_NEEDED y
-       dep_tristate '    MASQUERADE target support' CONFIG_IP_NF_TARGET_MASQUERADE $CONFIG_IP_NF_NAT
-       dep_tristate '    REDIRECT target support' CONFIG_IP_NF_TARGET_REDIRECT $CONFIG_IP_NF_NAT
-+      if [ "$CONFIG_IP_NF_PPTP" = "m" ]; then
-+        define_tristate CONFIG_IP_NF_NAT_PPTP m
-+      else
-+        if [ "$CONFIG_IP_NF_PPTP" = "y" ]; then
-+          define_tristate CONFIG_IP_NF_NAT_PPTP $CONFIG_IP_NF_NAT
-+        fi
-+      fi
-+      if [ "$CONFIG_IP_NF_CT_PROTO_GRE" = "m" ]; then
-+        define_tristate CONFIG_IP_NF_NAT_PROTO_GRE m
-+      else
-+        if [ "$CONFIG_IP_NF_CT_PROTO_GRE" = "y" ]; then
-+          define_tristate CONFIG_IP_NF_NAT_PROTO_GRE $CONFIG_IP_NF_NAT
-+        fi
-+      fi
-       if [ "$CONFIG_IP_NF_AMANDA" = "m" ]; then
-         define_tristate CONFIG_IP_NF_NAT_AMANDA m
-       else
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_core.c
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/ip_conntrack_core.c
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_core.c
-@@ -143,6 +143,8 @@ ip_ct_get_tuple(const struct iphdr *iph,
- 	tuple->dst.ip = iph->daddr;
- 	tuple->dst.protonum = iph->protocol;
- 
-+	tuple->src.u.all = tuple->dst.u.all = 0;
-+
- 	ret = protocol->pkt_to_tuple((u_int32_t *)iph + iph->ihl,
- 				     len - 4*iph->ihl,
- 				     tuple);
-@@ -158,6 +160,8 @@ invert_tuple(struct ip_conntrack_tuple *
- 	inverse->dst.ip = orig->src.ip;
- 	inverse->dst.protonum = orig->dst.protonum;
- 
-+	inverse->src.u.all = inverse->dst.u.all = 0;
-+
- 	return protocol->invert_tuple(inverse, orig);
- }
- 
-@@ -970,8 +974,8 @@ int ip_conntrack_expect_related(struct i
- 	 * so there is no need to use the tuple lock too */
- 
- 	DEBUGP("ip_conntrack_expect_related %p\n", related_to);
--	DEBUGP("tuple: "); DUMP_TUPLE(&expect->tuple);
--	DEBUGP("mask:  "); DUMP_TUPLE(&expect->mask);
-+	DEBUGP("tuple: "); DUMP_TUPLE_RAW(&expect->tuple);
-+	DEBUGP("mask:  "); DUMP_TUPLE_RAW(&expect->mask);
- 
- 	old = LIST_FIND(&ip_conntrack_expect_list, resent_expect,
- 		        struct ip_conntrack_expect *, &expect->tuple, 
-@@ -1089,15 +1093,14 @@ int ip_conntrack_change_expect(struct ip
- 
- 	MUST_BE_READ_LOCKED(&ip_conntrack_lock);
- 	WRITE_LOCK(&ip_conntrack_expect_tuple_lock);
--
- 	DEBUGP("change_expect:\n");
--	DEBUGP("exp tuple: "); DUMP_TUPLE(&expect->tuple);
--	DEBUGP("exp mask:  "); DUMP_TUPLE(&expect->mask);
--	DEBUGP("newtuple:  "); DUMP_TUPLE(newtuple);
-+	DEBUGP("exp tuple: "); DUMP_TUPLE_RAW(&expect->tuple);
-+	DEBUGP("exp mask:  "); DUMP_TUPLE_RAW(&expect->mask);
-+	DEBUGP("newtuple:  "); DUMP_TUPLE_RAW(newtuple);
- 	if (expect->ct_tuple.dst.protonum == 0) {
- 		/* Never seen before */
- 		DEBUGP("change expect: never seen before\n");
--		if (!ip_ct_tuple_equal(&expect->tuple, newtuple) 
-+		if (!ip_ct_tuple_mask_cmp(&expect->tuple, newtuple, &expect->mask)
- 		    && LIST_FIND(&ip_conntrack_expect_list, expect_clash,
- 			         struct ip_conntrack_expect *, newtuple, &expect->mask)) {
- 			/* Force NAT to find an unused tuple */
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_pptp_priv.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_pptp_priv.h
-@@ -0,0 +1,24 @@
-+#ifndef _IP_CT_PPTP_PRIV_H
-+#define _IP_CT_PPTP_PRIV_H
-+
-+/* PptpControlMessageType names */
-+static const char *strMName[] = {
-+	"UNKNOWN_MESSAGE",
-+	"START_SESSION_REQUEST",
-+	"START_SESSION_REPLY",
-+	"STOP_SESSION_REQUEST",
-+	"STOP_SESSION_REPLY",
-+	"ECHO_REQUEST",
-+	"ECHO_REPLY",
-+	"OUT_CALL_REQUEST",
-+	"OUT_CALL_REPLY",
-+	"IN_CALL_REQUEST",
-+	"IN_CALL_REPLY",
-+	"IN_CALL_CONNECT",
-+	"CALL_CLEAR_REQUEST",
-+	"CALL_DISCONNECT_NOTIFY",
-+	"WAN_ERROR_NOTIFY",
-+	"SET_LINK_INFO"
-+};
-+
-+#endif
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_proto_gre.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_proto_gre.c
-@@ -0,0 +1,333 @@
-+/*
-+ * ip_conntrack_proto_gre.c - Version 1.2 
-+ *
-+ * Connection tracking protocol helper module for GRE.
-+ *
-+ * GRE is a generic encapsulation protocol, which is generally not very
-+ * suited for NAT, as it has no protocol-specific part as port numbers.
-+ *
-+ * It has an optional key field, which may help us distinguishing two 
-+ * connections between the same two hosts.
-+ *
-+ * GRE is defined in RFC 1701 and RFC 1702, as well as RFC 2784 
-+ *
-+ * PPTP is built on top of a modified version of GRE, and has a mandatory
-+ * field called "CallID", which serves us for the same purpose as the key
-+ * field in plain GRE.
-+ *
-+ * Documentation about PPTP can be found in RFC 2637
-+ *
-+ * (C) 2000-2003 by Harald Welte <laforge@gnumonks.org>
-+ *
-+ * Development of this code funded by Astaro AG (http://www.astaro.com/)
-+ *
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/types.h>
-+#include <linux/timer.h>
-+#include <linux/netfilter.h>
-+#include <linux/ip.h>
-+#include <linux/in.h>
-+#include <linux/list.h>
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+
-+DECLARE_RWLOCK(ip_ct_gre_lock);
-+#define ASSERT_READ_LOCK(x) MUST_BE_READ_LOCKED(&ip_ct_gre_lock)
-+#define ASSERT_WRITE_LOCK(x) MUST_BE_WRITE_LOCKED(&ip_ct_gre_lock)
-+
-+#include <linux/netfilter_ipv4/listhelp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_protocol.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_core.h>
-+
-+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Harald Welte <laforge@gnumonks.org>");
-+MODULE_DESCRIPTION("netfilter connection tracking protocol helper for GRE");
-+
-+/* shamelessly stolen from ip_conntrack_proto_udp.c */
-+#define GRE_TIMEOUT		(30*HZ)
-+#define GRE_STREAM_TIMEOUT	(180*HZ)
-+
-+#if 0
-+#define DEBUGP(format, args...) printk(KERN_DEBUG __FILE__ ":" __FUNCTION__ \
-+		                       ": " format, ## args)
-+#define DUMP_TUPLE_GRE(x) printk("%u.%u.%u.%u:0x%x -> %u.%u.%u.%u:0x%x:%u:0x%x\n", \
-+			NIPQUAD((x)->src.ip), ntohl((x)->src.u.gre.key), \
-+			NIPQUAD((x)->dst.ip), ntohl((x)->dst.u.gre.key))
-+#else
-+#define DEBUGP(x, args...)
-+#define DUMP_TUPLE_GRE(x)
-+#endif
-+				
-+/* GRE KEYMAP HANDLING FUNCTIONS */
-+static LIST_HEAD(gre_keymap_list);
-+
-+static inline int gre_key_cmpfn(const struct ip_ct_gre_keymap *km,
-+				const struct ip_conntrack_tuple *t)
-+{
-+	return ((km->tuple.src.ip == t->src.ip) &&
-+		(km->tuple.dst.ip == t->dst.ip) &&
-+	        (km->tuple.dst.protonum == t->dst.protonum) &&
-+	        (km->tuple.dst.u.all == t->dst.u.all));
-+}
-+
-+/* look up the source key for a given tuple */
-+static u_int32_t gre_keymap_lookup(struct ip_conntrack_tuple *t)
-+{
-+	struct ip_ct_gre_keymap *km;
-+	u_int32_t key;
-+
-+	READ_LOCK(&ip_ct_gre_lock);
-+	km = LIST_FIND(&gre_keymap_list, gre_key_cmpfn,
-+			struct ip_ct_gre_keymap *, t);
-+	if (!km) {
-+		READ_UNLOCK(&ip_ct_gre_lock);
-+		return 0;
-+	}
-+
-+	key = km->tuple.src.u.gre.key;
-+	READ_UNLOCK(&ip_ct_gre_lock);
-+
-+	return key;
-+}
-+
-+/* add a single keymap entry, associate with specified expect */
-+int ip_ct_gre_keymap_add(struct ip_conntrack_expect *exp,
-+			 struct ip_conntrack_tuple *t, int reply)
-+{
-+	struct ip_ct_gre_keymap *km;
-+
-+	km = kmalloc(sizeof(*km), GFP_ATOMIC);
-+	if (!km)
-+		return -1;
-+
-+	/* initializing list head should be sufficient */
-+	memset(km, 0, sizeof(*km));
-+
-+	memcpy(&km->tuple, t, sizeof(*t));
-+
-+	if (!reply)
-+		exp->proto.gre.keymap_orig = km;
-+	else
-+		exp->proto.gre.keymap_reply = km;
-+
-+	DEBUGP("adding new entry %p: ", km);
-+	DUMP_TUPLE_GRE(&km->tuple);
-+
-+	WRITE_LOCK(&ip_ct_gre_lock);
-+	list_append(&gre_keymap_list, km);
-+	WRITE_UNLOCK(&ip_ct_gre_lock);
-+
-+	return 0;
-+}
-+
-+/* change the tuple of a keymap entry (used by nat helper) */
-+void ip_ct_gre_keymap_change(struct ip_ct_gre_keymap *km,
-+			     struct ip_conntrack_tuple *t)
-+{
-+	DEBUGP("changing entry %p to: ", km);
-+	DUMP_TUPLE_GRE(t);
-+
-+	WRITE_LOCK(&ip_ct_gre_lock);
-+	memcpy(&km->tuple, t, sizeof(km->tuple));
-+	WRITE_UNLOCK(&ip_ct_gre_lock);
-+}
-+
-+/* destroy the keymap entries associated with specified expect */
-+void ip_ct_gre_keymap_destroy(struct ip_conntrack_expect *exp)
-+{
-+	DEBUGP("entering for exp %p\n", exp);
-+	WRITE_LOCK(&ip_ct_gre_lock);
-+	if (exp->proto.gre.keymap_orig) {
-+		DEBUGP("removing %p from list\n", exp->proto.gre.keymap_orig);
-+		list_del(&exp->proto.gre.keymap_orig->list);
-+		kfree(exp->proto.gre.keymap_orig);
-+		exp->proto.gre.keymap_orig = NULL;
-+	}
-+	if (exp->proto.gre.keymap_reply) {
-+		DEBUGP("removing %p from list\n", exp->proto.gre.keymap_reply);
-+		list_del(&exp->proto.gre.keymap_reply->list);
-+		kfree(exp->proto.gre.keymap_reply);
-+		exp->proto.gre.keymap_reply = NULL;
-+	}
-+	WRITE_UNLOCK(&ip_ct_gre_lock);
-+}
-+
-+
-+/* PUBLIC CONNTRACK PROTO HELPER FUNCTIONS */
-+
-+/* invert gre part of tuple */
-+static int gre_invert_tuple(struct ip_conntrack_tuple *tuple,
-+			    const struct ip_conntrack_tuple *orig)
-+{
-+	tuple->dst.u.gre.key = orig->src.u.gre.key;
-+	tuple->src.u.gre.key = orig->dst.u.gre.key;
-+
-+	return 1;
-+}
-+
-+/* gre hdr info to tuple */
-+static int gre_pkt_to_tuple(const void *datah, size_t datalen,
-+			    struct ip_conntrack_tuple *tuple)
-+{
-+	struct gre_hdr *grehdr = (struct gre_hdr *) datah;
-+	struct gre_hdr_pptp *pgrehdr = (struct gre_hdr_pptp *) datah;
-+	u_int32_t srckey;
-+
-+	/* core guarantees 8 protocol bytes, no need for size check */
-+
-+	switch (grehdr->version) {
-+		case GRE_VERSION_1701:
-+			if (!grehdr->key) {
-+				DEBUGP("Can't track GRE without key\n");
-+				return 0;
-+			}
-+			tuple->dst.u.gre.key = *(gre_key(grehdr));
-+			break;
-+
-+		case GRE_VERSION_PPTP:
-+			if (ntohs(grehdr->protocol) != GRE_PROTOCOL_PPTP) {
-+				DEBUGP("GRE_VERSION_PPTP but unknown proto\n");
-+				return 0;
-+			}
-+			tuple->dst.u.gre.key = htonl(ntohs(pgrehdr->call_id));
-+			break;
-+
-+		default:
-+			printk(KERN_WARNING "unknown GRE version %hu\n",
-+				grehdr->version);
-+			return 0;
-+	}
-+
-+	srckey = gre_keymap_lookup(tuple);
-+
-+#if 0
-+	DEBUGP("found src key %x for tuple ", ntohl(srckey));
-+	DUMP_TUPLE_GRE(tuple);
-+#endif
-+	tuple->src.u.gre.key = srckey;
-+
-+	return 1;
-+}
-+
-+/* print gre part of tuple */
-+static unsigned int gre_print_tuple(char *buffer,
-+				    const struct ip_conntrack_tuple *tuple)
-+{
-+	return sprintf(buffer, "srckey=0x%x dstkey=0x%x ", 
-+			ntohl(tuple->src.u.gre.key),
-+			ntohl(tuple->dst.u.gre.key));
-+}
-+
-+/* print private data for conntrack */
-+static unsigned int gre_print_conntrack(char *buffer,
-+					const struct ip_conntrack *ct)
-+{
-+	return sprintf(buffer, "timeout=%u, stream_timeout=%u ",
-+		       (ct->proto.gre.timeout / HZ),
-+		       (ct->proto.gre.stream_timeout / HZ));
-+}
-+
-+/* Returns verdict for packet, and may modify conntrack */
-+static int gre_packet(struct ip_conntrack *ct,
-+		      struct iphdr *iph, size_t len,
-+		      enum ip_conntrack_info conntrackinfo)
-+{
-+	/* If we've seen traffic both ways, this is a GRE connection.
-+	 * Extend timeout. */
-+	if (ct->status & IPS_SEEN_REPLY) {
-+		ip_ct_refresh_acct(ct, ct->proto.gre.stream_timeout);
-+		/* Also, more likely to be important, and not a probe. */
-+		set_bit(IPS_ASSURED_BIT, &ct->status);
-+	} else
-+		ip_ct_refresh_acct(ct, ct->proto.gre.timeout);
-+	
-+	return NF_ACCEPT;
-+}
-+
-+/* Called when a new connection for this protocol found. */
-+static int gre_new(struct ip_conntrack *ct,
-+		   struct iphdr *iph, size_t len)
-+{ 
-+	DEBUGP(": ");
-+	DUMP_TUPLE_GRE(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-+
-+	/* initialize to sane value.  Ideally a conntrack helper
-+	 * (e.g. in case of pptp) is increasing them */
-+	ct->proto.gre.stream_timeout = GRE_STREAM_TIMEOUT;
-+	ct->proto.gre.timeout = GRE_TIMEOUT;
-+
-+	return 1;
-+}
-+
-+/* Called when a conntrack entry has already been removed from the hashes
-+ * and is about to be deleted from memory */
-+static void gre_destroy(struct ip_conntrack *ct)
-+{
-+	struct ip_conntrack_expect *master = ct->master;
-+
-+	DEBUGP(" entering\n");
-+
-+	if (!master) {
-+		DEBUGP("no master exp for ct %p\n", ct);
-+		return;
-+	}
-+
-+	ip_ct_gre_keymap_destroy(master);
-+}
-+
-+/* protocol helper struct */
-+static struct ip_conntrack_protocol gre = { { NULL, NULL }, IPPROTO_GRE,
-+					    "gre", 
-+					    gre_pkt_to_tuple,
-+					    gre_invert_tuple,
-+					    gre_print_tuple,
-+					    gre_print_conntrack,
-+					    gre_packet,
-+					    gre_new,
-+					    gre_destroy,
-+					    NULL,
-+					    THIS_MODULE };
-+
-+/* ip_conntrack_proto_gre initialization */
-+static int __init init(void)
-+{
-+	int retcode;
-+
-+	if ((retcode = ip_conntrack_protocol_register(&gre))) {
-+                printk(KERN_ERR "Unable to register conntrack protocol "
-+			        "helper for gre: %d\n",	retcode);
-+		return -EIO;
-+	}
-+
-+	return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+	struct list_head *pos, *n;
-+
-+	/* delete all keymap entries */
-+	WRITE_LOCK(&ip_ct_gre_lock);
-+	list_for_each_safe(pos, n, &gre_keymap_list) {
-+		DEBUGP("deleting keymap %p at module unload time\n", pos);
-+		list_del(pos);
-+		kfree(pos);
-+	}
-+	WRITE_UNLOCK(&ip_ct_gre_lock);
-+
-+	ip_conntrack_protocol_unregister(&gre); 
-+}
-+
-+EXPORT_SYMBOL(ip_ct_gre_keymap_add);
-+EXPORT_SYMBOL(ip_ct_gre_keymap_change);
-+EXPORT_SYMBOL(ip_ct_gre_keymap_destroy);
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_nat_core.c
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/ip_nat_core.c
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_nat_core.c
-@@ -424,7 +424,7 @@ get_unique_tuple(struct ip_conntrack_tup
- 	*tuple = *orig_tuple;
- 	while ((rptr = find_best_ips_proto_fast(tuple, mr, conntrack, hooknum))
- 	       != NULL) {
--		DEBUGP("Found best for "); DUMP_TUPLE(tuple);
-+		DEBUGP("Found best for "); DUMP_TUPLE_RAW(tuple);
- 		/* 3) The per-protocol part of the manip is made to
- 		   map into the range to make a unique tuple. */
- 
-@@ -564,9 +564,9 @@ ip_nat_setup_info(struct ip_conntrack *c
- 		       HOOK2MANIP(hooknum)==IP_NAT_MANIP_SRC ? "SRC" : "DST",
- 		       conntrack);
- 		DEBUGP("Original: ");
--		DUMP_TUPLE(&orig_tp);
-+		DUMP_TUPLE_RAW(&orig_tp);
- 		DEBUGP("New: ");
--		DUMP_TUPLE(&new_tuple);
-+		DUMP_TUPLE_RAW(&new_tuple);
- #endif
- 
- 		/* We now have two tuples (SRCIP/SRCPT/DSTIP/DSTPT):
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_nat_pptp.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_nat_pptp.c
-@@ -0,0 +1,482 @@
-+/*
-+ * ip_nat_pptp.c	- Version 1.5
-+ *
-+ * NAT support for PPTP (Point to Point Tunneling Protocol).
-+ * PPTP is a a protocol for creating virtual private networks.
-+ * It is a specification defined by Microsoft and some vendors
-+ * working with Microsoft.  PPTP is built on top of a modified
-+ * version of the Internet Generic Routing Encapsulation Protocol.
-+ * GRE is defined in RFC 1701 and RFC 1702.  Documentation of
-+ * PPTP can be found in RFC 2637
-+ *
-+ * (C) 2000-2003 by Harald Welte <laforge@gnumonks.org>
-+ *
-+ * Development of this code funded by Astaro AG (http://www.astaro.com/)
-+ *
-+ * TODO: - Support for multiple calls within one session
-+ * 	   (needs netfilter newnat code)
-+ * 	 - NAT to a unique tuple, not to TCP source port
-+ * 	   (needs netfilter tuple reservation)
-+ *
-+ * Changes:
-+ *     2002-02-10 - Version 1.3
-+ *       - Use ip_nat_mangle_tcp_packet() because of cloned skb's
-+ *	   in local connections (Philip Craig <philipc@snapgear.com>)
-+ *       - add checks for magicCookie and pptp version
-+ *       - make argument list of pptp_{out,in}bound_packet() shorter
-+ *       - move to C99 style initializers
-+ *       - print version number at module loadtime
-+ *     2003-09-22 - Version 1.5
-+ *       - use SNATed tcp sourceport as callid, since we get called before
-+ *         TCP header is mangled (Philip Craig <philipc@snapgear.com>)
-+ * 
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/ip.h>
-+#include <linux/tcp.h>
-+#include <net/tcp.h>
-+#include <linux/netfilter_ipv4/ip_nat.h>
-+#include <linux/netfilter_ipv4/ip_nat_rule.h>
-+#include <linux/netfilter_ipv4/ip_nat_helper.h>
-+#include <linux/netfilter_ipv4/ip_nat_pptp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
-+
-+#define IP_NAT_PPTP_VERSION "1.5"
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Harald Welte <laforge@gnumonks.org>");
-+MODULE_DESCRIPTION("Netfilter NAT helper module for PPTP");
-+
-+
-+#if 0
-+#include "ip_conntrack_pptp_priv.h"
-+#define DEBUGP(format, args...) printk(KERN_DEBUG __FILE__ ":" __FUNCTION__ \
-+				       ": " format, ## args)
-+#else
-+#define DEBUGP(format, args...)
-+#endif
-+
-+static unsigned int
-+pptp_nat_expected(struct sk_buff **pskb,
-+		  unsigned int hooknum,
-+		  struct ip_conntrack *ct,
-+		  struct ip_nat_info *info)
-+{
-+	struct ip_conntrack *master = master_ct(ct);
-+	struct ip_nat_multi_range mr;
-+	struct ip_ct_pptp_master *ct_pptp_info;
-+	struct ip_nat_pptp *nat_pptp_info;
-+	u_int32_t newip, newcid;
-+	int ret;
-+
-+	IP_NF_ASSERT(info);
-+	IP_NF_ASSERT(master);
-+	IP_NF_ASSERT(!(info->initialized & (1 << HOOK2MANIP(hooknum))));
-+
-+	DEBUGP("we have a connection!\n");
-+
-+	LOCK_BH(&ip_pptp_lock);
-+	ct_pptp_info = &master->help.ct_pptp_info;
-+	nat_pptp_info = &master->nat.help.nat_pptp_info;
-+
-+	/* need to alter GRE tuple because conntrack expectfn() used 'wrong'
-+	 * (unmanipulated) values */
-+	if (HOOK2MANIP(hooknum) == IP_NAT_MANIP_DST) {
-+		DEBUGP("completing tuples with NAT info \n");
-+		/* we can do this, since we're unconfirmed */
-+		if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.gre.key ==
-+			htonl(ct_pptp_info->pac_call_id)) {	
-+			/* assume PNS->PAC */
-+			ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.gre.key =
-+				htonl(nat_pptp_info->pns_call_id);
-+			ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.gre.key =
-+				htonl(nat_pptp_info->pns_call_id);
-+			newip = master->tuplehash[IP_CT_DIR_REPLY].tuple.src.ip;
-+			newcid = htonl(nat_pptp_info->pac_call_id);
-+		} else {
-+			/* assume PAC->PNS */
-+			ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.gre.key =
-+				htonl(nat_pptp_info->pac_call_id);
-+			ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.gre.key =
-+				htonl(nat_pptp_info->pac_call_id);
-+			newip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+			newcid = htonl(nat_pptp_info->pns_call_id);
-+		}
-+	} else {
-+		if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.gre.key ==
-+			htonl(ct_pptp_info->pac_call_id)) {	
-+			/* assume PNS->PAC */
-+			newip = master->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+			newcid = htonl(ct_pptp_info->pns_call_id);
-+		}
-+		else {
-+			/* assume PAC->PNS */
-+			newip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
-+			newcid = htonl(ct_pptp_info->pac_call_id);
-+		}
-+	}
-+
-+	mr.rangesize = 1;
-+	mr.range[0].flags = IP_NAT_RANGE_MAP_IPS | IP_NAT_RANGE_PROTO_SPECIFIED;
-+	mr.range[0].min_ip = mr.range[0].max_ip = newip;
-+	mr.range[0].min = mr.range[0].max = 
-+		((union ip_conntrack_manip_proto ) { newcid }); 
-+	DEBUGP("change ip to %u.%u.%u.%u\n", 
-+		NIPQUAD(newip));
-+	DEBUGP("change key to 0x%x\n", ntohl(newcid));
-+	ret = ip_nat_setup_info(ct, &mr, hooknum);
-+
-+	UNLOCK_BH(&ip_pptp_lock);
-+
-+	return ret;
-+
-+}
-+
-+/* outbound packets == from PNS to PAC */
-+static inline unsigned int
-+pptp_outbound_pkt(struct sk_buff **pskb,
-+		  struct ip_conntrack *ct,
-+		  enum ip_conntrack_info ctinfo,
-+		  struct ip_conntrack_expect *exp)
-+
-+{
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *) iph + iph->ihl*4;
-+	struct pptp_pkt_hdr *pptph = (struct pptp_pkt_hdr *) 
-+					((void *)tcph + tcph->doff*4);
-+
-+	struct PptpControlHeader *ctlh;
-+	union pptp_ctrl_union pptpReq;
-+	struct ip_ct_pptp_master *ct_pptp_info = &ct->help.ct_pptp_info;
-+	struct ip_nat_pptp *nat_pptp_info = &ct->nat.help.nat_pptp_info;
-+
-+	u_int16_t msg, *cid = NULL, new_callid;
-+
-+	/* FIXME: size checks !!! */
-+	ctlh = (struct PptpControlHeader *) ((void *) pptph + sizeof(*pptph));
-+	pptpReq.rawreq = (void *) ((void *) ctlh + sizeof(*ctlh));
-+
-+	new_callid = htons(ct_pptp_info->pns_call_id);
-+	
-+	switch (msg = ntohs(ctlh->messageType)) {
-+		case PPTP_OUT_CALL_REQUEST:
-+			cid = &pptpReq.ocreq->callID;
-+			/* FIXME: ideally we would want to reserve a call ID
-+			 * here.  current netfilter NAT core is not able to do
-+			 * this :( For now we use TCP source port. This breaks
-+			 * multiple calls within one control session */
-+
-+			/* save original call ID in nat_info */
-+			nat_pptp_info->pns_call_id = ct_pptp_info->pns_call_id;
-+
-+			/* don't use tcph->source since we are at a DSTmanip
-+			 * hook (e.g. PREROUTING) and pkt is not mangled yet */
-+			new_callid = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.tcp.port;
-+
-+			/* save new call ID in ct info */
-+			ct_pptp_info->pns_call_id = ntohs(new_callid);
-+			break;
-+		case PPTP_IN_CALL_REPLY:
-+			cid = &pptpReq.icreq->callID;
-+			break;
-+		case PPTP_CALL_CLEAR_REQUEST:
-+			cid = &pptpReq.clrreq->callID;
-+			break;
-+		default:
-+			DEBUGP("unknown outbound packet 0x%04x:%s\n", msg,
-+			      (msg <= PPTP_MSG_MAX)? strMName[msg]:strMName[0]);
-+			/* fall through */
-+
-+		case PPTP_SET_LINK_INFO:
-+			/* only need to NAT in case PAC is behind NAT box */
-+		case PPTP_START_SESSION_REQUEST:
-+		case PPTP_START_SESSION_REPLY:
-+		case PPTP_STOP_SESSION_REQUEST:
-+		case PPTP_STOP_SESSION_REPLY:
-+		case PPTP_ECHO_REQUEST:
-+		case PPTP_ECHO_REPLY:
-+			/* no need to alter packet */
-+			return NF_ACCEPT;
-+	}
-+
-+	IP_NF_ASSERT(cid);
-+
-+	DEBUGP("altering call id from 0x%04x to 0x%04x\n",
-+		ntohs(*cid), ntohs(new_callid));
-+
-+	/* mangle packet */
-+	ip_nat_mangle_tcp_packet(pskb, ct, ctinfo, (void *)cid - (void *)pptph,
-+				 sizeof(new_callid), (char *)&new_callid,
-+				 sizeof(new_callid));
-+
-+	return NF_ACCEPT;
-+}
-+
-+/* inbound packets == from PAC to PNS */
-+static inline unsigned int
-+pptp_inbound_pkt(struct sk_buff **pskb,
-+		 struct ip_conntrack *ct,
-+		 enum ip_conntrack_info ctinfo,
-+		 struct ip_conntrack_expect *oldexp)
-+{
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *) iph + iph->ihl*4;
-+	struct pptp_pkt_hdr *pptph = (struct pptp_pkt_hdr *) 
-+					((void *)tcph + tcph->doff*4);
-+
-+	struct PptpControlHeader *ctlh;
-+	union pptp_ctrl_union pptpReq;
-+	struct ip_ct_pptp_master *ct_pptp_info = &ct->help.ct_pptp_info;
-+	struct ip_nat_pptp *nat_pptp_info = &ct->nat.help.nat_pptp_info;
-+
-+	u_int16_t msg, new_cid = 0, new_pcid, *pcid = NULL, *cid = NULL;
-+	u_int32_t old_dst_ip;
-+
-+	struct ip_conntrack_tuple t, inv_t;
-+	struct ip_conntrack_tuple *orig_t, *reply_t;
-+
-+	/* FIXME: size checks !!! */
-+	ctlh = (struct PptpControlHeader *) ((void *) pptph + sizeof(*pptph));
-+	pptpReq.rawreq = (void *) ((void *) ctlh + sizeof(*ctlh));
-+
-+	new_pcid = htons(nat_pptp_info->pns_call_id);
-+
-+	switch (msg = ntohs(ctlh->messageType)) {
-+	case PPTP_OUT_CALL_REPLY:
-+		pcid = &pptpReq.ocack->peersCallID;	
-+		cid = &pptpReq.ocack->callID;
-+		if (!oldexp) {
-+			DEBUGP("outcall but no expectation\n");
-+			break;
-+		}
-+		old_dst_ip = oldexp->tuple.dst.ip;
-+		t = oldexp->tuple;
-+		invert_tuplepr(&inv_t, &t);
-+
-+		/* save original PAC call ID in nat_info */
-+		nat_pptp_info->pac_call_id = ct_pptp_info->pac_call_id;
-+
-+		/* alter expectation */
-+		orig_t = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
-+		reply_t = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
-+		if (t.src.ip == orig_t->src.ip && t.dst.ip == orig_t->dst.ip) {
-+			/* expectation for PNS->PAC direction */
-+			t.src.u.gre.key = htonl(nat_pptp_info->pns_call_id);
-+			t.dst.u.gre.key = htonl(ct_pptp_info->pac_call_id);
-+			inv_t.src.ip = reply_t->src.ip;
-+			inv_t.dst.ip = reply_t->dst.ip;
-+			inv_t.src.u.gre.key = htonl(nat_pptp_info->pac_call_id);
-+			inv_t.dst.u.gre.key = htonl(ct_pptp_info->pns_call_id);
-+		} else {
-+			/* expectation for PAC->PNS direction */
-+			t.src.u.gre.key = htonl(nat_pptp_info->pac_call_id);
-+			t.dst.u.gre.key = htonl(ct_pptp_info->pns_call_id);
-+			inv_t.src.ip = orig_t->src.ip;
-+			inv_t.dst.ip = orig_t->dst.ip;
-+			inv_t.src.u.gre.key = htonl(nat_pptp_info->pns_call_id);
-+			inv_t.dst.u.gre.key = htonl(ct_pptp_info->pac_call_id);
-+		}
-+
-+		if (!ip_conntrack_change_expect(oldexp, &t)) {
-+			DEBUGP("successfully changed expect\n");
-+		} else {
-+			DEBUGP("can't change expect\n");
-+		}
-+		if (oldexp->proto.gre.keymap_orig)
-+			ip_ct_gre_keymap_change(oldexp->proto.gre.keymap_orig, 
-+						&t);
-+		if (oldexp->proto.gre.keymap_reply)
-+			ip_ct_gre_keymap_change(oldexp->proto.gre.keymap_reply, 
-+						&inv_t);
-+		break;
-+	case PPTP_IN_CALL_CONNECT:
-+		pcid = &pptpReq.iccon->peersCallID;
-+		if (!oldexp)
-+			break;
-+		old_dst_ip = oldexp->tuple.dst.ip;
-+		t = oldexp->tuple;
-+
-+		/* alter expectation, no need for callID */
-+		if (t.dst.ip == ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip) {
-+			/* expectation for PNS->PAC direction */
-+			t.src.ip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+		} else {
-+			/* expectation for PAC->PNS direction */
-+			t.dst.ip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+		}
-+
-+		if (!ip_conntrack_change_expect(oldexp, &t)) {
-+			DEBUGP("successfully changed expect\n");
-+		} else {
-+			DEBUGP("can't change expect\n");
-+		}
-+		break;
-+	case PPTP_IN_CALL_REQUEST:
-+		/* only need to nat in case PAC is behind NAT box */
-+		break;
-+	case PPTP_WAN_ERROR_NOTIFY:
-+		pcid = &pptpReq.wanerr->peersCallID;
-+		break;
-+	case PPTP_CALL_DISCONNECT_NOTIFY:
-+		pcid = &pptpReq.disc->callID;
-+		break;
-+	case PPTP_SET_LINK_INFO:
-+		pcid = &pptpReq.setlink->peersCallID;
-+		break;
-+
-+	default:
-+		DEBUGP("unknown inbound packet %s\n",
-+			(msg <= PPTP_MSG_MAX)? strMName[msg]:strMName[0]);
-+		/* fall through */
-+
-+	case PPTP_START_SESSION_REQUEST:
-+	case PPTP_START_SESSION_REPLY:
-+	case PPTP_STOP_SESSION_REQUEST:
-+	case PPTP_STOP_SESSION_REPLY:
-+	case PPTP_ECHO_REQUEST:
-+	case PPTP_ECHO_REPLY:
-+		/* no need to alter packet */
-+		return NF_ACCEPT;
-+	}
-+
-+	/* mangle packet */
-+	IP_NF_ASSERT(pcid);
-+	DEBUGP("altering peer call id from 0x%04x to 0x%04x\n",
-+		ntohs(*pcid), ntohs(new_pcid));
-+	ip_nat_mangle_tcp_packet(pskb, ct, ctinfo, (void *)pcid - (void *)pptph,
-+				 sizeof(new_pcid), (char *)&new_pcid, 
-+				 sizeof(new_pcid));
-+
-+	if (new_cid) {
-+		IP_NF_ASSERT(cid);
-+		DEBUGP("altering call id from 0x%04x to 0x%04x\n",
-+			ntohs(*cid), ntohs(new_cid));
-+		ip_nat_mangle_tcp_packet(pskb, ct, ctinfo, 
-+					 (void *)cid - (void *)pptph, 
-+					 sizeof(new_cid), (char *)&new_cid, 
-+					 sizeof(new_cid));
-+	}
-+
-+	/* great, at least we don't need to resize packets */
-+	return NF_ACCEPT;
-+}
-+
-+
-+static unsigned int tcp_help(struct ip_conntrack *ct,
-+			     struct ip_conntrack_expect *exp,
-+			     struct ip_nat_info *info,
-+			     enum ip_conntrack_info ctinfo,
-+			     unsigned int hooknum, struct sk_buff **pskb)
-+{
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *) iph + iph->ihl*4;
-+	unsigned int datalen = (*pskb)->len - iph->ihl*4 - tcph->doff*4;
-+	struct pptp_pkt_hdr *pptph;
-+
-+	int dir;
-+
-+	DEBUGP("entering\n");
-+
-+	/* Only mangle things once: DST for original direction
-+	   and SRC for reply direction. */
-+	dir = CTINFO2DIR(ctinfo);
-+	if (!((HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC
-+	     && dir == IP_CT_DIR_ORIGINAL)
-+	      || (HOOK2MANIP(hooknum) == IP_NAT_MANIP_DST
-+		  && dir == IP_CT_DIR_REPLY))) {
-+		DEBUGP("Not touching dir %s at hook %s\n",
-+		       dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
-+		       hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+		       : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+		       : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT"
-+		       : hooknum == NF_IP_LOCAL_IN ? "INPUT" : "???");
-+		return NF_ACCEPT;
-+	}
-+
-+	/* if packet is too small, just skip it */
-+	if (datalen < sizeof(struct pptp_pkt_hdr)+
-+		      sizeof(struct PptpControlHeader)) {
-+		DEBUGP("pptp packet too short\n");
-+		return NF_ACCEPT;	
-+	}
-+
-+	pptph = (struct pptp_pkt_hdr *) ((void *)tcph + tcph->doff*4);
-+
-+	/* if it's not a control message, we can't handle it */
-+	if (ntohs(pptph->packetType) != PPTP_PACKET_CONTROL ||
-+	    ntohl(pptph->magicCookie) != PPTP_MAGIC_COOKIE) {
-+		DEBUGP("not a pptp control packet\n");
-+		return NF_ACCEPT;
-+	}
-+
-+	LOCK_BH(&ip_pptp_lock);
-+
-+	if (dir == IP_CT_DIR_ORIGINAL) {
-+		/* reuqests sent by client to server (PNS->PAC) */
-+		pptp_outbound_pkt(pskb, ct, ctinfo, exp);
-+	} else {
-+		/* response from the server to the client (PAC->PNS) */
-+		pptp_inbound_pkt(pskb, ct, ctinfo, exp);
-+	}
-+
-+	UNLOCK_BH(&ip_pptp_lock);
-+
-+	return NF_ACCEPT;
-+}
-+
-+/* nat helper struct for control connection */
-+static struct ip_nat_helper pptp_tcp_helper = { 
-+	.list = { NULL, NULL },
-+	.name = "pptp", 
-+	.flags = IP_NAT_HELPER_F_ALWAYS, 
-+	.me = THIS_MODULE,
-+	.tuple = { .src = { .ip = 0, 
-+			    .u = { .tcp = { .port = 
-+				    	__constant_htons(PPTP_CONTROL_PORT) } 
-+				 } 
-+			  },
-+	  	   .dst = { .ip = 0, 
-+			    .u = { .all = 0 }, 
-+			    .protonum = IPPROTO_TCP 
-+		   	  } 
-+		 },
-+
-+	.mask = { .src = { .ip = 0, 
-+			   .u = { .tcp = { .port = 0xFFFF } } 
-+			 },
-+		  .dst = { .ip = 0, 
-+			   .u = { .all = 0 }, 
-+			   .protonum = 0xFFFF 
-+		  	 } 
-+		},
-+	.help = tcp_help, 
-+	.expect = pptp_nat_expected 
-+};
-+
-+			  
-+static int __init init(void)
-+{
-+	DEBUGP("%s: registering NAT helper\n", __FILE__);
-+	if (ip_nat_helper_register(&pptp_tcp_helper)) {
-+		printk(KERN_ERR "Unable to register NAT application helper "
-+				"for pptp\n");
-+		return -EIO;
-+	}
-+
-+	printk("ip_nat_pptp version %s loaded\n", IP_NAT_PPTP_VERSION);
-+	return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+	DEBUGP("cleanup_module\n" );
-+	ip_nat_helper_unregister(&pptp_tcp_helper);
-+	printk("ip_nat_pptp version %s unloaded\n", IP_NAT_PPTP_VERSION);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_nat_proto_gre.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_nat_proto_gre.c
-@@ -0,0 +1,202 @@
-+/*
-+ * ip_nat_proto_gre.c - Version 1.2
-+ *
-+ * NAT protocol helper module for GRE.
-+ *
-+ * GRE is a generic encapsulation protocol, which is generally not very
-+ * suited for NAT, as it has no protocol-specific part as port numbers.
-+ *
-+ * It has an optional key field, which may help us distinguishing two 
-+ * connections between the same two hosts.
-+ *
-+ * GRE is defined in RFC 1701 and RFC 1702, as well as RFC 2784 
-+ *
-+ * PPTP is built on top of a modified version of GRE, and has a mandatory
-+ * field called "CallID", which serves us for the same purpose as the key
-+ * field in plain GRE.
-+ *
-+ * Documentation about PPTP can be found in RFC 2637
-+ *
-+ * (C) 2000-2003 by Harald Welte <laforge@gnumonks.org>
-+ *
-+ * Development of this code funded by Astaro AG (http://www.astaro.com/)
-+ *
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/ip.h>
-+#include <linux/netfilter_ipv4/ip_nat.h>
-+#include <linux/netfilter_ipv4/ip_nat_rule.h>
-+#include <linux/netfilter_ipv4/ip_nat_protocol.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Harald Welte <laforge@gnumonks.org>");
-+MODULE_DESCRIPTION("Netfilter NAT protocol helper module for GRE");
-+
-+#if 0
-+#define DEBUGP(format, args...) printk(KERN_DEBUG __FILE__ ":" __FUNCTION__ \
-+				       ": " format, ## args)
-+#else
-+#define DEBUGP(x, args...)
-+#endif
-+
-+/* is key in given range between min and max */
-+static int
-+gre_in_range(const struct ip_conntrack_tuple *tuple,
-+	     enum ip_nat_manip_type maniptype,
-+	     const union ip_conntrack_manip_proto *min,
-+	     const union ip_conntrack_manip_proto *max)
-+{
-+	u_int32_t key;
-+
-+	if (maniptype == IP_NAT_MANIP_SRC)
-+		key = tuple->src.u.gre.key;
-+	else
-+		key = tuple->dst.u.gre.key;
-+
-+	return ntohl(key) >= ntohl(min->gre.key)
-+		&& ntohl(key) <= ntohl(max->gre.key);
-+}
-+
-+/* generate unique tuple ... */
-+static int 
-+gre_unique_tuple(struct ip_conntrack_tuple *tuple,
-+		 const struct ip_nat_range *range,
-+		 enum ip_nat_manip_type maniptype,
-+		 const struct ip_conntrack *conntrack)
-+{
-+	u_int32_t min, i, range_size;
-+	u_int32_t key = 0, *keyptr;
-+
-+	if (maniptype == IP_NAT_MANIP_SRC)
-+		keyptr = &tuple->src.u.gre.key;
-+	else
-+		keyptr = &tuple->dst.u.gre.key;
-+
-+	if (!(range->flags & IP_NAT_RANGE_PROTO_SPECIFIED)) {
-+
-+		DEBUGP("%p: NATing GRE PPTP\n", conntrack);
-+		min = 1;
-+		range_size = 0xffff;
-+
-+	} else {
-+		min = ntohl(range->min.gre.key);
-+		range_size = ntohl(range->max.gre.key) - min + 1;
-+	}
-+
-+	DEBUGP("min = %u, range_size = %u\n", min, range_size); 
-+
-+	for (i = 0; i < range_size; i++, key++) {
-+		*keyptr = htonl(min + key % range_size);
-+		if (!ip_nat_used_tuple(tuple, conntrack))
-+			return 1;
-+	}
-+
-+	DEBUGP("%p: no NAT mapping\n", conntrack);
-+
-+	return 0;
-+}
-+
-+/* manipulate a GRE packet according to maniptype */
-+static void 
-+gre_manip_pkt(struct iphdr *iph, size_t len, 
-+	      const struct ip_conntrack_manip *manip,
-+	      enum ip_nat_manip_type maniptype)
-+{
-+	struct gre_hdr *greh = (struct gre_hdr *)((u_int32_t *)iph+iph->ihl);
-+	struct gre_hdr_pptp *pgreh = (struct gre_hdr_pptp *) greh;
-+
-+	/* we only have destination manip of a packet, since 'source key' 
-+	 * is not present in the packet itself */
-+	if (maniptype == IP_NAT_MANIP_DST) {
-+		/* key manipulation is always dest */
-+		switch (greh->version) {
-+		case 0:
-+			if (!greh->key) {
-+				DEBUGP("can't nat GRE w/o key\n");
-+				break;
-+			}
-+			if (greh->csum) {
-+				/* FIXME: Never tested this code... */
-+				*(gre_csum(greh)) = 
-+					ip_nat_cheat_check(~*(gre_key(greh)),
-+							manip->u.gre.key,
-+							*(gre_csum(greh)));
-+			}
-+			*(gre_key(greh)) = manip->u.gre.key;
-+			break;
-+		case GRE_VERSION_PPTP:
-+			DEBUGP("call_id -> 0x%04x\n", 
-+				ntohl(manip->u.gre.key));
-+			pgreh->call_id = htons(ntohl(manip->u.gre.key));
-+			break;
-+		default:
-+			DEBUGP("can't nat unknown GRE version\n");
-+			break;
-+		}
-+	}
-+}
-+
-+/* print out a nat tuple */
-+static unsigned int 
-+gre_print(char *buffer, 
-+	  const struct ip_conntrack_tuple *match,
-+	  const struct ip_conntrack_tuple *mask)
-+{
-+	unsigned int len = 0;
-+
-+	if (mask->src.u.gre.key)
-+		len += sprintf(buffer + len, "srckey=0x%x ", 
-+				ntohl(match->src.u.gre.key));
-+
-+	if (mask->dst.u.gre.key)
-+		len += sprintf(buffer + len, "dstkey=0x%x ",
-+				ntohl(match->src.u.gre.key));
-+
-+	return len;
-+}
-+
-+/* print a range of keys */
-+static unsigned int 
-+gre_print_range(char *buffer, const struct ip_nat_range *range)
-+{
-+	if (range->min.gre.key != 0 
-+	    || range->max.gre.key != 0xFFFF) {
-+		if (range->min.gre.key == range->max.gre.key)
-+			return sprintf(buffer, "key 0x%x ",
-+					ntohl(range->min.gre.key));
-+		else
-+			return sprintf(buffer, "keys 0x%u-0x%u ",
-+					ntohl(range->min.gre.key),
-+					ntohl(range->max.gre.key));
-+	} else
-+		return 0;
-+}
-+
-+/* nat helper struct */
-+static struct ip_nat_protocol gre = 
-+	{ { NULL, NULL }, "GRE", IPPROTO_GRE,
-+	  gre_manip_pkt,
-+	  gre_in_range,
-+	  gre_unique_tuple,
-+	  gre_print,
-+	  gre_print_range 
-+	};
-+				  
-+static int __init init(void)
-+{
-+        if (ip_nat_protocol_register(&gre))
-+                return -EIO;
-+
-+        return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+        ip_nat_protocol_unregister(&gre);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -36,23 +36,32 @@ obj-$(CONFIG_IP_NF_AMANDA) += ip_conntra
- ifdef CONFIG_IP_NF_AMANDA
- 	export-objs += ip_conntrack_amanda.o
- endif
--
- obj-$(CONFIG_IP_NF_TFTP) += ip_conntrack_tftp.o
- obj-$(CONFIG_IP_NF_FTP) += ip_conntrack_ftp.o
- ifdef CONFIG_IP_NF_FTP
- 	export-objs += ip_conntrack_ftp.o
- endif
--
- obj-$(CONFIG_IP_NF_IRC) += ip_conntrack_irc.o
- ifdef CONFIG_IP_NF_IRC
- 	export-objs += ip_conntrack_irc.o
- endif
-+obj-$(CONFIG_IP_NF_CT_PROTO_GRE) += ip_conntrack_proto_gre.o
-+ifdef CONFIG_IP_NF_CT_PROTO_GRE
-+	export-objs += ip_conntrack_proto_gre.o
-+endif
-+obj-$(CONFIG_IP_NF_PPTP) += ip_conntrack_pptp.o
-+ifdef CONFIG_IP_NF_NAT_PPTP
-+	export-objs += ip_conntrack_pptp.o
-+endif
-+
- 
- # NAT helpers 
- obj-$(CONFIG_IP_NF_NAT_AMANDA) += ip_nat_amanda.o
- obj-$(CONFIG_IP_NF_NAT_TFTP) += ip_nat_tftp.o
- obj-$(CONFIG_IP_NF_NAT_FTP) += ip_nat_ftp.o
- obj-$(CONFIG_IP_NF_NAT_IRC) += ip_nat_irc.o
-+obj-$(CONFIG_IP_NF_NAT_PROTO_GRE) += ip_nat_proto_gre.o
-+obj-$(CONFIG_IP_NF_NAT_PPTP) += ip_nat_pptp.o
- 
- # generic IP tables 
- obj-$(CONFIG_IP_NF_IPTABLES) += ip_tables.o
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_pptp.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_pptp.c
-@@ -0,0 +1,635 @@
-+/*
-+ * ip_conntrack_pptp.c	- Version 1.9
-+ *
-+ * Connection tracking support for PPTP (Point to Point Tunneling Protocol).
-+ * PPTP is a a protocol for creating virtual private networks.
-+ * It is a specification defined by Microsoft and some vendors
-+ * working with Microsoft.  PPTP is built on top of a modified
-+ * version of the Internet Generic Routing Encapsulation Protocol.
-+ * GRE is defined in RFC 1701 and RFC 1702.  Documentation of
-+ * PPTP can be found in RFC 2637
-+ *
-+ * (C) 2000-2003 by Harald Welte <laforge@gnumonks.org>
-+ *
-+ * Development of this code funded by Astaro AG (http://www.astaro.com/)
-+ *
-+ * Limitations:
-+ * 	 - We blindly assume that control connections are always
-+ * 	   established in PNS->PAC direction.  This is a violation
-+ * 	   of RFFC2673
-+ *
-+ * TODO: - finish support for multiple calls within one session
-+ * 	   (needs expect reservations in newnat)
-+ *	 - testing of incoming PPTP calls 
-+ *
-+ * Changes: 
-+ * 	2002-02-05 - Version 1.3
-+ * 	  - Call ip_conntrack_unexpect_related() from 
-+ * 	    pptp_timeout_related() to destroy expectations in case
-+ * 	    CALL_DISCONNECT_NOTIFY or tcp fin packet was seen
-+ * 	    (Philip Craig <philipc@snapgear.com>)
-+ * 	  - Add Version information at module loadtime
-+ * 	2002-02-10 - Version 1.6
-+ * 	  - move to C99 style initializers
-+ * 	  - remove second expectation if first arrives
-+ *
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/netfilter.h>
-+#include <linux/ip.h>
-+#include <net/checksum.h>
-+#include <net/tcp.h>
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
-+
-+#define IP_CT_PPTP_VERSION "1.9"
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Harald Welte <laforge@gnumonks.org>");
-+MODULE_DESCRIPTION("Netfilter connection tracking helper module for PPTP");
-+
-+DECLARE_LOCK(ip_pptp_lock);
-+
-+#if 0
-+#include "ip_conntrack_pptp_priv.h"
-+#define DEBUGP(format, args...)	printk(KERN_DEBUG __FILE__ ":" __FUNCTION__ \
-+					": " format, ## args)
-+#else
-+#define DEBUGP(format, args...)
-+#endif
-+
-+#define SECS *HZ
-+#define MINS * 60 SECS
-+#define HOURS * 60 MINS
-+#define DAYS * 24 HOURS
-+
-+#define PPTP_GRE_TIMEOUT 		(10 MINS)
-+#define PPTP_GRE_STREAM_TIMEOUT 	(5 DAYS)
-+
-+static int pptp_expectfn(struct ip_conntrack *ct)
-+{
-+	struct ip_conntrack *master;
-+	struct ip_conntrack_expect *exp;
-+
-+	DEBUGP("increasing timeouts\n");
-+	/* increase timeout of GRE data channel conntrack entry */
-+	ct->proto.gre.timeout = PPTP_GRE_TIMEOUT;
-+	ct->proto.gre.stream_timeout = PPTP_GRE_STREAM_TIMEOUT;
-+
-+	master = master_ct(ct);
-+	if (!master) {
-+		DEBUGP(" no master!!!\n");
-+		return 0;
-+	}
-+
-+	exp = ct->master;
-+	if (!exp) {
-+		DEBUGP("no expectation!!\n");
-+		return 0;
-+	}
-+
-+	DEBUGP("completing tuples with ct info\n");
-+	/* we can do this, since we're unconfirmed */
-+	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.gre.key == 
-+		htonl(master->help.ct_pptp_info.pac_call_id)) {	
-+		/* assume PNS->PAC */
-+		ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.gre.key = 
-+			htonl(master->help.ct_pptp_info.pns_call_id);
-+		ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.gre.key =
-+			htonl(master->help.ct_pptp_info.pns_call_id);
-+	} else {
-+		/* assume PAC->PNS */
-+		ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.gre.key =
-+			htonl(master->help.ct_pptp_info.pac_call_id);
-+		ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.gre.key =
-+			htonl(master->help.ct_pptp_info.pac_call_id);
-+	}
-+	
-+	/* delete other expectation */
-+	if (exp->expected_list.next != &exp->expected_list) {
-+		struct ip_conntrack_expect *other_exp;
-+		struct list_head *cur_item, *next;
-+
-+		for (cur_item = master->sibling_list.next;
-+		     cur_item != &master->sibling_list; cur_item = next) {
-+			next = cur_item->next;
-+			other_exp = list_entry(cur_item,
-+					       struct ip_conntrack_expect,
-+					       expected_list);
-+			/* remove only if occurred at same sequence number */
-+			if (other_exp != exp && other_exp->seq == exp->seq) {
-+				DEBUGP("unexpecting other direction\n");
-+				ip_ct_gre_keymap_destroy(other_exp);
-+				ip_conntrack_unexpect_related(other_exp);
-+			}
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+/* timeout GRE data connections */
-+static int pptp_timeout_related(struct ip_conntrack *ct)
-+{
-+	struct list_head *cur_item, *next;
-+	struct ip_conntrack_expect *exp;
-+	enum ip_conntrack_info ctinfo;
-+	struct iphdr *iph;
-+
-+	/* FIXME: do we have to lock something ? */
-+	for (cur_item = ct->sibling_list.next;
-+	    cur_item != &ct->sibling_list; cur_item = next) {
-+		next = cur_item->next;
-+		exp = list_entry(cur_item, struct ip_conntrack_expect,
-+				 expected_list);
-+
-+		ip_ct_gre_keymap_destroy(exp);
-+		if (!exp->sibling) {
-+			ip_conntrack_unexpect_related(exp);
-+			continue;
-+		}
-+
-+		DEBUGP("setting timeout of conntrack %p to 0\n",
-+			exp->sibling);
-+		exp->sibling->proto.gre.timeout = 0;
-+		exp->sibling->proto.gre.stream_timeout = 0;
-+		ip_ct_refresh_acct(exp->sibling, ctinfo, iph, 0);
-+	}
-+
-+	return 0;
-+}
-+
-+/* expect GRE connections (PNS->PAC and PAC->PNS direction) */
-+static inline int
-+exp_gre(struct ip_conntrack *master,
-+	u_int32_t seq,
-+	u_int16_t callid,
-+	u_int16_t peer_callid)
-+{
-+	struct ip_conntrack_expect exp;
-+	struct ip_conntrack_tuple inv_tuple;
-+
-+	memset(&exp, 0, sizeof(exp));
-+	/* tuple in original direction, PNS->PAC */
-+	exp.tuple.src.ip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+	exp.tuple.src.u.gre.key = htonl(ntohs(peer_callid));
-+	exp.tuple.dst.ip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
-+	exp.tuple.dst.u.gre.key = htonl(ntohs(callid));
-+	exp.tuple.dst.protonum = IPPROTO_GRE;
-+
-+	exp.mask.src.ip = 0xffffffff;
-+	exp.mask.src.u.all = 0;
-+	exp.mask.dst.u.all = 0;
-+	exp.mask.dst.u.gre.key = 0xffffffff;
-+	exp.mask.dst.ip = 0xffffffff;
-+	exp.mask.dst.protonum = 0xffff;
-+			
-+	exp.seq = seq;
-+	exp.expectfn = pptp_expectfn;
-+
-+	exp.help.exp_pptp_info.pac_call_id = ntohs(callid);
-+	exp.help.exp_pptp_info.pns_call_id = ntohs(peer_callid);
-+
-+	DEBUGP("calling expect_related ");
-+	DUMP_TUPLE_RAW(&exp.tuple);
-+	
-+	/* Add GRE keymap entries */
-+	if (ip_ct_gre_keymap_add(&exp, &exp.tuple, 0) != 0)
-+		return 1;
-+
-+	invert_tuplepr(&inv_tuple, &exp.tuple);
-+	if (ip_ct_gre_keymap_add(&exp, &inv_tuple, 1) != 0) {
-+		ip_ct_gre_keymap_destroy(&exp);
-+		return 1;
-+	}
-+	
-+	if (ip_conntrack_expect_related(master, &exp) != 0) {
-+		ip_ct_gre_keymap_destroy(&exp);
-+		DEBUGP("cannot expect_related()\n");
-+		return 1;
-+	}
-+
-+	/* tuple in reply direction, PAC->PNS */
-+	exp.tuple.src.ip = master->tuplehash[IP_CT_DIR_REPLY].tuple.src.ip;
-+	exp.tuple.src.u.gre.key = htonl(ntohs(callid));
-+	exp.tuple.dst.ip = master->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+	exp.tuple.dst.u.gre.key = htonl(ntohs(peer_callid));
-+
-+	DEBUGP("calling expect_related ");
-+	DUMP_TUPLE_RAW(&exp.tuple);
-+	
-+	/* Add GRE keymap entries */
-+	ip_ct_gre_keymap_add(&exp, &exp.tuple, 0);
-+	invert_tuplepr(&inv_tuple, &exp.tuple);
-+	ip_ct_gre_keymap_add(&exp, &inv_tuple, 1);
-+	/* FIXME: cannot handle error correctly, since we need to free
-+	 * the above keymap :( */
-+	
-+	if (ip_conntrack_expect_related(master, &exp) != 0) {
-+		/* free the second pair of keypmaps */
-+		ip_ct_gre_keymap_destroy(&exp);
-+		DEBUGP("cannot expect_related():\n");
-+		return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+static inline int 
-+pptp_inbound_pkt(struct tcphdr *tcph,
-+		 struct pptp_pkt_hdr *pptph, 
-+		 size_t datalen,
-+		 struct ip_conntrack *ct,
-+		 enum ip_conntrack_info ctinfo)
-+{
-+	struct PptpControlHeader *ctlh;
-+        union pptp_ctrl_union pptpReq;
-+	
-+	struct ip_ct_pptp_master *info = &ct->help.ct_pptp_info;
-+	u_int16_t msg, *cid, *pcid;
-+	u_int32_t seq;	
-+
-+	ctlh = (struct PptpControlHeader *) 
-+		((char *) pptph + sizeof(struct pptp_pkt_hdr));
-+	pptpReq.rawreq = (void *) 
-+		((char *) ctlh + sizeof(struct PptpControlHeader));
-+
-+	msg = ntohs(ctlh->messageType);
-+	DEBUGP("inbound control message %s\n", strMName[msg]);
-+
-+	switch (msg) {
-+	case PPTP_START_SESSION_REPLY:
-+		/* server confirms new control session */
-+		if (info->sstate < PPTP_SESSION_REQUESTED) {
-+			DEBUGP("%s without START_SESS_REQUEST\n",
-+				strMName[msg]);
-+			break;
-+		}
-+		if (pptpReq.srep->resultCode == PPTP_START_OK)
-+			info->sstate = PPTP_SESSION_CONFIRMED;
-+		else 
-+			info->sstate = PPTP_SESSION_ERROR;
-+		break;
-+
-+	case PPTP_STOP_SESSION_REPLY:
-+		/* server confirms end of control session */
-+		if (info->sstate > PPTP_SESSION_STOPREQ) {
-+			DEBUGP("%s without STOP_SESS_REQUEST\n",
-+				strMName[msg]);
-+			break;
-+		}
-+		if (pptpReq.strep->resultCode == PPTP_STOP_OK)
-+			info->sstate = PPTP_SESSION_NONE;
-+		else
-+			info->sstate = PPTP_SESSION_ERROR;
-+		break;
-+
-+	case PPTP_OUT_CALL_REPLY:
-+		/* server accepted call, we now expect GRE frames */
-+		if (info->sstate != PPTP_SESSION_CONFIRMED) {
-+			DEBUGP("%s but no session\n", strMName[msg]);
-+			break;
-+		}
-+		if (info->cstate != PPTP_CALL_OUT_REQ &&
-+		    info->cstate != PPTP_CALL_OUT_CONF) {
-+			DEBUGP("%s without OUTCALL_REQ\n", strMName[msg]);
-+			break;
-+		}
-+		if (pptpReq.ocack->resultCode != PPTP_OUTCALL_CONNECT) {
-+			info->cstate = PPTP_CALL_NONE;
-+			break;
-+		}
-+
-+		cid = &pptpReq.ocack->callID;
-+		pcid = &pptpReq.ocack->peersCallID;
-+
-+		info->pac_call_id = ntohs(*cid);
-+		
-+		if (htons(info->pns_call_id) != *pcid) {
-+			DEBUGP("%s for unknown callid %u\n",
-+				strMName[msg], ntohs(*pcid));
-+			break;
-+		}
-+
-+		DEBUGP("%s, CID=%X, PCID=%X\n", strMName[msg], 
-+			ntohs(*cid), ntohs(*pcid));
-+		
-+		info->cstate = PPTP_CALL_OUT_CONF;
-+
-+		seq = ntohl(tcph->seq) + ((void *)pcid - (void *)pptph);
-+		if (exp_gre(ct, seq, *cid, *pcid) != 0)
-+			printk("ip_conntrack_pptp: error during exp_gre\n");
-+		break;
-+
-+	case PPTP_IN_CALL_REQUEST:
-+		/* server tells us about incoming call request */
-+		if (info->sstate != PPTP_SESSION_CONFIRMED) {
-+			DEBUGP("%s but no session\n", strMName[msg]);
-+			break;
-+		}
-+		pcid = &pptpReq.icack->peersCallID;
-+		DEBUGP("%s, PCID=%X\n", strMName[msg], ntohs(*pcid));
-+		info->cstate = PPTP_CALL_IN_REQ;
-+		info->pac_call_id= ntohs(*pcid);
-+		break;
-+
-+	case PPTP_IN_CALL_CONNECT:
-+		/* server tells us about incoming call established */
-+		if (info->sstate != PPTP_SESSION_CONFIRMED) {
-+			DEBUGP("%s but no session\n", strMName[msg]);
-+			break;
-+		}
-+		if (info->sstate != PPTP_CALL_IN_REP
-+		    && info->sstate != PPTP_CALL_IN_CONF) {
-+			DEBUGP("%s but never sent IN_CALL_REPLY\n",
-+				strMName[msg]);
-+			break;
-+		}
-+
-+		pcid = &pptpReq.iccon->peersCallID;
-+		cid = &info->pac_call_id;
-+
-+		if (info->pns_call_id != ntohs(*pcid)) {
-+			DEBUGP("%s for unknown CallID %u\n", 
-+				strMName[msg], ntohs(*cid));
-+			break;
-+		}
-+
-+		DEBUGP("%s, PCID=%X\n", strMName[msg], ntohs(*pcid));
-+		info->cstate = PPTP_CALL_IN_CONF;
-+
-+		/* we expect a GRE connection from PAC to PNS */
-+		seq = ntohl(tcph->seq) + ((void *)pcid - (void *)pptph);
-+		if (exp_gre(ct, seq, *cid, *pcid) != 0)
-+			printk("ip_conntrack_pptp: error during exp_gre\n");
-+
-+		break;
-+
-+	case PPTP_CALL_DISCONNECT_NOTIFY:
-+		/* server confirms disconnect */
-+		cid = &pptpReq.disc->callID;
-+		DEBUGP("%s, CID=%X\n", strMName[msg], ntohs(*cid));
-+		info->cstate = PPTP_CALL_NONE;
-+
-+		/* untrack this call id, unexpect GRE packets */
-+		pptp_timeout_related(ct);
-+		break;
-+
-+	case PPTP_WAN_ERROR_NOTIFY:
-+		break;
-+
-+	case PPTP_ECHO_REQUEST:
-+	case PPTP_ECHO_REPLY:
-+		/* I don't have to explain these ;) */
-+		break;
-+	default:
-+		DEBUGP("invalid %s (TY=%d)\n", (msg <= PPTP_MSG_MAX)
-+			? strMName[msg]:strMName[0], msg);
-+		break;
-+	}
-+
-+	return NF_ACCEPT;
-+
-+}
-+
-+static inline int
-+pptp_outbound_pkt(struct tcphdr *tcph,
-+		  struct pptp_pkt_hdr *pptph,
-+		  size_t datalen,
-+		  struct ip_conntrack *ct,
-+		  enum ip_conntrack_info ctinfo)
-+{
-+	struct PptpControlHeader *ctlh;
-+        union pptp_ctrl_union pptpReq;
-+	struct ip_ct_pptp_master *info = &ct->help.ct_pptp_info;
-+	u_int16_t msg, *cid, *pcid;
-+
-+	ctlh = (struct PptpControlHeader *) ((void *) pptph + sizeof(*pptph));
-+	pptpReq.rawreq = (void *) ((void *) ctlh + sizeof(*ctlh));
-+
-+	msg = ntohs(ctlh->messageType);
-+	DEBUGP("outbound control message %s\n", strMName[msg]);
-+
-+	switch (msg) {
-+	case PPTP_START_SESSION_REQUEST:
-+		/* client requests for new control session */
-+		if (info->sstate != PPTP_SESSION_NONE) {
-+			DEBUGP("%s but we already have one",
-+				strMName[msg]);
-+		}
-+		info->sstate = PPTP_SESSION_REQUESTED;
-+		break;
-+	case PPTP_STOP_SESSION_REQUEST:
-+		/* client requests end of control session */
-+		info->sstate = PPTP_SESSION_STOPREQ;
-+		break;
-+
-+	case PPTP_OUT_CALL_REQUEST:
-+		/* client initiating connection to server */
-+		if (info->sstate != PPTP_SESSION_CONFIRMED) {
-+			DEBUGP("%s but no session\n",
-+				strMName[msg]);
-+			break;
-+		}
-+		info->cstate = PPTP_CALL_OUT_REQ;
-+		/* track PNS call id */
-+		cid = &pptpReq.ocreq->callID;
-+		DEBUGP("%s, CID=%X\n", strMName[msg], ntohs(*cid));
-+		info->pns_call_id = ntohs(*cid);
-+		break;
-+	case PPTP_IN_CALL_REPLY:
-+		/* client answers incoming call */
-+		if (info->cstate != PPTP_CALL_IN_REQ
-+		    && info->cstate != PPTP_CALL_IN_REP) {
-+			DEBUGP("%s without incall_req\n", 
-+				strMName[msg]);
-+			break;
-+		}
-+		if (pptpReq.icack->resultCode != PPTP_INCALL_ACCEPT) {
-+			info->cstate = PPTP_CALL_NONE;
-+			break;
-+		}
-+		pcid = &pptpReq.icack->peersCallID;
-+		if (info->pac_call_id != ntohs(*pcid)) {
-+			DEBUGP("%s for unknown call %u\n", 
-+				strMName[msg], ntohs(*pcid));
-+			break;
-+		}
-+		DEBUGP("%s, CID=%X\n", strMName[msg], ntohs(*pcid));
-+		/* part two of the three-way handshake */
-+		info->cstate = PPTP_CALL_IN_REP;
-+		info->pns_call_id = ntohs(pptpReq.icack->callID);
-+		break;
-+
-+	case PPTP_CALL_CLEAR_REQUEST:
-+		/* client requests hangup of call */
-+		if (info->sstate != PPTP_SESSION_CONFIRMED) {
-+			DEBUGP("CLEAR_CALL but no session\n");
-+			break;
-+		}
-+		/* FUTURE: iterate over all calls and check if
-+		 * call ID is valid.  We don't do this without newnat,
-+		 * because we only know about last call */
-+		info->cstate = PPTP_CALL_CLEAR_REQ;
-+		break;
-+	case PPTP_SET_LINK_INFO:
-+		break;
-+	case PPTP_ECHO_REQUEST:
-+	case PPTP_ECHO_REPLY:
-+		/* I don't have to explain these ;) */
-+		break;
-+	default:
-+		DEBUGP("invalid %s (TY=%d)\n", (msg <= PPTP_MSG_MAX)? 
-+			strMName[msg]:strMName[0], msg);
-+		/* unknown: no need to create GRE masq table entry */
-+		break;
-+	}
-+
-+	return NF_ACCEPT;
-+}
-+
-+
-+/* track caller id inside control connection, call expect_related */
-+static int 
-+conntrack_pptp_help(const struct iphdr *iph, size_t len,
-+		    struct ip_conntrack *ct, enum ip_conntrack_info ctinfo)
-+
-+{
-+	struct pptp_pkt_hdr *pptph;
-+	
-+	struct tcphdr *tcph = (void *) iph + iph->ihl * 4;
-+	u_int32_t tcplen = len - iph->ihl * 4;
-+	u_int32_t datalen = tcplen - tcph->doff * 4;
-+	void *datalimit;
-+	int dir = CTINFO2DIR(ctinfo);
-+	struct ip_ct_pptp_master *info = &ct->help.ct_pptp_info;
-+
-+	int oldsstate, oldcstate;
-+	int ret;
-+
-+	/* don't do any tracking before tcp handshake complete */
-+	if (ctinfo != IP_CT_ESTABLISHED 
-+	    && ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY) {
-+		DEBUGP("ctinfo = %u, skipping\n", ctinfo);
-+		return NF_ACCEPT;
-+	}
-+	
-+	/* not a complete TCP header? */
-+	if (tcplen < sizeof(struct tcphdr) || tcplen < tcph->doff * 4) {
-+		DEBUGP("tcplen = %u\n", tcplen);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* checksum invalid? */
-+	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
-+			csum_partial((char *) tcph, tcplen, 0))) {
-+		printk(KERN_NOTICE __FILE__ ": bad csum\n");
-+		/* W2K PPTP server sends TCP packets with wrong checksum :(( */
-+		//return NF_ACCEPT;
-+	}
-+
-+	if (tcph->fin || tcph->rst) {
-+		DEBUGP("RST/FIN received, timeouting GRE\n");
-+		/* can't do this after real newnat */
-+		info->cstate = PPTP_CALL_NONE;
-+
-+		/* untrack this call id, unexpect GRE packets */
-+		pptp_timeout_related(ct);
-+	}
-+
-+
-+	pptph = (struct pptp_pkt_hdr *) ((void *) tcph + tcph->doff * 4);
-+	datalimit = (void *) pptph + datalen;
-+
-+	/* not a full pptp packet header? */
-+	if ((void *) pptph+sizeof(*pptph) >= datalimit) {
-+		DEBUGP("no full PPTP header, can't track\n");
-+		return NF_ACCEPT;
-+	}
-+	
-+	/* if it's not a control message we can't do anything with it */
-+        if (ntohs(pptph->packetType) != PPTP_PACKET_CONTROL ||
-+	    ntohl(pptph->magicCookie) != PPTP_MAGIC_COOKIE) {
-+		DEBUGP("not a control packet\n");
-+		return NF_ACCEPT;
-+	}
-+
-+	oldsstate = info->sstate;
-+	oldcstate = info->cstate;
-+
-+	LOCK_BH(&ip_pptp_lock);
-+
-+	/* FIXME: We just blindly assume that the control connection is always
-+	 * established from PNS->PAC.  However, RFC makes no guarantee */
-+	if (dir == IP_CT_DIR_ORIGINAL)
-+		/* client -> server (PNS -> PAC) */
-+		ret = pptp_outbound_pkt(tcph, pptph, datalen, ct, ctinfo);
-+	else
-+		/* server -> client (PAC -> PNS) */
-+		ret = pptp_inbound_pkt(tcph, pptph, datalen, ct, ctinfo);
-+	DEBUGP("sstate: %d->%d, cstate: %d->%d\n",
-+		oldsstate, info->sstate, oldcstate, info->cstate);
-+	UNLOCK_BH(&ip_pptp_lock);
-+
-+	return ret;
-+}
-+
-+/* control protocol helper */
-+static struct ip_conntrack_helper pptp = { 
-+	.list = { NULL, NULL },
-+	.name = "pptp", 
-+	.flags = IP_CT_HELPER_F_REUSE_EXPECT,
-+	.me = THIS_MODULE,
-+	.max_expected = 2,
-+	.timeout = 0,
-+	.tuple = { .src = { .ip = 0, 
-+		 	    .u = { .tcp = { .port =  
-+				    __constant_htons(PPTP_CONTROL_PORT) } } 
-+			  }, 
-+		   .dst = { .ip = 0, 
-+			    .u = { .all = 0 },
-+			    .protonum = IPPROTO_TCP
-+			  } 
-+		 },
-+	.mask = { .src = { .ip = 0, 
-+			   .u = { .tcp = { .port = 0xffff } } 
-+			 }, 
-+		  .dst = { .ip = 0, 
-+			   .u = { .all = 0 },
-+			   .protonum = 0xffff 
-+		 	 } 
-+		},
-+	.help = conntrack_pptp_help
-+};
-+
-+/* ip_conntrack_pptp initialization */
-+static int __init init(void)
-+{
-+	int retcode;
-+
-+	DEBUGP(__FILE__ ": registering helper\n");
-+	if ((retcode = ip_conntrack_helper_register(&pptp))) {
-+                printk(KERN_ERR "Unable to register conntrack application "
-+				"helper for pptp: %d\n", retcode);
-+		return -EIO;
-+	}
-+
-+	printk("ip_conntrack_pptp version %s loaded\n", IP_CT_PPTP_VERSION);
-+	return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+	ip_conntrack_helper_unregister(&pptp);
-+	printk("ip_conntrack_pptp version %s unloaded\n", IP_CT_PPTP_VERSION);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-+
-+EXPORT_SYMBOL(ip_pptp_lock);
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/606-netfilter_NETMAP.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,163 +0,0 @@
-Index: linux-2.4.35.4/Documentation/Configure.help
-===================================================================
---- linux-2.4.35.4.orig/Documentation/Configure.help
-+++ linux-2.4.35.4/Documentation/Configure.help
-@@ -3086,6 +3086,17 @@ CONFIG_IP_NF_TARGET_REDIRECT
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+NETMAP target support
-+CONFIG_IP_NF_TARGET_NETMAP
-+  NETMAP is an implementation of static 1:1 NAT mapping of network
-+  addresses. It maps the network address part, while keeping the
-+  host address part intact. It is similar to Fast NAT, except that
-+  Netfilter's connection tracking doesn't work well with Fast NAT.
-+
-+  If you want to compile it as a module, say M here and read
-+  Documentation/modules.txt.  The module will be called
-+  ipt_NETMAP.o.  If unsure, say `N'.
-+
- Packet mangling
- CONFIG_IP_NF_MANGLE
-   This option adds a `mangle' table to iptables: see the man page for
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -65,6 +65,7 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-       define_bool CONFIG_IP_NF_NAT_NEEDED y
-       dep_tristate '    MASQUERADE target support' CONFIG_IP_NF_TARGET_MASQUERADE $CONFIG_IP_NF_NAT
-       dep_tristate '    REDIRECT target support' CONFIG_IP_NF_TARGET_REDIRECT $CONFIG_IP_NF_NAT
-+      dep_tristate '    NETMAP target support' CONFIG_IP_NF_TARGET_NETMAP $CONFIG_IP_NF_NAT
-       if [ "$CONFIG_IP_NF_PPTP" = "m" ]; then
-         define_tristate CONFIG_IP_NF_NAT_PPTP m
-       else
-Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_NETMAP.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ipt_NETMAP.c
-@@ -0,0 +1,112 @@
-+/* NETMAP - static NAT mapping of IP network addresses (1:1).
-+   The mapping can be applied to source (POSTROUTING),
-+   destination (PREROUTING), or both (with separate rules).
-+
-+   Author: Svenning Soerensen <svenning@post5.tele.dk>
-+*/
-+
-+#include <linux/config.h>
-+#include <linux/ip.h>
-+#include <linux/module.h>
-+#include <linux/netdevice.h>
-+#include <linux/netfilter.h>
-+#include <linux/netfilter_ipv4.h>
-+#include <linux/netfilter_ipv4/ip_nat_rule.h>
-+
-+#define MODULENAME "NETMAP"
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Svenning Soerensen <svenning@post5.tele.dk>");
-+MODULE_DESCRIPTION("iptables 1:1 NAT mapping of IP networks target");
-+
-+#if 0
-+#define DEBUGP printk
-+#else
-+#define DEBUGP(format, args...)
-+#endif
-+
-+static int
-+check(const char *tablename,
-+      const struct ipt_entry *e,
-+      void *targinfo,
-+      unsigned int targinfosize,
-+      unsigned int hook_mask)
-+{
-+	const struct ip_nat_multi_range *mr = targinfo;
-+
-+	if (strcmp(tablename, "nat") != 0) {
-+		DEBUGP(MODULENAME":check: bad table `%s'.\n", tablename);
-+		return 0;
-+	}
-+	if (targinfosize != IPT_ALIGN(sizeof(*mr))) {
-+		DEBUGP(MODULENAME":check: size %u.\n", targinfosize);
-+		return 0;
-+	}
-+	if (hook_mask & ~((1 << NF_IP_PRE_ROUTING) | (1 << NF_IP_POST_ROUTING))) {
-+		DEBUGP(MODULENAME":check: bad hooks %x.\n", hook_mask);
-+		return 0;
-+	}
-+	if (!(mr->range[0].flags & IP_NAT_RANGE_MAP_IPS)) {
-+		DEBUGP(MODULENAME":check: bad MAP_IPS.\n");
-+		return 0;
-+	}
-+	if (mr->rangesize != 1) {
-+		DEBUGP(MODULENAME":check: bad rangesize %u.\n", mr->rangesize);
-+		return 0;
-+	}
-+	return 1;
-+}
-+
-+static unsigned int
-+target(struct sk_buff **pskb,
-+       unsigned int hooknum,
-+       const struct net_device *in,
-+       const struct net_device *out,
-+       const void *targinfo,
-+       void *userinfo)
-+{
-+	struct ip_conntrack *ct;
-+	enum ip_conntrack_info ctinfo;
-+	u_int32_t new_ip, netmask;
-+	const struct ip_nat_multi_range *mr = targinfo;
-+	struct ip_nat_multi_range newrange;
-+
-+	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING
-+		     || hooknum == NF_IP_POST_ROUTING);
-+	ct = ip_conntrack_get(*pskb, &ctinfo);
-+
-+	netmask = ~(mr->range[0].min_ip ^ mr->range[0].max_ip);
-+
-+	if (hooknum == NF_IP_PRE_ROUTING)
-+		new_ip = (*pskb)->nh.iph->daddr & ~netmask;
-+	else
-+		new_ip = (*pskb)->nh.iph->saddr & ~netmask;
-+	new_ip |= mr->range[0].min_ip & netmask;
-+
-+	newrange = ((struct ip_nat_multi_range)
-+	{ 1, { { mr->range[0].flags | IP_NAT_RANGE_MAP_IPS,
-+		 new_ip, new_ip,
-+		 mr->range[0].min, mr->range[0].max } } });
-+
-+	/* Hand modified range to generic setup. */
-+	return ip_nat_setup_info(ct, &newrange, hooknum);
-+}
-+
-+static struct ipt_target target_module = { 
-+	.name = MODULENAME,
-+	.target = target,
-+	.checkentry = check,
-+	.me = THIS_MODULE
-+};
-+
-+static int __init init(void)
-+{
-+	return ipt_register_target(&target_module);
-+}
-+
-+static void __exit fini(void)
-+{
-+	ipt_unregister_target(&target_module);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -107,6 +107,7 @@ obj-$(CONFIG_IP_NF_TARGET_DSCP) += ipt_D
- obj-$(CONFIG_IP_NF_TARGET_MARK) += ipt_MARK.o
- obj-$(CONFIG_IP_NF_TARGET_MASQUERADE) += ipt_MASQUERADE.o
- obj-$(CONFIG_IP_NF_TARGET_REDIRECT) += ipt_REDIRECT.o
-+obj-$(CONFIG_IP_NF_TARGET_NETMAP) += ipt_NETMAP.o
- obj-$(CONFIG_IP_NF_NAT_SNMP_BASIC) += ip_nat_snmp_basic.o
- obj-$(CONFIG_IP_NF_TARGET_LOG) += ipt_LOG.o
- obj-$(CONFIG_IP_NF_TARGET_TTL) += ipt_TTL.o
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/609-netfilter_string.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,989 +0,0 @@
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_string.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_string.h
-@@ -0,0 +1,18 @@
-+#ifndef _IPT_STRING_H
-+#define _IPT_STRING_H
-+
-+#define IPT_STRING_MAX_PATTERN_SIZE 128
-+#define IPT_STRING_MAX_ALGO_NAME_SIZE 16
-+
-+struct ipt_string_info
-+{
-+	u_int16_t from_offset;
-+	u_int16_t to_offset;
-+	char	  algo[IPT_STRING_MAX_ALGO_NAME_SIZE];
-+	char 	  pattern[IPT_STRING_MAX_PATTERN_SIZE];
-+	u_int8_t  patlen;
-+	u_int8_t  invert;
-+	struct ts_config __attribute__((aligned(8))) *config;
-+};
-+
-+#endif /*_IPT_STRING_H*/
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -63,6 +63,7 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-   fi
-   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-     dep_tristate '  Unclean match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_UNCLEAN $CONFIG_IP_NF_IPTABLES
-+    dep_tristate '  String match support (EXPERIMENTAL) ' CONFIG_IP_NF_MATCH_STRING $CONFIG_IP_NF_IPTABLES
-     dep_tristate '  Owner match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_OWNER $CONFIG_IP_NF_IPTABLES
-     dep_tristate '  Layer 7 match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_LAYER7 $CONFIG_IP_NF_CONNTRACK
-     dep_mbool '  Layer 7 debugging output (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_LAYER7_DEBUG $CONFIG_IP_NF_MATCH_LAYER7
-Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_string.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ipt_string.c
-@@ -0,0 +1,99 @@
-+/* String matching match for iptables
-+ * 
-+ * (C) 2005 Pablo Neira Ayuso <pablo@eurodev.net>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/kernel.h>
-+#include <linux/skbuff.h>
-+#include <linux/netfilter_ipv4/ip_tables.h>
-+#include <linux/netfilter_ipv4/ipt_string.h>
-+#include "textsearch/textsearch.h"
-+#include "textsearch/textsearch.c"
-+#include "textsearch/ts_bm.c"
-+#include "textsearch/ts_kmp.c"
-+
-+MODULE_AUTHOR("Pablo Neira Ayuso <pablo@eurodev.net>");
-+MODULE_DESCRIPTION("IP tables string match module");
-+MODULE_LICENSE("GPL");
-+
-+static int match(const struct sk_buff *skb,
-+		 const struct net_device *in,
-+		 const struct net_device *out,
-+		 const void *matchinfo,
-+		 int offset,
-+		 int *hotdrop)
-+{
-+	struct iphdr *ip = skb->nh.iph;
-+	struct ts_state state;
-+	struct ipt_string_info *conf = (struct ipt_string_info *) matchinfo;
-+	char *buf = (char *)ip+(ip->ihl*4);
-+	int len = ntohs(ip->tot_len)-(ip->ihl*4);
-+
-+	memset(&state, 0, sizeof(struct ts_state));
-+
-+	return (textsearch_find_continuous(conf->config, &state, buf, len) != UINT_MAX) && !conf->invert;
-+}
-+
-+#define STRING_TEXT_PRIV(m) ((struct ipt_string_info *) m)
-+
-+static int checkentry(const char *tablename,
-+		      const struct ipt_ip *ip,
-+		      void *matchinfo,
-+		      unsigned int matchsize,
-+		      unsigned int hook_mask)
-+{
-+	struct ipt_string_info *conf = matchinfo;
-+	struct ts_config *ts_conf;
-+
-+	if (matchsize != IPT_ALIGN(sizeof(struct ipt_string_info)))
-+		return 0;
-+
-+	/* Damn, can't handle this case properly with iptables... */
-+	if (conf->from_offset > conf->to_offset)
-+		return 0;
-+
-+	ts_conf = textsearch_prepare(conf->algo, conf->pattern, conf->patlen,
-+				     GFP_KERNEL, TS_AUTOLOAD);
-+	if (IS_ERR(ts_conf))
-+		return 0;
-+
-+	conf->config = ts_conf;
-+
-+	return 1;
-+}
-+
-+static void destroy(void *matchinfo, unsigned int matchsize)
-+{
-+	textsearch_destroy(STRING_TEXT_PRIV(matchinfo)->config);
-+}
-+
-+static struct ipt_match string_match = {
-+	.name 		= "string",
-+	.match 		= match,
-+	.checkentry	= checkentry,
-+	.destroy 	= destroy,
-+	.me 		= THIS_MODULE
-+};
-+
-+static int __init init(void)
-+{
-+	init_bm();
-+	init_kmp();
-+	return ipt_register_match(&string_match);
-+}
-+
-+static void __exit fini(void)
-+{
-+	exit_kmp();
-+	exit_bm();
-+	ipt_unregister_match(&string_match);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -108,6 +108,7 @@ obj-$(CONFIG_IP_NF_MATCH_STATE) += ipt_s
- obj-$(CONFIG_IP_NF_MATCH_CONNMARK) += ipt_connmark.o
- obj-$(CONFIG_IP_NF_MATCH_CONNTRACK) += ipt_conntrack.o
- obj-$(CONFIG_IP_NF_MATCH_UNCLEAN) += ipt_unclean.o
-+obj-$(CONFIG_IP_NF_MATCH_STRING) += ipt_string.o
- obj-$(CONFIG_IP_NF_MATCH_TCPMSS) += ipt_tcpmss.o
- obj-$(CONFIG_IP_NF_MATCH_LAYER7) += ipt_layer7.o
- 
-Index: linux-2.4.35.4/net/ipv4/netfilter/textsearch/textsearch.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/textsearch/textsearch.c
-@@ -0,0 +1,305 @@
-+/*
-+ * lib/textsearch.c	Generic text search interface
-+ *
-+ *		This program is free software; you can redistribute it and/or
-+ *		modify it under the terms of the GNU General Public License
-+ *		as published by the Free Software Foundation; either version
-+ *		2 of the License, or (at your option) any later version.
-+ *
-+ * Authors:	Thomas Graf <tgraf@suug.ch>
-+ * 		Pablo Neira Ayuso <pablo@eurodev.net>
-+ *
-+ * ==========================================================================
-+ *
-+ * INTRODUCTION
-+ *
-+ *   The textsearch infrastructure provides text searching facitilies for
-+ *   both linear and non-linear data. Individual search algorithms are
-+ *   implemented in modules and chosen by the user.
-+ *
-+ * ARCHITECTURE
-+ *
-+ *      User
-+ *     +----------------+
-+ *     |        finish()|<--------------(6)-----------------+
-+ *     |get_next_block()|<--------------(5)---------------+ |
-+ *     |                |                     Algorithm   | |
-+ *     |                |                    +------------------------------+
-+ *     |                |                    |  init()   find()   destroy() |
-+ *     |                |                    +------------------------------+
-+ *     |                |       Core API           ^       ^          ^
-+ *     |                |      +---------------+  (2)     (4)        (8)
-+ *     |             (1)|----->| prepare()     |---+       |          |
-+ *     |             (3)|----->| find()/next() |-----------+          |
-+ *     |             (7)|----->| destroy()     |----------------------+
-+ *     +----------------+      +---------------+
-+ *  
-+ *   (1) User configures a search by calling _prepare() specifying the
-+ *       search parameters such as the pattern and algorithm name.
-+ *   (2) Core requests the algorithm to allocate and initialize a search
-+ *       configuration according to the specified parameters.
-+ *   (3) User starts the search(es) by calling _find() or _next() to
-+ *       fetch subsequent occurrences. A state variable is provided
-+ *       to the algorihtm to store persistant variables.
-+ *   (4) Core eventually resets the search offset and forwards the find()
-+ *       request to the algorithm.
-+ *   (5) Algorithm calls get_next_block() provided by the user continously
-+ *       to fetch the data to be searched in block by block.
-+ *   (6) Algorithm invokes finish() after the last call to get_next_block
-+ *       to clean up any leftovers from get_next_block. (Optional)
-+ *   (7) User destroys the configuration by calling _destroy().
-+ *   (8) Core notifies the algorithm to destroy algorithm specific
-+ *       allocations. (Optional)
-+ *
-+ * USAGE
-+ *
-+ *   Before a search can be performed, a configuration must be created
-+ *   by calling textsearch_prepare() specyfing the searching algorithm and
-+ *   the pattern to look for. The returned configuration may then be used
-+ *   for an arbitary amount of times and even in parallel as long as a
-+ *   separate struct ts_state variable is provided to every instance.
-+ *
-+ *   The actual search is performed by either calling textsearch_find_-
-+ *   continuous() for linear data or by providing an own get_next_block()
-+ *   implementation and calling textsearch_find(). Both functions return
-+ *   the position of the first occurrence of the patern or UINT_MAX if
-+ *   no match was found. Subsequent occurences can be found by calling
-+ *   textsearch_next() regardless of the linearity of the data.
-+ *
-+ *   Once you're done using a configuration it must be given back via
-+ *   textsearch_destroy.
-+ *
-+ * EXAMPLE
-+ *
-+ *   int pos;
-+ *   struct ts_config *conf;
-+ *   struct ts_state state;
-+ *   const char *pattern = "chicken";
-+ *   const char *example = "We dance the funky chicken";
-+ *
-+ *   conf = textsearch_prepare("kmp", pattern, strlen(pattern),
-+ *                             GFP_KERNEL, TS_AUTOLOAD);
-+ *   if (IS_ERR(conf)) {
-+ *       err = PTR_ERR(conf);
-+ *       goto errout;
-+ *   }
-+ *
-+ *   pos = textsearch_find_continuous(conf, &state, example, strlen(example));
-+ *   if (pos != UINT_MAX)
-+ *       panic("Oh my god, dancing chickens at %d\n", pos);
-+ *
-+ *   textsearch_destroy(conf);
-+ *
-+ * ==========================================================================
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/types.h>
-+#include <linux/string.h>
-+#include <linux/init.h>
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+#include "textsearch.h"
-+
-+static LIST_HEAD(ts_ops);
-+static spinlock_t ts_mod_lock = SPIN_LOCK_UNLOCKED;
-+static DECLARE_RWLOCK(ts_ops_lock);
-+
-+static inline struct ts_ops *lookup_ts_algo(const char *name)
-+{
-+	struct ts_ops *o;
-+
-+	read_lock(&ts_ops_lock);
-+	list_for_each_entry(o, &ts_ops, list) {
-+		if (!strcmp(name, o->name)) {
-+			MOD_INC_USE_COUNT;
-+			read_unlock(&ts_ops_lock);
-+			return o;
-+		}
-+	}
-+	read_unlock(&ts_ops_lock);
-+
-+	return NULL;
-+}
-+
-+/**
-+ * textsearch_register - register a textsearch module
-+ * @ops: operations lookup table
-+ *
-+ * This function must be called by textsearch modules to announce
-+ * their presence. The specified &@ops must have %name set to a
-+ * unique identifier and the callbacks find(), init(), get_pattern(),
-+ * and get_pattern_len() must be implemented.
-+ *
-+ * Returns 0 or -EEXISTS if another module has already registered
-+ * with same name.
-+ */
-+int textsearch_register(struct ts_ops *ops)
-+{
-+	int err = -EEXIST;
-+	struct ts_ops *o;
-+
-+	if (ops->name == NULL || ops->find == NULL || ops->init == NULL ||
-+	    ops->get_pattern == NULL || ops->get_pattern_len == NULL)
-+		return -EINVAL;
-+
-+	spin_lock(&ts_mod_lock);
-+	list_for_each_entry(o, &ts_ops, list) {
-+		if (!strcmp(ops->name, o->name))
-+			goto errout;
-+	}
-+
-+	write_lock(&ts_ops_lock);
-+	list_add_tail(&ops->list, &ts_ops);
-+	write_unlock(&ts_ops_lock);
-+
-+	err = 0;
-+errout:
-+	spin_unlock(&ts_mod_lock);
-+	return err;
-+}
-+
-+/**
-+ * textsearch_unregister - unregister a textsearch module
-+ * @ops: operations lookup table
-+ *
-+ * This function must be called by textsearch modules to announce
-+ * their disappearance for examples when the module gets unloaded.
-+ * The &ops parameter must be the same as the one during the
-+ * registration.
-+ *
-+ * Returns 0 on success or -ENOENT if no matching textsearch
-+ * registration was found.
-+ */
-+int textsearch_unregister(struct ts_ops *ops)
-+{
-+	int err = 0;
-+	struct ts_ops *o;
-+
-+	spin_lock(&ts_mod_lock);
-+	list_for_each_entry(o, &ts_ops, list) {
-+		if (o == ops) {
-+			write_lock(&ts_ops_lock);
-+			list_del(&o->list);
-+			write_unlock(&ts_ops_lock);
-+			goto out;
-+		}
-+	}
-+
-+	err = -ENOENT;
-+out:
-+	spin_unlock(&ts_mod_lock);
-+	return err;
-+}
-+
-+struct ts_linear_state
-+{
-+	unsigned int	len;
-+	const void	*data;
-+};
-+
-+static unsigned int get_linear_data(unsigned int consumed, const u8 **dst,
-+				    struct ts_config *conf,
-+				    struct ts_state *state)
-+{
-+	struct ts_linear_state *st = (struct ts_linear_state *) state->cb;
-+
-+	if (likely(consumed < st->len)) {
-+		*dst = st->data + consumed;
-+		return st->len - consumed;
-+	}
-+
-+	return 0;
-+}
-+
-+/**
-+ * textsearch_find_continuous - search a pattern in continuous/linear data
-+ * @conf: search configuration
-+ * @state: search state
-+ * @data: data to search in
-+ * @len: length of data
-+ *
-+ * A simplified version of textsearch_find() for continuous/linear data.
-+ * Call textsearch_next() to retrieve subsequent matches.
-+ *
-+ * Returns the position of first occurrence of the pattern or
-+ * UINT_MAX if no occurrence was found.
-+ */ 
-+unsigned int textsearch_find_continuous(struct ts_config *conf,
-+					struct ts_state *state,
-+					const void *data, unsigned int len)
-+{
-+	struct ts_linear_state *st = (struct ts_linear_state *) state->cb;
-+
-+	conf->get_next_block = get_linear_data;
-+	st->data = data;
-+	st->len = len;
-+
-+	return textsearch_find(conf, state);
-+}
-+
-+/**
-+ * textsearch_prepare - Prepare a search
-+ * @algo: name of search algorithm
-+ * @pattern: pattern data
-+ * @len: length of pattern
-+ * @gfp_mask: allocation mask
-+ * @flags: search flags
-+ *
-+ * Looks up the search algorithm module and creates a new textsearch
-+ * configuration for the specified pattern. Upon completion all
-+ * necessary refcnts are held and the configuration must be put back
-+ * using textsearch_put() after usage.
-+ *
-+ * Note: The format of the pattern may not be compatible between
-+ *       the various search algorithms.
-+ *
-+ * Returns a new textsearch configuration according to the specified
-+ *         parameters or a ERR_PTR().
-+ */
-+struct ts_config *textsearch_prepare(const char *algo, const void *pattern,
-+				     unsigned int len, gfp_t gfp_mask, int flags)
-+{
-+	int err = -ENOENT;
-+	struct ts_config *conf;
-+	struct ts_ops *ops;
-+	
-+	ops = lookup_ts_algo(algo);
-+
-+	if (ops == NULL)
-+		goto errout;
-+
-+	conf = ops->init(pattern, len, gfp_mask);
-+	if (IS_ERR(conf)) {
-+		err = PTR_ERR(conf);
-+		goto errout;
-+	}
-+
-+	conf->ops = ops;
-+	return conf;
-+
-+errout:
-+	if (ops)
-+		MOD_DEC_USE_COUNT;
-+		
-+	return ERR_PTR(err);
-+}
-+
-+/**
-+ * textsearch_destroy - destroy a search configuration
-+ * @conf: search configuration
-+ *
-+ * Releases all references of the configuration and frees
-+ * up the memory.
-+ */
-+void textsearch_destroy(struct ts_config *conf)
-+{
-+	if (conf->ops) {
-+		if (conf->ops->destroy)
-+			conf->ops->destroy(conf);
-+		MOD_DEC_USE_COUNT;
-+	}
-+
-+	kfree(conf);
-+}
-+
-Index: linux-2.4.35.4/net/ipv4/netfilter/textsearch/textsearch.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/textsearch/textsearch.h
-@@ -0,0 +1,182 @@
-+#ifndef __LINUX_TEXTSEARCH_H
-+#define __LINUX_TEXTSEARCH_H
-+
-+#ifdef __KERNEL__
-+
-+#include <linux/types.h>
-+#include <linux/list.h>
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/slab.h>
-+
-+typedef int gfp_t;
-+struct ts_config;
-+
-+/**
-+ * TS_AUTOLOAD - Automatically load textsearch modules when needed
-+ */
-+#define TS_AUTOLOAD	1
-+
-+/**
-+ * struct ts_state - search state
-+ * @offset: offset for next match
-+ * @cb: control buffer, for persistant variables of get_next_block()
-+ */
-+struct ts_state
-+{
-+	unsigned int		offset;
-+	char			cb[40];
-+};
-+
-+/**
-+ * struct ts_ops - search module operations
-+ * @name: name of search algorithm
-+ * @init: initialization function to prepare a search
-+ * @find: find the next occurrence of the pattern
-+ * @destroy: destroy algorithm specific parts of a search configuration
-+ * @get_pattern: return head of pattern
-+ * @get_pattern_len: return length of pattern
-+ * @owner: module reference to algorithm
-+ */
-+struct ts_ops
-+{
-+	const char		*name;
-+	struct ts_config *	(*init)(const void *, unsigned int, gfp_t);
-+	unsigned int		(*find)(struct ts_config *,
-+					struct ts_state *);
-+	void			(*destroy)(struct ts_config *);
-+	void *			(*get_pattern)(struct ts_config *);
-+	unsigned int		(*get_pattern_len)(struct ts_config *);
-+	struct module		*owner;
-+	struct list_head	list;
-+};
-+
-+/**
-+ * struct ts_config - search configuration
-+ * @ops: operations of chosen algorithm
-+ * @get_next_block: callback to fetch the next block to search in
-+ * @finish: callback to finalize a search
-+ */
-+struct ts_config
-+{
-+	struct ts_ops		*ops;
-+
-+	/**
-+	 * get_next_block - fetch next block of data
-+	 * @consumed: number of bytes consumed by the caller
-+	 * @dst: destination buffer
-+	 * @conf: search configuration
-+	 * @state: search state
-+	 *
-+	 * Called repeatedly until 0 is returned. Must assign the
-+	 * head of the next block of data to &*dst and return the length
-+	 * of the block or 0 if at the end. consumed == 0 indicates
-+	 * a new search. May store/read persistant values in state->cb.
-+	 */
-+	unsigned int		(*get_next_block)(unsigned int consumed,
-+						  const u8 **dst,
-+						  struct ts_config *conf,
-+						  struct ts_state *state);
-+
-+	/**
-+	 * finish - finalize/clean a series of get_next_block() calls
-+	 * @conf: search configuration
-+	 * @state: search state
-+	 *
-+	 * Called after the last use of get_next_block(), may be used
-+	 * to cleanup any leftovers.
-+	 */
-+	void			(*finish)(struct ts_config *conf,
-+					  struct ts_state *state);
-+};
-+
-+/**
-+ * textsearch_next - continue searching for a pattern
-+ * @conf: search configuration
-+ * @state: search state
-+ *
-+ * Continues a search looking for more occurrences of the pattern.
-+ * textsearch_find() must be called to find the first occurrence
-+ * in order to reset the state.
-+ *
-+ * Returns the position of the next occurrence of the pattern or
-+ * UINT_MAX if not match was found.
-+ */ 
-+static inline unsigned int textsearch_next(struct ts_config *conf,
-+					   struct ts_state *state)
-+{
-+	unsigned int ret = conf->ops->find(conf, state);
-+
-+	if (conf->finish)
-+		conf->finish(conf, state);
-+
-+	return ret;
-+}
-+
-+/**
-+ * textsearch_find - start searching for a pattern
-+ * @conf: search configuration
-+ * @state: search state
-+ *
-+ * Returns the position of first occurrence of the pattern or
-+ * UINT_MAX if no match was found.
-+ */ 
-+static inline unsigned int textsearch_find(struct ts_config *conf,
-+					   struct ts_state *state)
-+{
-+	state->offset = 0;
-+	return textsearch_next(conf, state);
-+}
-+
-+/**
-+ * textsearch_get_pattern - return head of the pattern
-+ * @conf: search configuration
-+ */
-+static inline void *textsearch_get_pattern(struct ts_config *conf)
-+{
-+	return conf->ops->get_pattern(conf);
-+}
-+
-+/**
-+ * textsearch_get_pattern_len - return length of the pattern
-+ * @conf: search configuration
-+ */
-+static inline unsigned int textsearch_get_pattern_len(struct ts_config *conf)
-+{
-+	return conf->ops->get_pattern_len(conf);
-+}
-+
-+extern int textsearch_register(struct ts_ops *);
-+extern int textsearch_unregister(struct ts_ops *);
-+extern struct ts_config *textsearch_prepare(const char *, const void *,
-+					    unsigned int, gfp_t, int);
-+extern void textsearch_destroy(struct ts_config *conf);
-+extern unsigned int textsearch_find_continuous(struct ts_config *,
-+					       struct ts_state *,
-+					       const void *, unsigned int);
-+
-+
-+#define TS_PRIV_ALIGNTO	8
-+#define TS_PRIV_ALIGN(len) (((len) + TS_PRIV_ALIGNTO-1) & ~(TS_PRIV_ALIGNTO-1))
-+
-+static inline struct ts_config *alloc_ts_config(size_t payload,
-+						gfp_t gfp_mask)
-+{
-+	struct ts_config *conf;
-+
-+	conf = kmalloc(TS_PRIV_ALIGN(sizeof(*conf)) + payload, gfp_mask);
-+	if (conf == NULL)
-+		return ERR_PTR(-ENOMEM);
-+
-+	memset(conf, 0, TS_PRIV_ALIGN(sizeof(*conf)) + payload);
-+	return conf;
-+}
-+
-+static inline void *ts_config_priv(struct ts_config *conf)
-+{
-+	return ((u8 *) conf + TS_PRIV_ALIGN(sizeof(struct ts_config)));
-+}
-+
-+#endif /* __KERNEL__ */
-+
-+#endif
-Index: linux-2.4.35.4/net/ipv4/netfilter/textsearch/ts_bm.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/textsearch/ts_bm.c
-@@ -0,0 +1,190 @@
-+/*
-+ * lib/ts_bm.c		Boyer-Moore text search implementation
-+ *
-+ *		This program is free software; you can redistribute it and/or
-+ *		modify it under the terms of the GNU General Public License
-+ *		as published by the Free Software Foundation; either version
-+ *		2 of the License, or (at your option) any later version.
-+ *
-+ * Authors:	Pablo Neira Ayuso <pablo@eurodev.net>
-+ *
-+ * ==========================================================================
-+ * 
-+ *   Implements Boyer-Moore string matching algorithm:
-+ *
-+ *   [1] A Fast String Searching Algorithm, R.S. Boyer and Moore.
-+ *       Communications of the Association for Computing Machinery, 
-+ *       20(10), 1977, pp. 762-772.
-+ *       http://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf
-+ *
-+ *   [2] Handbook of Exact String Matching Algorithms, Thierry Lecroq, 2004
-+ *       http://www-igm.univ-mlv.fr/~lecroq/string/string.pdf
-+ *
-+ *   Note: Since Boyer-Moore (BM) performs searches for matchings from right 
-+ *   to left, it's still possible that a matching could be spread over 
-+ *   multiple blocks, in that case this algorithm won't find any coincidence.
-+ *   
-+ *   If you're willing to ensure that such thing won't ever happen, use the
-+ *   Knuth-Pratt-Morris (KMP) implementation instead. In conclusion, choose 
-+ *   the proper string search algorithm depending on your setting. 
-+ *
-+ *   Say you're using the textsearch infrastructure for filtering, NIDS or 
-+ *   any similar security focused purpose, then go KMP. Otherwise, if you 
-+ *   really care about performance, say you're classifying packets to apply
-+ *   Quality of Service (QoS) policies, and you don't mind about possible
-+ *   matchings spread over multiple fragments, then go BM.
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/types.h>
-+#include <linux/string.h>
-+#include "textsearch.h"
-+
-+/* Alphabet size, use ASCII */
-+#define ASIZE 256
-+
-+#if 0
-+#define DEBUGP printk
-+#else
-+#define DEBUGP(args, format...)
-+#endif
-+
-+struct ts_bm
-+{
-+	u8 *		pattern;
-+	unsigned int	patlen;
-+	unsigned int 	bad_shift[ASIZE];
-+	unsigned int	good_shift[0];
-+};
-+
-+static unsigned int bm_find(struct ts_config *conf, struct ts_state *state)
-+{
-+	struct ts_bm *bm = ts_config_priv(conf);
-+	unsigned int i, text_len, consumed = state->offset;
-+	const u8 *text;
-+	int shift = bm->patlen, bs;
-+
-+	for (;;) {
-+		text_len = conf->get_next_block(consumed, &text, conf, state);
-+
-+		if (unlikely(text_len == 0))
-+			break;
-+
-+		while (shift < text_len) {
-+			DEBUGP("Searching in position %d (%c)\n", 
-+				shift, text[shift]);
-+			for (i = 0; i < bm->patlen; i++) 
-+			     if (text[shift-i] != bm->pattern[bm->patlen-1-i])
-+				     goto next;
-+
-+			/* London calling... */
-+			DEBUGP("found!\n");
-+			return consumed += (shift-(bm->patlen-1));
-+
-+next:			bs = bm->bad_shift[text[shift-i]];
-+
-+			/* Now jumping to... */
-+			shift = max_t(int, shift-i+bs, shift+bm->good_shift[i]);
-+		}
-+		consumed += text_len;
-+	}
-+
-+	return UINT_MAX;
-+}
-+
-+static int subpattern(u8 *pattern, int i, int j, int g)
-+{
-+	int x = i+g-1, y = j+g-1, ret = 0;
-+
-+	while(pattern[x--] == pattern[y--]) {
-+		if (y < 0) {
-+			ret = 1;
-+			break;
-+		}
-+		if (--g == 0) {
-+			ret = pattern[i-1] != pattern[j-1];
-+			break;
-+		}
-+	}
-+
-+	return ret;
-+}
-+
-+static void bm_compute_prefix_tbl(struct ts_bm *bm, const u8 *pattern,
-+			       unsigned int len)
-+{
-+	int i, j, g;
-+
-+	for (i = 0; i < ASIZE; i++)
-+		bm->bad_shift[i] = len;
-+	for (i = 0; i < len - 1; i++)
-+		bm->bad_shift[pattern[i]] = len - 1 - i;
-+
-+	/* Compute the good shift array, used to match reocurrences 
-+	 * of a subpattern */
-+	bm->good_shift[0] = 1;
-+	for (i = 1; i < bm->patlen; i++)
-+		bm->good_shift[i] = bm->patlen;
-+        for (i = bm->patlen-1, g = 1; i > 0; g++, i--) {
-+		for (j = i-1; j >= 1-g ; j--)
-+			if (subpattern(bm->pattern, i, j, g)) {
-+				bm->good_shift[g] = bm->patlen-j-g;
-+				break;
-+			}
-+	}
-+}
-+
-+static struct ts_config *bm_init(const void *pattern, unsigned int len,
-+				 gfp_t gfp_mask)
-+{
-+	struct ts_config *conf;
-+	struct ts_bm *bm;
-+	unsigned int prefix_tbl_len = len * sizeof(unsigned int);
-+	size_t priv_size = sizeof(*bm) + len + prefix_tbl_len;
-+
-+	conf = alloc_ts_config(priv_size, gfp_mask);
-+	if (IS_ERR(conf))
-+		return conf;
-+
-+	bm = ts_config_priv(conf);
-+	bm->patlen = len;
-+	bm->pattern = (u8 *) bm->good_shift + prefix_tbl_len;
-+	bm_compute_prefix_tbl(bm, pattern, len);
-+	memcpy(bm->pattern, pattern, len);
-+
-+	return conf;
-+}
-+
-+static void *bm_get_pattern(struct ts_config *conf)
-+{
-+	struct ts_bm *bm = ts_config_priv(conf);
-+	return bm->pattern;
-+}
-+
-+static unsigned int bm_get_pattern_len(struct ts_config *conf)
-+{
-+	struct ts_bm *bm = ts_config_priv(conf);
-+	return bm->patlen;
-+}
-+
-+static struct ts_ops bm_ops = {
-+	.name		  = "bm",
-+	.find		  = bm_find,
-+	.init		  = bm_init,
-+	.get_pattern	  = bm_get_pattern,
-+	.get_pattern_len  = bm_get_pattern_len,
-+	.owner		  = THIS_MODULE,
-+	.list		  = LIST_HEAD_INIT(bm_ops.list)
-+};
-+
-+static int __init init_bm(void)
-+{
-+	return textsearch_register(&bm_ops);
-+}
-+
-+static void __exit exit_bm(void)
-+{
-+	textsearch_unregister(&bm_ops);
-+}
-Index: linux-2.4.35.4/net/ipv4/netfilter/textsearch/ts_kmp.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/textsearch/ts_kmp.c
-@@ -0,0 +1,141 @@
-+/*
-+ * lib/ts_kmp.c		Knuth-Morris-Pratt text search implementation
-+ *
-+ *		This program is free software; you can redistribute it and/or
-+ *		modify it under the terms of the GNU General Public License
-+ *		as published by the Free Software Foundation; either version
-+ *		2 of the License, or (at your option) any later version.
-+ *
-+ * Authors:	Thomas Graf <tgraf@suug.ch>
-+ *
-+ * ==========================================================================
-+ * 
-+ *   Implements a linear-time string-matching algorithm due to Knuth,
-+ *   Morris, and Pratt [1]. Their algorithm avoids the explicit
-+ *   computation of the transition function DELTA altogether. Its
-+ *   matching time is O(n), for n being length(text), using just an
-+ *   auxiliary function PI[1..m], for m being length(pattern),
-+ *   precomputed from the pattern in time O(m). The array PI allows
-+ *   the transition function DELTA to be computed efficiently
-+ *   "on the fly" as needed. Roughly speaking, for any state
-+ *   "q" = 0,1,...,m and any character "a" in SIGMA, the value
-+ *   PI["q"] contains the information that is independent of "a" and
-+ *   is needed to compute DELTA("q", "a") [2]. Since the array PI
-+ *   has only m entries, whereas DELTA has O(m|SIGMA|) entries, we
-+ *   save a factor of |SIGMA| in the preprocessing time by computing
-+ *   PI rather than DELTA.
-+ *
-+ *   [1] Cormen, Leiserson, Rivest, Stein
-+ *       Introdcution to Algorithms, 2nd Edition, MIT Press
-+ *   [2] See finite automation theory
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/types.h>
-+#include <linux/string.h>
-+#include "textsearch.h"
-+
-+struct ts_kmp
-+{
-+	u8 *		pattern;
-+	unsigned int	pattern_len;
-+	unsigned int 	prefix_tbl[0];
-+};
-+
-+static unsigned int kmp_find(struct ts_config *conf, struct ts_state *state)
-+{
-+	struct ts_kmp *kmp = ts_config_priv(conf);
-+	unsigned int i, q = 0, text_len, consumed = state->offset;
-+	const u8 *text;
-+
-+	for (;;) {
-+		text_len = conf->get_next_block(consumed, &text, conf, state);
-+
-+		if (unlikely(text_len == 0))
-+			break;
-+
-+		for (i = 0; i < text_len; i++) {
-+			while (q > 0 && kmp->pattern[q] != text[i])
-+				q = kmp->prefix_tbl[q - 1];
-+			if (kmp->pattern[q] == text[i])
-+				q++;
-+			if (unlikely(q == kmp->pattern_len)) {
-+				state->offset = consumed + i + 1;
-+				return state->offset - kmp->pattern_len;
-+			}
-+		}
-+
-+		consumed += text_len;
-+	}
-+
-+	return UINT_MAX;
-+}
-+
-+static inline void kmp_compute_prefix_tbl(const u8 *pattern, unsigned int len,
-+				      unsigned int *prefix_tbl)
-+{
-+	unsigned int k, q;
-+
-+	for (k = 0, q = 1; q < len; q++) {
-+		while (k > 0 && pattern[k] != pattern[q])
-+			k = prefix_tbl[k-1];
-+		if (pattern[k] == pattern[q])
-+			k++;
-+		prefix_tbl[q] = k;
-+	}
-+}
-+
-+static struct ts_config *kmp_init(const void *pattern, unsigned int len,
-+				  gfp_t gfp_mask)
-+{
-+	struct ts_config *conf;
-+	struct ts_kmp *kmp;
-+	unsigned int prefix_tbl_len = len * sizeof(unsigned int);
-+	size_t priv_size = sizeof(*kmp) + len + prefix_tbl_len;
-+
-+	conf = alloc_ts_config(priv_size, gfp_mask);
-+	if (IS_ERR(conf))
-+		return conf;
-+
-+	kmp = ts_config_priv(conf);
-+	kmp->pattern_len = len;
-+	kmp_compute_prefix_tbl(pattern, len, kmp->prefix_tbl);
-+	kmp->pattern = (u8 *) kmp->prefix_tbl + prefix_tbl_len;
-+	memcpy(kmp->pattern, pattern, len);
-+
-+	return conf;
-+}
-+
-+static void *kmp_get_pattern(struct ts_config *conf)
-+{
-+	struct ts_kmp *kmp = ts_config_priv(conf);
-+	return kmp->pattern;
-+}
-+
-+static unsigned int kmp_get_pattern_len(struct ts_config *conf)
-+{
-+	struct ts_kmp *kmp = ts_config_priv(conf);
-+	return kmp->pattern_len;
-+}
-+
-+static struct ts_ops kmp_ops = {
-+	.name		  = "kmp",
-+	.find		  = kmp_find,
-+	.init		  = kmp_init,
-+	.get_pattern	  = kmp_get_pattern,
-+	.get_pattern_len  = kmp_get_pattern_len,
-+	.owner		  = THIS_MODULE,
-+	.list		  = LIST_HEAD_INIT(kmp_ops.list)
-+};
-+
-+static int __init init_kmp(void)
-+{
-+	return textsearch_register(&kmp_ops);
-+}
-+
-+static void __exit exit_kmp(void)
-+{
-+	textsearch_unregister(&kmp_ops);
-+}
-+
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/610-netfilter_connbytes.patch	2009-04-12 13:27:08.000000000 -0400
+++ kamikaze-8.09-new/target/linux/generic-2.4/patches/610-netfilter_connbytes.patch	2009-04-12 13:44:35.000000000 -0400
@@ -2,15 +2,15 @@
 ===================================================================
 --- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
 +++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -11,6 +11,8 @@ if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ];
+@@ -11,6 +11,8 @@
    dep_tristate '  Amanda protocol support' CONFIG_IP_NF_AMANDA $CONFIG_IP_NF_CONNTRACK
    dep_tristate '  TFTP protocol support' CONFIG_IP_NF_TFTP $CONFIG_IP_NF_CONNTRACK
    dep_tristate '  IRC protocol support' CONFIG_IP_NF_IRC $CONFIG_IP_NF_CONNTRACK
 +  dep_tristate '  Connection tracking flow accounting' CONFIG_IP_NF_CT_ACCT $CONFIG_IP_NF_CONNTRACK
 +  dep_tristate '  Connection byte counter support' CONFIG_IP_NF_MATCH_CONNBYTES $CONFIG_IP_NF_CT_ACCT $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  GRE protocol support' CONFIG_IP_NF_CT_PROTO_GRE $CONFIG_IP_NF_CONNTRACK
-   dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
  fi
+
+ if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
 Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
 ===================================================================
 --- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
@@ -439,27 +439,3 @@
 +};
 +
 +#endif
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_proto_gre.c
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/ip_conntrack_proto_gre.c
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_proto_gre.c
-@@ -237,16 +237,16 @@ static unsigned int gre_print_conntrack(
- /* Returns verdict for packet, and may modify conntrack */
- static int gre_packet(struct ip_conntrack *ct,
- 		      struct iphdr *iph, size_t len,
--		      enum ip_conntrack_info conntrackinfo)
-+		      enum ip_conntrack_info ctinfo)
- {
- 	/* If we've seen traffic both ways, this is a GRE connection.
- 	 * Extend timeout. */
- 	if (ct->status & IPS_SEEN_REPLY) {
--		ip_ct_refresh_acct(ct, ct->proto.gre.stream_timeout);
-+		ip_ct_refresh_acct(ct, ctinfo, iph, ct->proto.gre.stream_timeout);
- 		/* Also, more likely to be important, and not a probe. */
- 		set_bit(IPS_ASSURED_BIT, &ct->status);
- 	} else
--		ip_ct_refresh_acct(ct, ct->proto.gre.timeout);
-+		ip_ct_refresh_acct(ct, ctinfo, iph, ct->proto.gre.timeout);
- 	
- 	return NF_ACCEPT;
- }
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/611-netfilter_condition.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,634 +0,0 @@
-Index: linux-2.4.35.4/Documentation/Configure.help
-===================================================================
---- linux-2.4.35.4.orig/Documentation/Configure.help
-+++ linux-2.4.35.4/Documentation/Configure.help
-@@ -2979,6 +2979,14 @@ CONFIG_IP_NF_MATCH_TOS
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+Condition variable match support
-+CONFIG_IP_NF_MATCH_CONDITION
-+  This option allows you to match firewall rules against condition
-+  variables stored in the /proc/net/ipt_condition directory.
-+
-+  If you want to compile it as a module, say M here and read
-+  Documentation/modules.txt.  If unsure, say `N'.
-+
- conntrack match support
- CONFIG_IP_NF_MATCH_CONNTRACK
-   This is a general conntrack match module, a superset of the state match.
-@@ -3354,6 +3362,14 @@ CONFIG_IP6_NF_MATCH_MARK
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+Condition variable match support
-+CONFIG_IP6_NF_MATCH_CONDITION
-+  This option allows you to match firewall rules against condition
-+  variables stored in the /proc/net/ipt_condition directory.
-+
-+  If you want to compile it as a module, say M here and read
-+  Documentation/modules.txt.  If unsure, say `N'.
-+
- Multiple port match support
- CONFIG_IP6_NF_MATCH_MULTIPORT
-   Multiport matching allows you to match TCP or UDP packets based on
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_condition.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_condition.h
-@@ -0,0 +1,11 @@
-+#ifndef __IPT_CONDITION_MATCH__
-+#define __IPT_CONDITION_MATCH__
-+
-+#define CONDITION_NAME_LEN  32
-+
-+struct condition_info {
-+	char name[CONDITION_NAME_LEN];
-+	int  invert;
-+};
-+
-+#endif
-Index: linux-2.4.35.4/include/linux/netfilter_ipv6/ip6t_condition.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv6/ip6t_condition.h
-@@ -0,0 +1,11 @@
-+#ifndef __IP6T_CONDITION_MATCH__
-+#define __IP6T_CONDITION_MATCH__
-+
-+#define CONDITION6_NAME_LEN  32
-+
-+struct condition6_info {
-+	char name[CONDITION6_NAME_LEN];
-+	int  invert;
-+};
-+
-+#endif
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -43,6 +43,7 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-   dep_tristate '  netfilter MARK match support' CONFIG_IP_NF_MATCH_MARK $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  Multiple port match support' CONFIG_IP_NF_MATCH_MULTIPORT $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  TOS match support' CONFIG_IP_NF_MATCH_TOS $CONFIG_IP_NF_IPTABLES
-+  dep_tristate '  condition match support' CONFIG_IP_NF_MATCH_CONDITION $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  recent match support' CONFIG_IP_NF_MATCH_RECENT $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  ECN match support' CONFIG_IP_NF_MATCH_ECN $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  peer to peer traffic match support' CONFIG_IP_NF_MATCH_IPP2P $CONFIG_IP_NF_IPTABLES
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -94,6 +94,7 @@ obj-$(CONFIG_IP_NF_MATCH_PKTTYPE) += ipt
- obj-$(CONFIG_IP_NF_MATCH_MULTIPORT) += ipt_multiport.o
- obj-$(CONFIG_IP_NF_MATCH_OWNER) += ipt_owner.o
- obj-$(CONFIG_IP_NF_MATCH_TOS) += ipt_tos.o
-+obj-$(CONFIG_IP_NF_MATCH_CONDITION) += ipt_condition.o
- 
- obj-$(CONFIG_IP_NF_MATCH_RECENT) += ipt_recent.o
- 
-Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_condition.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ipt_condition.c
-@@ -0,0 +1,256 @@
-+/*-------------------------------------------*\
-+|          Netfilter Condition Module         |
-+|                                             |
-+|  Description: This module allows firewall   |
-+|    rules to match using condition variables |
-+|    stored in /proc files.                   |
-+|                                             |
-+|  Author: Stephane Ouellette     2002-10-22  |
-+|          <ouellettes@videotron.ca>          |
-+|                                             |
-+|  History:                                   |
-+|    2003-02-10  Second version with improved |
-+|                locking and simplified code. |
-+|                                             |
-+|  This software is distributed under the     |
-+|  terms of the GNU GPL.                      |
-+\*-------------------------------------------*/
-+
-+#include<linux/module.h>
-+#include<linux/proc_fs.h>
-+#include<linux/spinlock.h>
-+#include<linux/string.h>
-+#include<asm/atomic.h>
-+#include<linux/netfilter_ipv4/ip_tables.h>
-+#include<linux/netfilter_ipv4/ipt_condition.h>
-+
-+
-+#ifndef CONFIG_PROC_FS
-+#error  "Proc file system support is required for this module"
-+#endif
-+
-+
-+MODULE_AUTHOR("Stephane Ouellette <ouellettes@videotron.ca>");
-+MODULE_DESCRIPTION("Allows rules to match against condition variables");
-+MODULE_LICENSE("GPL");
-+
-+
-+struct condition_variable {
-+	struct condition_variable *next;
-+	struct proc_dir_entry *status_proc;
-+	atomic_t refcount;
-+        int enabled;   /* TRUE == 1, FALSE == 0 */
-+};
-+
-+
-+static rwlock_t list_lock;
-+static struct condition_variable *head = NULL;
-+static struct proc_dir_entry *proc_net_condition = NULL;
-+
-+
-+static int
-+ipt_condition_read_info(char *buffer, char **start, off_t offset,
-+			int length, int *eof, void *data)
-+{
-+	struct condition_variable *var =
-+	    (struct condition_variable *) data;
-+
-+	if (offset == 0) {
-+		*start = buffer;
-+		buffer[0] = (var->enabled) ? '1' : '0';
-+		buffer[1] = '\n';
-+		return 2;
-+	}
-+
-+	*eof = 1;
-+	return 0;
-+}
-+
-+
-+static int
-+ipt_condition_write_info(struct file *file, const char *buffer,
-+			 unsigned long length, void *data)
-+{
-+	struct condition_variable *var =
-+	    (struct condition_variable *) data;
-+
-+	if (length) {
-+	        /* Match only on the first character */
-+		switch (buffer[0]) {
-+		case '0':
-+			var->enabled = 0;
-+			break;
-+		case '1':
-+			var->enabled = 1;
-+		}
-+	}
-+
-+	return (int) length;
-+}
-+
-+
-+static int
-+match(const struct sk_buff *skb, const struct net_device *in,
-+      const struct net_device *out, const void *matchinfo, int offset,
-+      const void *hdr, u_int16_t datalen, int *hotdrop)
-+{
-+	const struct condition_info *info =
-+	    (const struct condition_info *) matchinfo;
-+	struct condition_variable *var;
-+	int condition_status = 0;
-+
-+	read_lock(&list_lock);
-+
-+	for (var = head; var; var = var->next) {
-+		if (strcmp(info->name, var->status_proc->name) == 0) {
-+			condition_status = var->enabled;
-+			break;
-+		}
-+	}
-+
-+	read_unlock(&list_lock);
-+
-+	return condition_status ^ info->invert;
-+}
-+
-+
-+
-+static int
-+checkentry(const char *tablename, const struct ipt_ip *ip,
-+	   void *matchinfo, unsigned int matchsize, unsigned int hook_mask)
-+{
-+	struct condition_info *info = (struct condition_info *) matchinfo;
-+	struct condition_variable *var, *newvar;
-+
-+	if (matchsize != IPT_ALIGN(sizeof(struct condition_info)))
-+		return 0;
-+
-+	/* The first step is to check if the condition variable already exists. */
-+	/* Here, a read lock is sufficient because we won't change the list */
-+	read_lock(&list_lock);
-+
-+	for (var = head; var; var = var->next) {
-+		if (strcmp(info->name, var->status_proc->name) == 0) {
-+			atomic_inc(&var->refcount);
-+			read_unlock(&list_lock);
-+			return 1;
-+		}
-+	}
-+
-+	read_unlock(&list_lock);
-+
-+	/* At this point, we need to allocate a new condition variable */
-+	newvar = kmalloc(sizeof(struct condition_variable), GFP_KERNEL);
-+
-+	if (!newvar)
-+		return -ENOMEM;
-+
-+	/* Create the condition variable's proc file entry */
-+	newvar->status_proc = create_proc_entry(info->name, 0644, proc_net_condition);
-+
-+	if (!newvar->status_proc) {
-+	  /*
-+	   * There are two possibilities:
-+	   *  1- Another condition variable with the same name has been created, which is valid.
-+	   *  2- There was a memory allocation error.
-+	   */
-+		kfree(newvar);
-+		read_lock(&list_lock);
-+
-+		for (var = head; var; var = var->next) {
-+			if (strcmp(info->name, var->status_proc->name) == 0) {
-+				atomic_inc(&var->refcount);
-+				read_unlock(&list_lock);
-+				return 1;
-+			}
-+		}
-+
-+		read_unlock(&list_lock);
-+		return -ENOMEM;
-+	}
-+
-+	atomic_set(&newvar->refcount, 1);
-+	newvar->enabled = 0;
-+	newvar->status_proc->owner = THIS_MODULE;
-+	newvar->status_proc->data = newvar;
-+	wmb();
-+	newvar->status_proc->read_proc = ipt_condition_read_info;
-+	newvar->status_proc->write_proc = ipt_condition_write_info;
-+
-+	write_lock(&list_lock);
-+
-+	newvar->next = head;
-+	head = newvar;
-+
-+	write_unlock(&list_lock);
-+
-+	return 1;
-+}
-+
-+
-+static void
-+destroy(void *matchinfo, unsigned int matchsize)
-+{
-+	struct condition_info *info = (struct condition_info *) matchinfo;
-+	struct condition_variable *var, *prev = NULL;
-+
-+	if (matchsize != IPT_ALIGN(sizeof(struct condition_info)))
-+		return;
-+
-+	write_lock(&list_lock);
-+
-+	for (var = head; var && strcmp(info->name, var->status_proc->name);
-+	     prev = var, var = var->next);
-+
-+	if (var && atomic_dec_and_test(&var->refcount)) {
-+		if (prev)
-+			prev->next = var->next;
-+		else
-+			head = var->next;
-+
-+		write_unlock(&list_lock);
-+		remove_proc_entry(var->status_proc->name, proc_net_condition);
-+		kfree(var);
-+	} else
-+		write_unlock(&list_lock);
-+}
-+
-+
-+static struct ipt_match condition_match = {
-+	.name = "condition",
-+	.match = &match,
-+	.checkentry = &checkentry,
-+	.destroy = &destroy,
-+	.me = THIS_MODULE
-+};
-+
-+
-+static int __init
-+init(void)
-+{
-+	int errorcode;
-+
-+	rwlock_init(&list_lock);
-+	proc_net_condition = proc_mkdir("ipt_condition", proc_net);
-+
-+	if (proc_net_condition) {
-+	        errorcode = ipt_register_match(&condition_match);
-+
-+		if (errorcode)
-+			remove_proc_entry("ipt_condition", proc_net);
-+	} else
-+		errorcode = -EACCES;
-+
-+	return errorcode;
-+}
-+
-+
-+static void __exit
-+fini(void)
-+{
-+	ipt_unregister_match(&condition_match);
-+	remove_proc_entry("ipt_condition", proc_net);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv6/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv6/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv6/netfilter/Config.in
-@@ -17,6 +17,7 @@ tristate 'IP6 tables support (required f
- if [ "$CONFIG_IP6_NF_IPTABLES" != "n" ]; then
- # The simple matches.
-   dep_tristate '  limit match support' CONFIG_IP6_NF_MATCH_LIMIT $CONFIG_IP6_NF_IPTABLES
-+  dep_tristate '  condition match support' CONFIG_IP6_NF_MATCH_CONDITION $CONFIG_IP6_NF_IPTABLES
-   dep_tristate '  MAC address match support' CONFIG_IP6_NF_MATCH_MAC $CONFIG_IP6_NF_IPTABLES
-   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-     dep_tristate '  Routing header match support (EXPERIMENTAL)' CONFIG_IP6_NF_MATCH_RT $CONFIG_IP6_NF_IPTABLES
-Index: linux-2.4.35.4/net/ipv6/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv6/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv6/netfilter/Makefile
-@@ -14,6 +14,7 @@ export-objs := ip6_tables.o
- # Link order matters here.
- obj-$(CONFIG_IP6_NF_IPTABLES) += ip6_tables.o
- obj-$(CONFIG_IP6_NF_MATCH_LIMIT) += ip6t_limit.o
-+obj-$(CONFIG_IP6_NF_MATCH_CONDITION) += ip6t_condition.o
- obj-$(CONFIG_IP6_NF_MATCH_MARK) += ip6t_mark.o
- obj-$(CONFIG_IP6_NF_MATCH_LENGTH) += ip6t_length.o
- obj-$(CONFIG_IP6_NF_MATCH_MAC) += ip6t_mac.o
-Index: linux-2.4.35.4/net/ipv6/netfilter/ip6t_condition.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv6/netfilter/ip6t_condition.c
-@@ -0,0 +1,254 @@
-+/*-------------------------------------------*\
-+|    Netfilter Condition Module for IPv6      |
-+|                                             |
-+|  Description: This module allows firewall   |
-+|    rules to match using condition variables |
-+|    stored in /proc files.                   |
-+|                                             |
-+|  Author: Stephane Ouellette     2003-02-10  |
-+|          <ouellettes@videotron.ca>          |
-+|                                             |
-+|  This software is distributed under the     |
-+|  terms of the GNU GPL.                      |
-+\*-------------------------------------------*/
-+
-+#include<linux/module.h>
-+#include<linux/proc_fs.h>
-+#include<linux/spinlock.h>
-+#include<linux/string.h>
-+#include<asm/atomic.h>
-+#include<linux/netfilter_ipv6/ip6_tables.h>
-+#include<linux/netfilter_ipv6/ip6t_condition.h>
-+
-+
-+#ifndef CONFIG_PROC_FS
-+#error  "Proc file system support is required for this module"
-+#endif
-+
-+
-+MODULE_AUTHOR("Stephane Ouellette <ouellettes@videotron.ca>");
-+MODULE_DESCRIPTION("Allows rules to match against condition variables");
-+MODULE_LICENSE("GPL");
-+
-+
-+struct condition_variable {
-+	struct condition_variable *next;
-+	struct proc_dir_entry *status_proc;
-+	atomic_t refcount;
-+        int enabled; /* TRUE == 1, FALSE == 0 */
-+};
-+
-+
-+static rwlock_t list_lock;
-+static struct condition_variable *head = NULL;
-+static struct proc_dir_entry *proc_net_condition = NULL;
-+
-+
-+static int
-+ipt_condition_read_info(char *buffer, char **start, off_t offset,
-+			int length, int *eof, void *data)
-+{
-+	struct condition_variable *var =
-+	    (struct condition_variable *) data;
-+
-+	if (offset == 0) {
-+		*start = buffer;
-+		buffer[0] = (var->enabled) ? '1' : '0';
-+		buffer[1] = '\n';
-+		return 2;
-+	}
-+
-+	*eof = 1;
-+	return 0;
-+}
-+
-+
-+static int
-+ipt_condition_write_info(struct file *file, const char *buffer,
-+			 unsigned long length, void *data)
-+{
-+	struct condition_variable *var =
-+	    (struct condition_variable *) data;
-+
-+	if (length) {
-+	        /* Match only on the first character */
-+		switch (buffer[0]) {
-+		case '0':
-+			var->enabled = 0;
-+			break;
-+		case '1':
-+			var->enabled = 1;
-+		}
-+	}
-+
-+	return (int) length;
-+}
-+
-+
-+static int
-+match(const struct sk_buff *skb, const struct net_device *in,
-+      const struct net_device *out, const void *matchinfo, int offset,
-+      const void *hdr, u_int16_t datalen, int *hotdrop)
-+{
-+	const struct condition6_info *info =
-+	    (const struct condition6_info *) matchinfo;
-+	struct condition_variable *var;
-+	int condition_status = 0;
-+
-+	read_lock(&list_lock);
-+
-+	for (var = head; var; var = var->next) {
-+		if (strcmp(info->name, var->status_proc->name) == 0) {
-+			condition_status = var->enabled;
-+			break;
-+		}
-+	}
-+
-+	read_unlock(&list_lock);
-+
-+	return condition_status ^ info->invert;
-+}
-+
-+
-+
-+static int
-+checkentry(const char *tablename, const struct ip6t_ip6 *ip,
-+	   void *matchinfo, unsigned int matchsize, unsigned int hook_mask)
-+{
-+	struct condition6_info *info =
-+	    (struct condition6_info *) matchinfo;
-+	struct condition_variable *var, *newvar;
-+
-+	if (matchsize != IP6T_ALIGN(sizeof(struct condition6_info)))
-+		return 0;
-+
-+	/* The first step is to check if the condition variable already exists. */
-+	/* Here, a read lock is sufficient because we won't change the list */
-+	read_lock(&list_lock);
-+
-+	for (var = head; var; var = var->next) {
-+		if (strcmp(info->name, var->status_proc->name) == 0) {
-+			atomic_inc(&var->refcount);
-+			read_unlock(&list_lock);
-+			return 1;
-+		}
-+	}
-+
-+	read_unlock(&list_lock);
-+
-+	/* At this point, we need to allocate a new condition variable */
-+	newvar = kmalloc(sizeof(struct condition_variable), GFP_KERNEL);
-+
-+	if (!newvar)
-+		return -ENOMEM;
-+
-+	/* Create the condition variable's proc file entry */
-+	newvar->status_proc = create_proc_entry(info->name, 0644, proc_net_condition);
-+
-+	if (!newvar->status_proc) {
-+	  /*
-+	   * There are two possibilities:
-+	   *  1- Another condition variable with the same name has been created, which is valid.
-+	   *  2- There was a memory allocation error.
-+	   */
-+		kfree(newvar);
-+		read_lock(&list_lock);
-+
-+		for (var = head; var; var = var->next) {
-+			if (strcmp(info->name, var->status_proc->name) == 0) {
-+				atomic_inc(&var->refcount);
-+				read_unlock(&list_lock);
-+				return 1;
-+			}
-+		}
-+
-+		read_unlock(&list_lock);
-+		return -ENOMEM;
-+	}
-+
-+	atomic_set(&newvar->refcount, 1);
-+	newvar->enabled = 0;
-+	newvar->status_proc->owner = THIS_MODULE;
-+	newvar->status_proc->data = newvar;
-+	wmb();
-+	newvar->status_proc->read_proc = ipt_condition_read_info;
-+	newvar->status_proc->write_proc = ipt_condition_write_info;
-+
-+	write_lock(&list_lock);
-+
-+	newvar->next = head;
-+	head = newvar;
-+
-+	write_unlock(&list_lock);
-+
-+	return 1;
-+}
-+
-+
-+static void
-+destroy(void *matchinfo, unsigned int matchsize)
-+{
-+	struct condition6_info *info =
-+	    (struct condition6_info *) matchinfo;
-+	struct condition_variable *var, *prev = NULL;
-+
-+	if (matchsize != IP6T_ALIGN(sizeof(struct condition6_info)))
-+		return;
-+
-+	write_lock(&list_lock);
-+
-+	for (var = head; var && strcmp(info->name, var->status_proc->name);
-+	     prev = var, var = var->next);
-+
-+	if (var && atomic_dec_and_test(&var->refcount)) {
-+		if (prev)
-+			prev->next = var->next;
-+		else
-+			head = var->next;
-+
-+		write_unlock(&list_lock);
-+		remove_proc_entry(var->status_proc->name, proc_net_condition);
-+		kfree(var);
-+	} else
-+		write_unlock(&list_lock);
-+}
-+
-+
-+static struct ip6t_match condition_match = {
-+	.name = "condition",
-+	.match = &match,
-+	.checkentry = &checkentry,
-+	.destroy = &destroy,
-+	.me = THIS_MODULE
-+};
-+
-+
-+static int __init
-+init(void)
-+{
-+	int errorcode;
-+
-+	rwlock_init(&list_lock);
-+	proc_net_condition = proc_mkdir("ip6t_condition", proc_net);
-+
-+	if (proc_net_condition) {
-+	        errorcode = ipt_register_match(&condition_match);
-+
-+		if (errorcode)
-+			remove_proc_entry("ip6t_condition", proc_net);
-+	} else
-+		errorcode = -EACCES;
-+
-+	return errorcode;
-+}
-+
-+
-+static void __exit
-+fini(void)
-+{
-+	ipt_unregister_match(&condition_match);
-+	remove_proc_entry("ip6t_condition", proc_net);
-+}
-+
-+module_init(init);
-+module_exit(fini);
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/612-netfilter_quota.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,152 +0,0 @@
-Index: linux-2.4.35.4/Documentation/Configure.help
-===================================================================
---- linux-2.4.35.4.orig/Documentation/Configure.help
-+++ linux-2.4.35.4/Documentation/Configure.help
-@@ -2888,6 +2888,13 @@ CONFIG_IP_NF_MATCH_LIMIT
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+quota match support
-+CONFIG_IP_NF_MATCH_QUOTA
-+  This match implements network quotas.
-+
-+  If you want to compile it as a module, say M here and read
-+  Documentation/modules.txt.  If unsure, say `N'.
-+
- skb->pkt_type packet match support
- CONFIG_IP_NF_MATCH_PKTTYPE
-   This patch allows you to match packet in accrodance
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_quota.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_quota.h
-@@ -0,0 +1,12 @@
-+#ifndef _IPT_QUOTA_H
-+#define _IPT_QUOTA_H
-+
-+/* print debug info in both kernel/netfilter module & iptable library */
-+//#define DEBUG_IPT_QUOTA
-+
-+struct ipt_quota_info {
-+        u_int64_t quota;
-+	struct ipt_quota_info *master;
-+};
-+
-+#endif /*_IPT_QUOTA_H*/
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -24,6 +24,7 @@ tristate 'IP tables support (required fo
- if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; then
- # The simple matches.
-   dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
-+  dep_tristate '  quota match support' CONFIG_IP_NF_MATCH_QUOTA $CONFIG_IP_NF_IPTABLES
- 
-   dep_tristate '  IP set support' CONFIG_IP_NF_SET $CONFIG_IP_NF_IPTABLES
-   if [ "$CONFIG_IP_NF_SET" != "n" ]; then
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -74,6 +74,7 @@ obj-$(CONFIG_IP_NF_NAT) += iptable_nat.o
- # matches
- obj-$(CONFIG_IP_NF_MATCH_HELPER) += ipt_helper.o
- obj-$(CONFIG_IP_NF_MATCH_LIMIT) += ipt_limit.o
-+obj-$(CONFIG_IP_NF_MATCH_QUOTA) += ipt_quota.o
- obj-$(CONFIG_IP_NF_MATCH_MARK) += ipt_mark.o
- obj-$(CONFIG_IP_NF_MATCH_SET) += ipt_set.o
- obj-$(CONFIG_IP_NF_TARGET_SET) += ipt_SET.o
-Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_quota.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ipt_quota.c
-@@ -0,0 +1,88 @@
-+/* 
-+ * netfilter module to enforce network quotas
-+ *
-+ * Sam Johnston <samj@samj.net>
-+ *
-+ * 30/01/05: Fixed on SMP --Pablo Neira <pablo@eurodev.net>
-+ */
-+#include <linux/module.h>
-+#include <linux/skbuff.h>
-+#include <linux/spinlock.h>
-+#include <linux/interrupt.h>
-+
-+#include <linux/netfilter_ipv4/ip_tables.h>
-+#include <linux/netfilter_ipv4/ipt_quota.h>
-+
-+MODULE_LICENSE("GPL");
-+
-+static spinlock_t quota_lock = SPIN_LOCK_UNLOCKED;
-+
-+static int
-+match(const struct sk_buff *skb,
-+      const struct net_device *in,
-+      const struct net_device *out,
-+      const void *matchinfo,
-+      int offset, const void *hdr, u_int16_t datalen, int *hotdrop)
-+{
-+	struct ipt_quota_info *q =
-+		((struct ipt_quota_info *) matchinfo)->master;
-+
-+        spin_lock_bh(&quota_lock);
-+
-+        if (q->quota >= datalen) {
-+                /* we can afford this one */
-+                q->quota -= datalen;
-+                spin_unlock_bh(&quota_lock);
-+
-+#ifdef DEBUG_IPT_QUOTA
-+                printk("IPT Quota OK: %llu datlen %d \n", q->quota, datalen);
-+#endif
-+                return 1;
-+        }
-+
-+        /* so we do not allow even small packets from now on */
-+        q->quota = 0;
-+
-+#ifdef DEBUG_IPT_QUOTA
-+        printk("IPT Quota Failed: %llu datlen %d \n", q->quota, datalen);
-+#endif
-+
-+        spin_unlock_bh(&quota_lock);
-+        return 0;
-+}
-+
-+static int
-+checkentry(const char *tablename,
-+           const struct ipt_ip *ip,
-+           void *matchinfo, unsigned int matchsize, unsigned int hook_mask)
-+{
-+        /* TODO: spinlocks? sanity checks? */
-+	struct ipt_quota_info *q = (struct ipt_quota_info *) matchinfo;
-+
-+        if (matchsize != IPT_ALIGN(sizeof (struct ipt_quota_info)))
-+                return 0;
-+	
-+	/* For SMP, we only want to use one set of counters. */
-+	q->master = q;
-+
-+        return 1;
-+}
-+
-+static struct ipt_match quota_match
-+    = { {NULL, NULL}, "quota", &match, &checkentry, NULL, THIS_MODULE };
-+
-+static int __init
-+init(void)
-+{
-+        return ipt_register_match(&quota_match);
-+}
-+
-+static void __exit
-+fini(void)
-+{
-+        ipt_unregister_match(&quota_match);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-+
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/613-netfilter_nat_h323.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,827 +0,0 @@
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -15,6 +15,7 @@ if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ];
-   dep_tristate '  Connection byte counter support' CONFIG_IP_NF_MATCH_CONNBYTES $CONFIG_IP_NF_CT_ACCT $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  GRE protocol support' CONFIG_IP_NF_CT_PROTO_GRE $CONFIG_IP_NF_CONNTRACK
-   dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
-+  dep_tristate '  H.323 (netmeeting) support' CONFIG_IP_NF_H323 $CONFIG_IP_NF_CONNTRACK
- fi
- 
- if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-@@ -110,6 +111,13 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-           define_tristate CONFIG_IP_NF_NAT_AMANDA $CONFIG_IP_NF_NAT
-         fi
-       fi
-+      if [ "$CONFIG_IP_NF_H323" = "m" ]; then
-+       define_tristate CONFIG_IP_NF_NAT_H323 m
-+      else
-+       if [ "$CONFIG_IP_NF_H323" = "y" ]; then
-+         define_tristate CONFIG_IP_NF_NAT_H323 $CONFIG_IP_NF_NAT
-+       fi
-+      fi
-       if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-         dep_tristate '    Basic SNMP-ALG support (EXPERIMENTAL)' CONFIG_IP_NF_NAT_SNMP_BASIC $CONFIG_IP_NF_NAT
-       fi
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -53,6 +53,10 @@ obj-$(CONFIG_IP_NF_PPTP) += ip_conntrack
- ifdef CONFIG_IP_NF_NAT_PPTP
- 	export-objs += ip_conntrack_pptp.o
- endif
-+obj-$(CONFIG_IP_NF_H323) += ip_conntrack_h323.o
-+ifdef CONFIG_IP_NF_NAT_H323
-+       export-objs += ip_conntrack_h323.o
-+endif
- 
- 
- # NAT helpers 
-@@ -62,6 +66,7 @@ obj-$(CONFIG_IP_NF_NAT_FTP) += ip_nat_ft
- obj-$(CONFIG_IP_NF_NAT_IRC) += ip_nat_irc.o
- obj-$(CONFIG_IP_NF_NAT_PROTO_GRE) += ip_nat_proto_gre.o
- obj-$(CONFIG_IP_NF_NAT_PPTP) += ip_nat_pptp.o
-+obj-$(CONFIG_IP_NF_NAT_H323) += ip_nat_h323.o
- 
- # generic IP tables 
- obj-$(CONFIG_IP_NF_IPTABLES) += ip_tables.o
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_h323.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_h323.c
-@@ -0,0 +1,302 @@
-+/* 
-+ * H.323 'brute force' extension for H.323 connection tracking. 
-+ * Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
-+ *
-+ * Based on ip_masq_h323.c for 2.2 kernels from CoRiTel, Sofia project.
-+ * (http://www.coritel.it/projects/sofia/nat/)
-+ * Uses Sampsa Ranta's excellent idea on using expectfn to 'bind'
-+ * the unregistered helpers to the conntrack entries.
-+ */
-+
-+
-+#include <linux/module.h>
-+#include <linux/netfilter.h>
-+#include <linux/ip.h>
-+#include <net/checksum.h>
-+#include <net/tcp.h>
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_core.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_h323.h>
-+
-+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
-+MODULE_DESCRIPTION("H.323 'brute force' connection tracking module");
-+MODULE_LICENSE("GPL");
-+
-+DECLARE_LOCK(ip_h323_lock);
-+struct module *ip_conntrack_h323 = THIS_MODULE;
-+
-+#define DEBUGP(format, args...)
-+
-+static int h245_help(const struct iphdr *iph, size_t len,
-+		     struct ip_conntrack *ct,
-+		     enum ip_conntrack_info ctinfo)
-+{
-+	struct tcphdr *tcph = (void *)iph + iph->ihl * 4;
-+	unsigned char *data = (unsigned char *) tcph + tcph->doff * 4;
-+	unsigned char *data_limit;
-+	u_int32_t tcplen = len - iph->ihl * 4;
-+	u_int32_t datalen = tcplen - tcph->doff * 4;
-+	int dir = CTINFO2DIR(ctinfo);
-+	struct ip_ct_h225_master *info = &ct->help.ct_h225_info;
-+	struct ip_conntrack_expect expect, *exp = &expect;
-+	struct ip_ct_h225_expect *exp_info = &exp->help.exp_h225_info;
-+	u_int16_t data_port;
-+	u_int32_t data_ip;
-+	unsigned int i;
-+
-+	DEBUGP("ct_h245_help: help entered %u.%u.%u.%u:%u->%u.%u.%u.%u:%u\n",
-+		NIPQUAD(iph->saddr), ntohs(tcph->source),
-+		NIPQUAD(iph->daddr), ntohs(tcph->dest));
-+
-+	/* Can't track connections formed before we registered */
-+	if (!info)
-+		return NF_ACCEPT;
-+		
-+	/* Until there's been traffic both ways, don't look in packets. */
-+	if (ctinfo != IP_CT_ESTABLISHED
-+	    && ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
-+		DEBUGP("ct_h245_help: Conntrackinfo = %u\n", ctinfo);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* Not whole TCP header or too short packet? */
-+	if (tcplen < sizeof(struct tcphdr) || tcplen < tcph->doff * 4 + 5) {
-+		DEBUGP("ct_h245_help: tcplen = %u\n", (unsigned)tcplen);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* Checksum invalid?  Ignore. */
-+	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
-+			      csum_partial((char *)tcph, tcplen, 0))) {
-+		DEBUGP("ct_h245_help: bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
-+		       tcph, tcplen, NIPQUAD(iph->saddr),
-+		       NIPQUAD(iph->daddr));
-+		return NF_ACCEPT;
-+	}
-+
-+	data_limit = (unsigned char *) data + datalen;
-+	/* bytes: 0123   45
-+	          ipadrr port */
-+	for (i = 0; data < (data_limit - 5); data++, i++) {
-+		memcpy(&data_ip, data, sizeof(u_int32_t));
-+		if (data_ip == iph->saddr) {
-+			memcpy(&data_port, data + 4, sizeof(u_int16_t));
-+			memset(&expect, 0, sizeof(expect));
-+			/* update the H.225 info */
-+			DEBUGP("ct_h245_help: new RTCP/RTP requested %u.%u.%u.%u:->%u.%u.%u.%u:%u\n",
-+				NIPQUAD(ct->tuplehash[!dir].tuple.src.ip),
-+				NIPQUAD(iph->saddr), ntohs(data_port));
-+			LOCK_BH(&ip_h323_lock);
-+			info->is_h225 = H225_PORT + 1;
-+			exp_info->port = data_port;
-+			exp_info->dir = dir;
-+			exp_info->offset = i;
-+
-+			exp->seq = ntohl(tcph->seq) + i;
-+		    
-+			exp->tuple = ((struct ip_conntrack_tuple)
-+				{ { ct->tuplehash[!dir].tuple.src.ip,
-+				    { 0 } },
-+				  { data_ip,
-+				    { data_port },
-+				    IPPROTO_UDP }});
-+			exp->mask = ((struct ip_conntrack_tuple)
-+				{ { 0xFFFFFFFF, { 0 } },
-+				  { 0xFFFFFFFF, { 0xFFFF }, 0xFFFF }});
-+	
-+			exp->expectfn = NULL;
-+			
-+			/* Ignore failure; should only happen with NAT */
-+			ip_conntrack_expect_related(ct, exp);
-+
-+			UNLOCK_BH(&ip_h323_lock);
-+		}
-+	}
-+
-+	return NF_ACCEPT;
-+
-+}
-+
-+/* H.245 helper is not registered! */
-+static struct ip_conntrack_helper h245 = 
-+	{ { NULL, NULL },
-+          "H.245",				/* name */
-+          IP_CT_HELPER_F_REUSE_EXPECT,		/* flags */
-+          NULL,					/* module */
-+          8,					/* max_ expected */
-+          240,					/* timeout */
-+          { { 0, { 0 } },			/* tuple */
-+            { 0, { 0 }, IPPROTO_TCP } },
-+          { { 0, { 0xFFFF } },			/* mask */
-+            { 0, { 0 }, 0xFFFF } },
-+          h245_help				/* helper */
-+	};
-+
-+static int h225_expect(struct ip_conntrack *ct)
-+{
-+	WRITE_LOCK(&ip_conntrack_lock);
-+	ct->helper = &h245;
-+	DEBUGP("h225_expect: helper for %p added\n", ct);
-+	WRITE_UNLOCK(&ip_conntrack_lock);
-+	
-+	return NF_ACCEPT;	/* unused */
-+}
-+
-+static int h225_help(const struct iphdr *iph, size_t len,
-+		     struct ip_conntrack *ct,
-+		     enum ip_conntrack_info ctinfo)
-+{
-+	struct tcphdr *tcph = (void *)iph + iph->ihl * 4;
-+	unsigned char *data = (unsigned char *) tcph + tcph->doff * 4;
-+	unsigned char *data_limit;
-+	u_int32_t tcplen = len - iph->ihl * 4;
-+	u_int32_t datalen = tcplen - tcph->doff * 4;
-+	int dir = CTINFO2DIR(ctinfo);
-+	struct ip_ct_h225_master *info = &ct->help.ct_h225_info;
-+	struct ip_conntrack_expect expect, *exp = &expect;
-+	struct ip_ct_h225_expect *exp_info = &exp->help.exp_h225_info;
-+	u_int16_t data_port;
-+	u_int32_t data_ip;
-+	unsigned int i;
-+	
-+	DEBUGP("ct_h225_help: help entered %u.%u.%u.%u:%u->%u.%u.%u.%u:%u\n",
-+		NIPQUAD(iph->saddr), ntohs(tcph->source),
-+		NIPQUAD(iph->daddr), ntohs(tcph->dest));
-+
-+	/* Can't track connections formed before we registered */
-+	if (!info)
-+		return NF_ACCEPT;
-+
-+	/* Until there's been traffic both ways, don't look in packets. */
-+	if (ctinfo != IP_CT_ESTABLISHED
-+	    && ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
-+		DEBUGP("ct_h225_help: Conntrackinfo = %u\n", ctinfo);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* Not whole TCP header or too short packet? */
-+	if (tcplen < sizeof(struct tcphdr) || tcplen < tcph->doff * 4 + 5) {
-+		DEBUGP("ct_h225_help: tcplen = %u\n", (unsigned)tcplen);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* Checksum invalid?  Ignore. */
-+	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
-+			      csum_partial((char *)tcph, tcplen, 0))) {
-+		DEBUGP("ct_h225_help: bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
-+		       tcph, tcplen, NIPQUAD(iph->saddr),
-+		       NIPQUAD(iph->daddr));
-+		return NF_ACCEPT;
-+	}
-+	
-+	data_limit = (unsigned char *) data + datalen;
-+	/* bytes: 0123   45
-+	          ipadrr port */
-+	for (i = 0; data < (data_limit - 5); data++, i++) {
-+		memcpy(&data_ip, data, sizeof(u_int32_t));
-+		if (data_ip == iph->saddr) {
-+			memcpy(&data_port, data + 4, sizeof(u_int16_t));
-+			if (data_port == tcph->source) {
-+				/* Signal address */
-+				DEBUGP("ct_h225_help: sourceCallSignalAddress from %u.%u.%u.%u\n",
-+					NIPQUAD(iph->saddr));
-+				/* Update the H.225 info so that NAT can mangle the address/port
-+				   even when we have no expected connection! */
-+#ifdef CONFIG_IP_NF_NAT_NEEDED
-+				LOCK_BH(&ip_h323_lock);
-+				info->dir = dir;
-+				info->seq[IP_CT_DIR_ORIGINAL] = ntohl(tcph->seq) + i;
-+				info->offset[IP_CT_DIR_ORIGINAL] = i;
-+				UNLOCK_BH(&ip_h323_lock);
-+#endif
-+			} else {
-+				memset(&expect, 0, sizeof(expect));
-+
-+				/* update the H.225 info */
-+				LOCK_BH(&ip_h323_lock);
-+				info->is_h225 = H225_PORT;
-+				exp_info->port = data_port;
-+				exp_info->dir = dir;
-+				exp_info->offset = i;
-+
-+				exp->seq = ntohl(tcph->seq) + i;
-+
-+				exp->tuple = ((struct ip_conntrack_tuple)
-+					{ { ct->tuplehash[!dir].tuple.src.ip,
-+					    { 0 } },
-+					  { data_ip,
-+					    { data_port },
-+					    IPPROTO_TCP }});
-+				exp->mask = ((struct ip_conntrack_tuple)
-+					{ { 0xFFFFFFFF, { 0 } },
-+					  { 0xFFFFFFFF, { 0xFFFF }, 0xFFFF }});
-+	
-+				exp->expectfn = h225_expect;
-+				
-+				/* Ignore failure */
-+				ip_conntrack_expect_related(ct, exp);
-+
-+				DEBUGP("ct_h225_help: new H.245 requested %u.%u.%u.%u->%u.%u.%u.%u:%u\n",
-+					NIPQUAD(ct->tuplehash[!dir].tuple.src.ip),
-+					NIPQUAD(iph->saddr), ntohs(data_port));
-+
-+				UNLOCK_BH(&ip_h323_lock);
-+                	}  
-+#ifdef CONFIG_IP_NF_NAT_NEEDED
-+		} else if (data_ip == iph->daddr) {
-+			memcpy(&data_port, data + 4, sizeof(u_int16_t));
-+			if (data_port == tcph->dest) {
-+				/* Signal address */
-+				DEBUGP("ct_h225_help: destCallSignalAddress %u.%u.%u.%u\n",
-+					NIPQUAD(iph->daddr));
-+				/* Update the H.225 info so that NAT can mangle the address/port
-+				   even when we have no expected connection! */
-+				LOCK_BH(&ip_h323_lock);
-+				info->dir = dir;
-+				info->seq[IP_CT_DIR_REPLY] = ntohl(tcph->seq) + i;
-+				info->offset[IP_CT_DIR_REPLY] = i;
-+				UNLOCK_BH(&ip_h323_lock);
-+			}
-+#endif
-+		}
-+	}
-+
-+	return NF_ACCEPT;
-+
-+}
-+
-+static struct ip_conntrack_helper h225 = 
-+	{ { NULL, NULL },
-+	  "H.225",					/* name */
-+	  IP_CT_HELPER_F_REUSE_EXPECT,			/* flags */
-+	  THIS_MODULE,					/* module */
-+	  2,						/* max_expected */
-+	  240,						/* timeout */
-+	  { { 0, { __constant_htons(H225_PORT) } },	/* tuple */
-+	    { 0, { 0 }, IPPROTO_TCP } },
-+	  { { 0, { 0xFFFF } },				/* mask */
-+	    { 0, { 0 }, 0xFFFF } },
-+	  h225_help					/* helper */
-+	};
-+
-+static int __init init(void)
-+{
-+	return ip_conntrack_helper_register(&h225);
-+}
-+
-+static void __exit fini(void)
-+{
-+	/* Unregister H.225 helper */	
-+	ip_conntrack_helper_unregister(&h225);
-+}
-+
-+#ifdef CONFIG_IP_NF_NAT_NEEDED
-+EXPORT_SYMBOL(ip_h323_lock);
-+#endif
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_nat_h323.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_nat_h323.c
-@@ -0,0 +1,403 @@
-+/* 
-+ * H.323 'brute force' extension for NAT alteration. 
-+ * Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
-+ *
-+ * Based on ip_masq_h323.c for 2.2 kernels from CoRiTel, Sofia project.
-+ * (http://www.coritel.it/projects/sofia/nat.html)
-+ * Uses Sampsa Ranta's excellent idea on using expectfn to 'bind'
-+ * the unregistered helpers to the conntrack entries.
-+ */
-+
-+
-+#include <linux/module.h>
-+#include <linux/netfilter.h>
-+#include <linux/ip.h>
-+#include <net/checksum.h>
-+#include <net/tcp.h>
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+#include <linux/netfilter_ipv4/ip_nat.h>
-+#include <linux/netfilter_ipv4/ip_nat_helper.h>
-+#include <linux/netfilter_ipv4/ip_nat_rule.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_h323.h>
-+
-+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
-+MODULE_DESCRIPTION("H.323 'brute force' connection tracking module");
-+MODULE_LICENSE("GPL");
-+
-+DECLARE_LOCK_EXTERN(ip_h323_lock);
-+struct module *ip_nat_h323 = THIS_MODULE;
-+
-+#define DEBUGP(format, args...)
-+
-+
-+static unsigned int 
-+h225_nat_expected(struct sk_buff **pskb,
-+		  unsigned int hooknum,
-+		  struct ip_conntrack *ct,
-+		  struct ip_nat_info *info);
-+
-+static unsigned int h225_nat_help(struct ip_conntrack *ct,
-+				  struct ip_conntrack_expect *exp,
-+			 	  struct ip_nat_info *info,
-+			 	  enum ip_conntrack_info ctinfo,
-+			 	  unsigned int hooknum,
-+			 	  struct sk_buff **pskb);
-+		  
-+static struct ip_nat_helper h245 = 
-+	{ { NULL, NULL },
-+          "H.245",				/* name */
-+	  0,					/* flags */
-+	  NULL,					/* module */
-+	  { { 0, { 0 } },			/* tuple */
-+	    { 0, { 0 }, IPPROTO_TCP } },
-+	  { { 0, { 0xFFFF } },			/* mask */
-+	    { 0, { 0 }, 0xFFFF } },
-+	  h225_nat_help,			/* helper */
-+	  h225_nat_expected			/* expectfn */
-+	};
-+
-+static unsigned int
-+h225_nat_expected(struct sk_buff **pskb,
-+		  unsigned int hooknum,
-+		  struct ip_conntrack *ct,
-+		  struct ip_nat_info *info)
-+{
-+	struct ip_nat_multi_range mr;
-+	u_int32_t newdstip, newsrcip, newip;
-+	u_int16_t port;
-+	struct ip_ct_h225_expect *exp_info;
-+	struct ip_ct_h225_master *master_info;
-+	struct ip_conntrack *master = master_ct(ct);
-+	unsigned int is_h225, ret;
-+	
-+	IP_NF_ASSERT(info);
-+	IP_NF_ASSERT(master);
-+
-+	IP_NF_ASSERT(!(info->initialized & (1<<HOOK2MANIP(hooknum))));
-+
-+	DEBUGP("h225_nat_expected: We have a connection!\n");
-+	master_info = &ct->master->expectant->help.ct_h225_info;
-+	exp_info = &ct->master->help.exp_h225_info;
-+
-+	LOCK_BH(&ip_h323_lock);
-+
-+	DEBUGP("master: ");
-+	DUMP_TUPLE(&master->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-+	DUMP_TUPLE(&master->tuplehash[IP_CT_DIR_REPLY].tuple);
-+	DEBUGP("conntrack: ");
-+	DUMP_TUPLE(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-+	if (exp_info->dir == IP_CT_DIR_ORIGINAL) {
-+		/* Make connection go to the client. */
-+		newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+		newsrcip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
-+		DEBUGP("h225_nat_expected: %u.%u.%u.%u->%u.%u.%u.%u (to client)\n",
-+		       NIPQUAD(newsrcip), NIPQUAD(newdstip));
-+	} else {
-+		/* Make the connection go to the server */
-+		newdstip = master->tuplehash[IP_CT_DIR_REPLY].tuple.src.ip;
-+		newsrcip = master->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+		DEBUGP("h225_nat_expected: %u.%u.%u.%u->%u.%u.%u.%u (to server)\n",
-+		       NIPQUAD(newsrcip), NIPQUAD(newdstip));
-+	}
-+	port = exp_info->port;
-+	is_h225 = master_info->is_h225 == H225_PORT;
-+	UNLOCK_BH(&ip_h323_lock);
-+	
-+	if (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC)
-+		newip = newsrcip;
-+	else
-+		newip = newdstip;
-+
-+	DEBUGP("h225_nat_expected: IP to %u.%u.%u.%u\n", NIPQUAD(newip));
-+
-+	mr.rangesize = 1;
-+	/* We don't want to manip the per-protocol, just the IPs... */
-+	mr.range[0].flags = IP_NAT_RANGE_MAP_IPS;
-+	mr.range[0].min_ip = mr.range[0].max_ip = newip;
-+
-+	/* ... unless we're doing a MANIP_DST, in which case, make
-+	   sure we map to the correct port */
-+	if (HOOK2MANIP(hooknum) == IP_NAT_MANIP_DST) {
-+		mr.range[0].flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
-+		mr.range[0].min = mr.range[0].max
-+			= ((union ip_conntrack_manip_proto)
-+				{ port });
-+	}
-+
-+	ret = ip_nat_setup_info(ct, &mr, hooknum);
-+	
-+	if (is_h225) {
-+		DEBUGP("h225_nat_expected: H.225, setting NAT helper for %p\n", ct);
-+		/* NAT expectfn called with ip_nat_lock write-locked */
-+		info->helper = &h245;
-+	}
-+	return ret;
-+}
-+
-+static int h323_signal_address_fixup(struct ip_conntrack *ct,
-+			      	     struct sk_buff **pskb,
-+			      	     enum ip_conntrack_info ctinfo)
-+{
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *)iph + iph->ihl*4;
-+	unsigned char *data;
-+	u_int32_t tcplen = (*pskb)->len - iph->ihl*4;
-+	u_int32_t datalen = tcplen - tcph->doff*4;
-+	struct ip_ct_h225_master *info = &ct->help.ct_h225_info; 
-+	u_int32_t newip;
-+	u_int16_t port;
-+	u_int8_t buffer[6];
-+	int i;
-+
-+	MUST_BE_LOCKED(&ip_h323_lock);
-+
-+	DEBUGP("h323_signal_address_fixup: %s %s\n",
-+		between(info->seq[IP_CT_DIR_ORIGINAL], ntohl(tcph->seq), ntohl(tcph->seq) + datalen)
-+			? "yes" : "no",
-+		between(info->seq[IP_CT_DIR_REPLY], ntohl(tcph->seq), ntohl(tcph->seq) + datalen)
-+			? "yes" : "no");
-+	if (!(between(info->seq[IP_CT_DIR_ORIGINAL], ntohl(tcph->seq), ntohl(tcph->seq) + datalen)
-+	      || between(info->seq[IP_CT_DIR_REPLY], ntohl(tcph->seq), ntohl(tcph->seq) + datalen)))
-+		return 1;
-+
-+	DEBUGP("h323_signal_address_fixup: offsets %u + 6  and %u + 6 in %u\n", 
-+		info->offset[IP_CT_DIR_ORIGINAL], 
-+		info->offset[IP_CT_DIR_REPLY],
-+		tcplen);
-+	DUMP_TUPLE(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-+	DUMP_TUPLE(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);
-+
-+	for (i = 0; i < IP_CT_DIR_MAX; i++) {
-+		DEBUGP("h323_signal_address_fixup: %s %s\n",
-+			info->dir == IP_CT_DIR_ORIGINAL ? "original" : "reply",
-+			i == IP_CT_DIR_ORIGINAL ? "caller" : "callee");
-+		if (!between(info->seq[i], ntohl(tcph->seq), 
-+			     ntohl(tcph->seq) + datalen))
-+			continue;
-+		if (!between(info->seq[i] + 6, ntohl(tcph->seq),
-+			     ntohl(tcph->seq) + datalen)) {
-+			/* Partial retransmisison. It's a cracker being funky. */
-+			if (net_ratelimit()) {
-+				printk("H.323_NAT: partial packet %u/6 in %u/%u\n",
-+				     info->seq[i],
-+				     ntohl(tcph->seq),
-+				     ntohl(tcph->seq) + datalen);
-+			}
-+			return 0;
-+		}
-+
-+		/* Change address inside packet to match way we're mapping
-+		   this connection. */
-+		if (i == IP_CT_DIR_ORIGINAL) {
-+			newip = ct->tuplehash[!info->dir].tuple.dst.ip;
-+			port = ct->tuplehash[!info->dir].tuple.dst.u.tcp.port;
-+		} else {
-+			newip = ct->tuplehash[!info->dir].tuple.src.ip;
-+			port = ct->tuplehash[!info->dir].tuple.src.u.tcp.port;
-+		}
-+
-+		data = (char *) tcph + tcph->doff * 4 + info->offset[i];
-+
-+		DEBUGP("h323_signal_address_fixup: orig %s IP:port %u.%u.%u.%u:%u\n", 
-+			i == IP_CT_DIR_ORIGINAL ? "source" : "dest  ", 
-+		        data[0], data[1], data[2], data[3],
-+		        (data[4] << 8 | data[5]));
-+
-+		/* Modify the packet */
-+		memcpy(buffer, &newip, 4);
-+		memcpy(buffer + 4, &port, 2);
-+		if (!ip_nat_mangle_tcp_packet(pskb, ct, ctinfo, info->offset[i],
-+					      6, buffer, 6))
-+			return 0;
-+
-+		DEBUGP("h323_signal_address_fixup:  new %s IP:port %u.%u.%u.%u:%u\n", 
-+			i == IP_CT_DIR_ORIGINAL ? "source" : "dest  ", 
-+		        data[0], data[1], data[2], data[3],
-+		        (data[4] << 8 | data[5]));
-+	}
-+
-+	return 1;
-+}
-+
-+static int h323_data_fixup(struct ip_ct_h225_expect *info,
-+			   struct ip_conntrack *ct,
-+			   struct sk_buff **pskb,
-+			   enum ip_conntrack_info ctinfo,
-+			   struct ip_conntrack_expect *expect)
-+{
-+	u_int32_t newip;
-+	u_int16_t port;
-+	u_int8_t buffer[6];
-+	struct ip_conntrack_tuple newtuple;
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *)iph + iph->ihl*4;
-+	unsigned char *data;
-+	u_int32_t tcplen = (*pskb)->len - iph->ihl*4;
-+	struct ip_ct_h225_master *master_info = &ct->help.ct_h225_info;
-+	int is_h225;
-+
-+	MUST_BE_LOCKED(&ip_h323_lock);
-+	DEBUGP("h323_data_fixup: offset %u + 6 in %u\n", info->offset, tcplen);
-+	DUMP_TUPLE(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-+	DUMP_TUPLE(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);
-+
-+	if (!between(expect->seq + 6, ntohl(tcph->seq),
-+		    ntohl(tcph->seq) + tcplen - tcph->doff * 4)) {
-+		/* Partial retransmisison. It's a cracker being funky. */
-+		if (net_ratelimit()) {
-+			printk("H.323_NAT: partial packet %u/6 in %u/%u\n",
-+			     expect->seq,
-+			     ntohl(tcph->seq),
-+			     ntohl(tcph->seq) + tcplen - tcph->doff * 4);
-+		}
-+		return 0;
-+	}
-+
-+	/* Change address inside packet to match way we're mapping
-+	   this connection. */
-+	if (info->dir == IP_CT_DIR_REPLY) {
-+		/* Must be where client thinks server is */
-+		newip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
-+		/* Expect something from client->server */
-+		newtuple.src.ip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+		newtuple.dst.ip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
-+	} else {
-+		/* Must be where server thinks client is */
-+		newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+		/* Expect something from server->client */
-+		newtuple.src.ip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.ip;
-+		newtuple.dst.ip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+	}
-+
-+	is_h225 = (master_info->is_h225 == H225_PORT);
-+
-+	if (is_h225) {
-+		newtuple.dst.protonum = IPPROTO_TCP;
-+		newtuple.src.u.tcp.port = expect->tuple.src.u.tcp.port;
-+	} else {
-+		newtuple.dst.protonum = IPPROTO_UDP;
-+		newtuple.src.u.udp.port = expect->tuple.src.u.udp.port;
-+	}
-+	
-+	/* Try to get same port: if not, try to change it. */
-+	for (port = ntohs(info->port); port != 0; port++) {
-+		if (is_h225)
-+			newtuple.dst.u.tcp.port = htons(port);
-+		else
-+			newtuple.dst.u.udp.port = htons(port);
-+
-+		if (ip_conntrack_change_expect(expect, &newtuple) == 0)
-+			break;
-+	}
-+	if (port == 0) {
-+		DEBUGP("h323_data_fixup: no free port found!\n");
-+		return 0;
-+	}
-+
-+	port = htons(port);
-+
-+	data = (char *) tcph + tcph->doff * 4 + info->offset;
-+
-+	DEBUGP("h323_data_fixup: orig IP:port %u.%u.%u.%u:%u\n", 
-+	        data[0], data[1], data[2], data[3],
-+	        (data[4] << 8 | data[5]));
-+
-+	/* Modify the packet */
-+	memcpy(buffer, &newip, 4);
-+	memcpy(buffer + 4, &port, 2);
-+	if (!ip_nat_mangle_tcp_packet(pskb, ct, ctinfo, info->offset,
-+				      6, buffer, 6))
-+		return 0;
-+	
-+	DEBUGP("h323_data_fixup: new IP:port %u.%u.%u.%u:%u\n", 
-+	        data[0], data[1], data[2], data[3],
-+	        (data[4] << 8 | data[5]));
-+
-+	return 1;
-+}
-+
-+static unsigned int h225_nat_help(struct ip_conntrack *ct,
-+				  struct ip_conntrack_expect *exp,
-+			 	  struct ip_nat_info *info,
-+			 	  enum ip_conntrack_info ctinfo,
-+			 	  unsigned int hooknum,
-+			 	  struct sk_buff **pskb)
-+{
-+	int dir;
-+	struct ip_ct_h225_expect *exp_info;
-+	
-+	/* Only mangle things once: original direction in POST_ROUTING
-+	   and reply direction on PRE_ROUTING. */
-+	dir = CTINFO2DIR(ctinfo);
-+	DEBUGP("nat_h323: dir %s at hook %s\n",
-+	       dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
-+	       hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+	       : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+	       : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???");
-+	if (!((hooknum == NF_IP_POST_ROUTING && dir == IP_CT_DIR_ORIGINAL)
-+	      || (hooknum == NF_IP_PRE_ROUTING && dir == IP_CT_DIR_REPLY))) {
-+		DEBUGP("nat_h323: Not touching dir %s at hook %s\n",
-+		       dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
-+		       hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+		       : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+		       : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???");
-+		return NF_ACCEPT;
-+	}
-+
-+	if (!exp) {
-+		LOCK_BH(&ip_h323_lock);
-+		if (!h323_signal_address_fixup(ct, pskb, ctinfo)) {
-+			UNLOCK_BH(&ip_h323_lock);
-+			return NF_DROP;
-+		}
-+		UNLOCK_BH(&ip_h323_lock);
-+		return NF_ACCEPT;
-+	}
-+		
-+	exp_info = &exp->help.exp_h225_info;
-+
-+	LOCK_BH(&ip_h323_lock);
-+	if (!h323_data_fixup(exp_info, ct, pskb, ctinfo, exp)) {
-+		UNLOCK_BH(&ip_h323_lock);
-+		return NF_DROP;
-+	}
-+	UNLOCK_BH(&ip_h323_lock);
-+
-+	return NF_ACCEPT;
-+}
-+
-+static struct ip_nat_helper h225 = 
-+	{ { NULL, NULL },
-+	  "H.225",					/* name */
-+	  IP_NAT_HELPER_F_ALWAYS, 			/* flags */
-+	  THIS_MODULE,					/* module */
-+	  { { 0, { __constant_htons(H225_PORT) } },	/* tuple */
-+	    { 0, { 0 }, IPPROTO_TCP } },
-+	  { { 0, { 0xFFFF } },				/* mask */
-+	    { 0, { 0 }, 0xFFFF } },
-+	  h225_nat_help,				/* helper */
-+	  h225_nat_expected				/* expectfn */
-+	};
-+
-+static int __init init(void)
-+{
-+	int ret;
-+	
-+	ret = ip_nat_helper_register(&h225);
-+
-+	if (ret != 0)
-+		printk("ip_nat_h323: cannot initialize the module!\n");
-+
-+	return ret;
-+}
-+
-+static void __exit fini(void)
-+{
-+	ip_nat_helper_unregister(&h225);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/netfilter_ipv4/ip_conntrack.h
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-@@ -71,6 +71,7 @@ union ip_conntrack_expect_proto {
- #include <linux/netfilter_ipv4/ip_conntrack_ftp.h>
- #include <linux/netfilter_ipv4/ip_conntrack_irc.h>
- #include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_h323.h>
- 
- /* per expectation: application helper private data */
- union ip_conntrack_expect_help {
-@@ -79,6 +80,7 @@ union ip_conntrack_expect_help {
- 	struct ip_ct_ftp_expect exp_ftp_info;
- 	struct ip_ct_irc_expect exp_irc_info;
- 	struct ip_ct_pptp_expect exp_pptp_info;
-+	struct ip_ct_h225_expect exp_h225_info;
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
- 	union {
-@@ -93,6 +95,7 @@ union ip_conntrack_help {
- 	struct ip_ct_ftp_master ct_ftp_info;
- 	struct ip_ct_irc_master ct_irc_info;
- 	struct ip_ct_pptp_master ct_pptp_info;
-+	struct ip_ct_h225_master ct_h225_info;
- };
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_h323.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_h323.h
-@@ -0,0 +1,30 @@
-+#ifndef _IP_CONNTRACK_H323_H
-+#define _IP_CONNTRACK_H323_H
-+/* H.323 connection tracking. */
-+
-+#ifdef __KERNEL__
-+/* Protects H.323 related data */
-+DECLARE_LOCK_EXTERN(ip_h323_lock);
-+#endif
-+
-+/* Default H.225 port */
-+#define H225_PORT	1720
-+
-+/* This structure is per expected connection */
-+struct ip_ct_h225_expect {
-+	u_int16_t port;			/* Port of the H.225 helper/RTCP/RTP channel */
-+	enum ip_conntrack_dir dir;	/* Direction of the original connection */
-+	unsigned int offset;		/* offset of the address in the payload */
-+};
-+
-+/* This structure exists only once per master */
-+struct ip_ct_h225_master {
-+	int is_h225;				/* H.225 or H.245 connection */
-+#ifdef CONFIG_IP_NF_NAT_NEEDED
-+	enum ip_conntrack_dir dir;		/* Direction of the original connection */
-+	u_int32_t seq[IP_CT_DIR_MAX];		/* Exceptional packet mangling for signal addressess... */
-+	unsigned int offset[IP_CT_DIR_MAX];	/* ...and the offset of the addresses in the payload */
-+#endif
-+};
-+
-+#endif /* _IP_CONNTRACK_H323_H */
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/614-netfilter_nat_rtsp.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,1534 +0,0 @@
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -16,6 +16,7 @@ if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ];
-   dep_tristate '  GRE protocol support' CONFIG_IP_NF_CT_PROTO_GRE $CONFIG_IP_NF_CONNTRACK
-   dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
-   dep_tristate '  H.323 (netmeeting) support' CONFIG_IP_NF_H323 $CONFIG_IP_NF_CONNTRACK
-+  dep_tristate '  RTSP protocol support' CONFIG_IP_NF_RTSP $CONFIG_IP_NF_CONNTRACK
- fi
- 
- if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-@@ -118,6 +119,13 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-          define_tristate CONFIG_IP_NF_NAT_H323 $CONFIG_IP_NF_NAT
-        fi
-       fi
-+      if [ "$CONFIG_IP_NF_RTSP" = "m" ]; then
-+        define_tristate CONFIG_IP_NF_NAT_RTSP m
-+      else
-+       if [ "$CONFIG_IP_NF_RTSP" = "y" ]; then
-+         define_tristate CONFIG_IP_NF_NAT_RTSP $CONFIG_IP_NF_NAT
-+       fi
-+      fi
-       if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-         dep_tristate '    Basic SNMP-ALG support (EXPERIMENTAL)' CONFIG_IP_NF_NAT_SNMP_BASIC $CONFIG_IP_NF_NAT
-       fi
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -57,6 +57,11 @@ obj-$(CONFIG_IP_NF_H323) += ip_conntrack
- ifdef CONFIG_IP_NF_NAT_H323
-        export-objs += ip_conntrack_h323.o
- endif
-+obj-$(CONFIG_IP_NF_RTSP) += ip_conntrack_rtsp.o
-+ifdef CONFIG_IP_NF_NAT_RTSP
-+       export-objs += ip_conntrack_rtsp.o
-+endif
-+
- 
- 
- # NAT helpers 
-@@ -67,6 +72,7 @@ obj-$(CONFIG_IP_NF_NAT_IRC) += ip_nat_ir
- obj-$(CONFIG_IP_NF_NAT_PROTO_GRE) += ip_nat_proto_gre.o
- obj-$(CONFIG_IP_NF_NAT_PPTP) += ip_nat_pptp.o
- obj-$(CONFIG_IP_NF_NAT_H323) += ip_nat_h323.o
-+obj-$(CONFIG_IP_NF_NAT_RTSP) += ip_nat_rtsp.o
- 
- # generic IP tables 
- obj-$(CONFIG_IP_NF_IPTABLES) += ip_tables.o
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_rtsp.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_rtsp.c
-@@ -0,0 +1,507 @@
-+/*
-+ * RTSP extension for IP connection tracking
-+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
-+ * based on ip_conntrack_irc.c
-+ *
-+ *      This program is free software; you can redistribute it and/or
-+ *      modify it under the terms of the GNU General Public License
-+ *      as published by the Free Software Foundation; either version
-+ *      2 of the License, or (at your option) any later version.
-+ *
-+ * Module load syntax:
-+ *   insmod ip_conntrack_rtsp.o ports=port1,port2,...port<MAX_PORTS>
-+ *                              max_outstanding=n setup_timeout=secs
-+ *
-+ * If no ports are specified, the default will be port 554.
-+ *
-+ * With max_outstanding you can define the maximum number of not yet
-+ * answered SETUP requests per RTSP session (default 8).
-+ * With setup_timeout you can specify how long the system waits for
-+ * an expected data channel (default 300 seconds).
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/netfilter.h>
-+#include <linux/ip.h>
-+#include <net/checksum.h>
-+#include <net/tcp.h>
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_rtsp.h>
-+
-+#include <linux/ctype.h>
-+#define NF_NEED_STRNCASECMP
-+#define NF_NEED_STRTOU16
-+#define NF_NEED_STRTOU32
-+#define NF_NEED_NEXTLINE
-+#include <linux/netfilter_helpers.h>
-+#define NF_NEED_MIME_NEXTLINE
-+#include <linux/netfilter_mime.h>
-+
-+#define MAX_SIMUL_SETUP 8 /* XXX: use max_outstanding */
-+
-+#define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
-+#ifdef IP_NF_RTSP_DEBUG
-+#define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
-+#else
-+#define DEBUGP(fmt, args...)
-+#endif
-+
-+#define MAX_PORTS 8
-+static int ports[MAX_PORTS];
-+static int num_ports = 0;
-+static int max_outstanding = 8;
-+static unsigned int setup_timeout = 300;
-+
-+MODULE_AUTHOR("Tom Marshall <tmarshall@real.com>");
-+MODULE_DESCRIPTION("RTSP connection tracking module");
-+MODULE_LICENSE("GPL");
-+#ifdef MODULE_PARM
-+MODULE_PARM(ports, "1-" __MODULE_STRING(MAX_PORTS) "i");
-+MODULE_PARM_DESC(ports, "port numbers of RTSP servers");
-+MODULE_PARM(max_outstanding, "i");
-+MODULE_PARM_DESC(max_outstanding, "max number of outstanding SETUP requests per RTSP session");
-+MODULE_PARM(setup_timeout, "i");
-+MODULE_PARM_DESC(setup_timeout, "timeout on for unestablished data channels");
-+#endif
-+
-+DECLARE_LOCK(ip_rtsp_lock);
-+struct module* ip_conntrack_rtsp = THIS_MODULE;
-+
-+/*
-+ * Max mappings we will allow for one RTSP connection (for RTP, the number
-+ * of allocated ports is twice this value).  Note that SMIL burns a lot of
-+ * ports so keep this reasonably high.  If this is too low, you will see a
-+ * lot of "no free client map entries" messages.
-+ */
-+#define MAX_PORT_MAPS 16
-+
-+/*** default port list was here in the masq code: 554, 3030, 4040 ***/
-+
-+#define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
-+
-+/*
-+ * Parse an RTSP packet.
-+ *
-+ * Returns zero if parsing failed.
-+ *
-+ * Parameters:
-+ *  IN      ptcp        tcp data pointer
-+ *  IN      tcplen      tcp data len
-+ *  IN/OUT  ptcpoff     points to current tcp offset
-+ *  OUT     phdrsoff    set to offset of rtsp headers
-+ *  OUT     phdrslen    set to length of rtsp headers
-+ *  OUT     pcseqoff    set to offset of CSeq header
-+ *  OUT     pcseqlen    set to length of CSeq header
-+ */
-+static int
-+rtsp_parse_message(char* ptcp, uint tcplen, uint* ptcpoff,
-+                   uint* phdrsoff, uint* phdrslen,
-+                   uint* pcseqoff, uint* pcseqlen)
-+{
-+    uint    entitylen = 0;
-+    uint    lineoff;
-+    uint    linelen;
-+
-+    if (!nf_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen))
-+    {
-+        return 0;
-+    }
-+
-+    *phdrsoff = *ptcpoff;
-+    while (nf_mime_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen))
-+    {
-+        if (linelen == 0)
-+        {
-+            if (entitylen > 0)
-+            {
-+                *ptcpoff += min(entitylen, tcplen - *ptcpoff);
-+            }
-+            break;
-+        }
-+        if (lineoff+linelen > tcplen)
-+        {
-+            INFOP("!! overrun !!\n");
-+            break;
-+        }
-+
-+        if (nf_strncasecmp(ptcp+lineoff, "CSeq:", 5) == 0)
-+        {
-+            *pcseqoff = lineoff;
-+            *pcseqlen = linelen;
-+        }
-+        if (nf_strncasecmp(ptcp+lineoff, "Content-Length:", 15) == 0)
-+        {
-+            uint off = lineoff+15;
-+            SKIP_WSPACE(ptcp+lineoff, linelen, off);
-+            nf_strtou32(ptcp+off, &entitylen);
-+        }
-+    }
-+    *phdrslen = (*ptcpoff) - (*phdrsoff);
-+
-+    return 1;
-+}
-+
-+/*
-+ * Find lo/hi client ports (if any) in transport header
-+ * In:
-+ *   ptcp, tcplen = packet
-+ *   tranoff, tranlen = buffer to search
-+ *
-+ * Out:
-+ *   pport_lo, pport_hi = lo/hi ports (host endian)
-+ *
-+ * Returns nonzero if any client ports found
-+ *
-+ * Note: it is valid (and expected) for the client to request multiple
-+ * transports, so we need to parse the entire line.
-+ */
-+static int
-+rtsp_parse_transport(char* ptran, uint tranlen,
-+                     struct ip_ct_rtsp_expect* prtspexp)
-+{
-+    int     rc = 0;
-+    uint    off = 0;
-+
-+    if (tranlen < 10 || !iseol(ptran[tranlen-1]) ||
-+        nf_strncasecmp(ptran, "Transport:", 10) != 0)
-+    {
-+        INFOP("sanity check failed\n");
-+        return 0;
-+    }
-+    DEBUGP("tran='%.*s'\n", (int)tranlen, ptran);
-+    off += 10;
-+    SKIP_WSPACE(ptran, tranlen, off);
-+
-+    /* Transport: tran;field;field=val,tran;field;field=val,... */
-+    while (off < tranlen)
-+    {
-+        const char* pparamend;
-+        uint        nextparamoff;
-+
-+        pparamend = memchr(ptran+off, ',', tranlen-off);
-+        pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
-+        nextparamoff = pparamend-ptran;
-+
-+        while (off < nextparamoff)
-+        {
-+            const char* pfieldend;
-+            uint        nextfieldoff;
-+
-+            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
-+            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
-+
-+            if (strncmp(ptran+off, "client_port=", 12) == 0)
-+            {
-+                u_int16_t   port;
-+                uint        numlen;
-+
-+                off += 12;
-+                numlen = nf_strtou16(ptran+off, &port);
-+                off += numlen;
-+                if (prtspexp->loport != 0 && prtspexp->loport != port)
-+                {
-+                    DEBUGP("multiple ports found, port %hu ignored\n", port);
-+                }
-+                else
-+                {
-+                    prtspexp->loport = prtspexp->hiport = port;
-+                    if (ptran[off] == '-')
-+                    {
-+                        off++;
-+                        numlen = nf_strtou16(ptran+off, &port);
-+                        off += numlen;
-+                        prtspexp->pbtype = pb_range;
-+                        prtspexp->hiport = port;
-+
-+                        // If we have a range, assume rtp:
-+                        // loport must be even, hiport must be loport+1
-+                        if ((prtspexp->loport & 0x0001) != 0 ||
-+                            prtspexp->hiport != prtspexp->loport+1)
-+                        {
-+                            DEBUGP("incorrect range: %hu-%hu, correcting\n",
-+                                   prtspexp->loport, prtspexp->hiport);
-+                            prtspexp->loport &= 0xfffe;
-+                            prtspexp->hiport = prtspexp->loport+1;
-+                        }
-+                    }
-+                    else if (ptran[off] == '/')
-+                    {
-+                        off++;
-+                        numlen = nf_strtou16(ptran+off, &port);
-+                        off += numlen;
-+                        prtspexp->pbtype = pb_discon;
-+                        prtspexp->hiport = port;
-+                    }
-+                    rc = 1;
-+                }
-+            }
-+
-+            /*
-+             * Note we don't look for the destination parameter here.
-+             * If we are using NAT, the NAT module will handle it.  If not,
-+             * and the client is sending packets elsewhere, the expectation
-+             * will quietly time out.
-+             */
-+
-+            off = nextfieldoff;
-+        }
-+
-+        off = nextparamoff;
-+    }
-+
-+    return rc;
-+}
-+
-+/*** conntrack functions ***/
-+
-+/* outbound packet: client->server */
-+static int
-+help_out(const struct iphdr* iph, size_t pktlen,
-+                struct ip_conntrack* ct, enum ip_conntrack_info ctinfo)
-+{
-+    int dir = CTINFO2DIR(ctinfo);   /* = IP_CT_DIR_ORIGINAL */
-+    struct  tcphdr* tcph = (void*)iph + iph->ihl * 4;
-+    uint    tcplen = pktlen - iph->ihl * 4;
-+    char*   pdata = (char*)tcph + tcph->doff * 4;
-+    uint    datalen = tcplen - tcph->doff * 4;
-+    uint    dataoff = 0;
-+
-+    struct ip_conntrack_expect exp;
-+
-+    while (dataoff < datalen)
-+    {
-+        uint    cmdoff = dataoff;
-+        uint    hdrsoff = 0;
-+        uint    hdrslen = 0;
-+        uint    cseqoff = 0;
-+        uint    cseqlen = 0;
-+        uint    lineoff = 0;
-+        uint    linelen = 0;
-+        uint    off;
-+        int     rc;
-+
-+        if (!rtsp_parse_message(pdata, datalen, &dataoff,
-+                                &hdrsoff, &hdrslen,
-+                                &cseqoff, &cseqlen))
-+        {
-+            break;      /* not a valid message */
-+        }
-+
-+        if (strncmp(pdata+cmdoff, "SETUP ", 6) != 0)
-+        {
-+            continue;   /* not a SETUP message */
-+        }
-+        DEBUGP("found a setup message\n");
-+
-+        memset(&exp, 0, sizeof(exp));
-+
-+        off = 0;
-+        while (nf_mime_nextline(pdata+hdrsoff, hdrslen, &off,
-+                                &lineoff, &linelen))
-+        {
-+            if (linelen == 0)
-+            {
-+                break;
-+            }
-+            if (off > hdrsoff+hdrslen)
-+            {
-+                INFOP("!! overrun !!");
-+                break;
-+            }
-+
-+            if (nf_strncasecmp(pdata+hdrsoff+lineoff, "Transport:", 10) == 0)
-+            {
-+                rtsp_parse_transport(pdata+hdrsoff+lineoff, linelen,
-+                                     &exp.help.exp_rtsp_info);
-+            }
-+        }
-+
-+        if (exp.help.exp_rtsp_info.loport == 0)
-+        {
-+            DEBUGP("no udp transports found\n");
-+            continue;   /* no udp transports found */
-+        }
-+
-+        DEBUGP("udp transport found, ports=(%d,%hu,%hu)\n",
-+              (int)exp.help.exp_rtsp_info.pbtype,
-+              exp.help.exp_rtsp_info.loport,
-+              exp.help.exp_rtsp_info.hiport);
-+
-+        LOCK_BH(&ip_rtsp_lock);
-+        exp.seq = ntohl(tcph->seq) + hdrsoff; /* mark all the headers */
-+        exp.help.exp_rtsp_info.len = hdrslen;
-+
-+        exp.tuple.src.ip = ct->tuplehash[!dir].tuple.src.ip;
-+        exp.mask.src.ip  = 0xffffffff;
-+        exp.tuple.dst.ip = ct->tuplehash[dir].tuple.src.ip;
-+        exp.mask.dst.ip  = 0xffffffff;
-+        exp.tuple.dst.u.udp.port = exp.help.exp_rtsp_info.loport;
-+        exp.mask.dst.u.udp.port  = (exp.help.exp_rtsp_info.pbtype == pb_range) ? 0xfffe : 0xffff;
-+        exp.tuple.dst.protonum = IPPROTO_UDP;
-+        exp.mask.dst.protonum  = 0xffff;
-+
-+        DEBUGP("expect_related %u.%u.%u.%u:%u-%u.%u.%u.%u:%u\n",
-+                NIPQUAD(exp.tuple.src.ip),
-+                ntohs(exp.tuple.src.u.tcp.port),
-+                NIPQUAD(exp.tuple.dst.ip),
-+                ntohs(exp.tuple.dst.u.tcp.port));
-+
-+        /* pass the request off to the nat helper */
-+        rc = ip_conntrack_expect_related(ct, &exp);
-+        UNLOCK_BH(&ip_rtsp_lock);
-+        if (rc == 0)
-+        {
-+            DEBUGP("ip_conntrack_expect_related succeeded\n");
-+        }
-+        else
-+        {
-+            INFOP("ip_conntrack_expect_related failed (%d)\n", rc);
-+        }
-+    }
-+
-+    return NF_ACCEPT;
-+}
-+
-+/* inbound packet: server->client */
-+static int
-+help_in(const struct iphdr* iph, size_t pktlen,
-+                struct ip_conntrack* ct, enum ip_conntrack_info ctinfo)
-+{
-+    return NF_ACCEPT;
-+}
-+
-+static int
-+help(const struct iphdr* iph, size_t pktlen,
-+                struct ip_conntrack* ct, enum ip_conntrack_info ctinfo)
-+{
-+    /* tcplen not negative guarenteed by ip_conntrack_tcp.c */
-+    struct tcphdr* tcph = (void*)iph + iph->ihl * 4;
-+    u_int32_t tcplen = pktlen - iph->ihl * 4;
-+
-+    /* Until there's been traffic both ways, don't look in packets. */
-+    if (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY)
-+    {
-+        DEBUGP("conntrackinfo = %u\n", ctinfo);
-+        return NF_ACCEPT;
-+    }
-+
-+    /* Not whole TCP header? */
-+    if (tcplen < sizeof(struct tcphdr) || tcplen < tcph->doff * 4)
-+    {
-+        DEBUGP("tcplen = %u\n", (unsigned)tcplen);
-+        return NF_ACCEPT;
-+    }
-+
-+    /* Checksum invalid?  Ignore. */
-+    /* FIXME: Source route IP option packets --RR */
-+    if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
-+                     csum_partial((char*)tcph, tcplen, 0)))
-+    {
-+        DEBUGP("bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
-+               tcph, tcplen, NIPQUAD(iph->saddr), NIPQUAD(iph->daddr));
-+        return NF_ACCEPT;
-+    }
-+
-+    switch (CTINFO2DIR(ctinfo))
-+    {
-+    case IP_CT_DIR_ORIGINAL:
-+        help_out(iph, pktlen, ct, ctinfo);
-+        break;
-+    case IP_CT_DIR_REPLY:
-+        help_in(iph, pktlen, ct, ctinfo);
-+        break;
-+    }
-+
-+    return NF_ACCEPT;
-+}
-+
-+static struct ip_conntrack_helper rtsp_helpers[MAX_PORTS];
-+static char rtsp_names[MAX_PORTS][10];
-+
-+/* This function is intentionally _NOT_ defined as __exit */
-+static void
-+fini(void)
-+{
-+    int i;
-+    for (i = 0; i < num_ports; i++)
-+    {
-+        DEBUGP("unregistering port %d\n", ports[i]);
-+        ip_conntrack_helper_unregister(&rtsp_helpers[i]);
-+    }
-+}
-+
-+static int __init
-+init(void)
-+{
-+    int i, ret;
-+    struct ip_conntrack_helper *hlpr;
-+    char *tmpname;
-+
-+    printk("ip_conntrack_rtsp v" IP_NF_RTSP_VERSION " loading\n");
-+
-+    if (max_outstanding < 1)
-+    {
-+        printk("ip_conntrack_rtsp: max_outstanding must be a positive integer\n");
-+        return -EBUSY;
-+    }
-+    if (setup_timeout < 0)
-+    {
-+        printk("ip_conntrack_rtsp: setup_timeout must be a positive integer\n");
-+        return -EBUSY;
-+    }
-+
-+    /* If no port given, default to standard rtsp port */
-+    if (ports[0] == 0)
-+    {
-+        ports[0] = RTSP_PORT;
-+    }
-+
-+    for (i = 0; (i < MAX_PORTS) && ports[i]; i++)
-+    {
-+        hlpr = &rtsp_helpers[i];
-+        memset(hlpr, 0, sizeof(struct ip_conntrack_helper));
-+        hlpr->tuple.src.u.tcp.port = htons(ports[i]);
-+        hlpr->tuple.dst.protonum = IPPROTO_TCP;
-+        hlpr->mask.src.u.tcp.port = 0xFFFF;
-+        hlpr->mask.dst.protonum = 0xFFFF;
-+        hlpr->max_expected = max_outstanding;
-+        hlpr->timeout = setup_timeout;
-+        hlpr->flags = IP_CT_HELPER_F_REUSE_EXPECT;
-+        hlpr->me = ip_conntrack_rtsp;
-+        hlpr->help = help;
-+
-+        tmpname = &rtsp_names[i][0];
-+        if (ports[i] == RTSP_PORT)
-+        {
-+            sprintf(tmpname, "rtsp");
-+        }
-+        else
-+        {
-+            sprintf(tmpname, "rtsp-%d", i);
-+        }
-+        hlpr->name = tmpname;
-+
-+        DEBUGP("port #%d: %d\n", i, ports[i]);
-+
-+        ret = ip_conntrack_helper_register(hlpr);
-+
-+        if (ret)
-+        {
-+            printk("ip_conntrack_rtsp: ERROR registering port %d\n", ports[i]);
-+            fini();
-+            return -EBUSY;
-+        }
-+        num_ports++;
-+    }
-+    return 0;
-+}
-+
-+#ifdef CONFIG_IP_NF_NAT_NEEDED
-+EXPORT_SYMBOL(ip_rtsp_lock);
-+#endif
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_nat_rtsp.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_nat_rtsp.c
-@@ -0,0 +1,621 @@
-+/*
-+ * RTSP extension for TCP NAT alteration
-+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
-+ * based on ip_nat_irc.c
-+ *
-+ *      This program is free software; you can redistribute it and/or
-+ *      modify it under the terms of the GNU General Public License
-+ *      as published by the Free Software Foundation; either version
-+ *      2 of the License, or (at your option) any later version.
-+ *
-+ * Module load syntax:
-+ *      insmod ip_nat_rtsp.o ports=port1,port2,...port<MAX_PORTS>
-+ *                           stunaddr=<address>
-+ *                           destaction=[auto|strip|none]
-+ *
-+ * If no ports are specified, the default will be port 554 only.
-+ *
-+ * stunaddr specifies the address used to detect that a client is using STUN.
-+ * If this address is seen in the destination parameter, it is assumed that
-+ * the client has already punched a UDP hole in the firewall, so we don't
-+ * mangle the client_port.  If none is specified, it is autodetected.  It
-+ * only needs to be set if you have multiple levels of NAT.  It should be
-+ * set to the external address that the STUN clients detect.  Note that in
-+ * this case, it will not be possible for clients to use UDP with servers
-+ * between the NATs.
-+ *
-+ * If no destaction is specified, auto is used.
-+ *   destaction=auto:  strip destination parameter if it is not stunaddr.
-+ *   destaction=strip: always strip destination parameter (not recommended).
-+ *   destaction=none:  do not touch destination parameter (not recommended).
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/netfilter_ipv4.h>
-+#include <linux/ip.h>
-+#include <linux/tcp.h>
-+#include <linux/kernel.h>
-+#include <net/tcp.h>
-+#include <linux/netfilter_ipv4/ip_nat.h>
-+#include <linux/netfilter_ipv4/ip_nat_helper.h>
-+#include <linux/netfilter_ipv4/ip_nat_rule.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_rtsp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+
-+#include <linux/inet.h>
-+#include <linux/ctype.h>
-+#define NF_NEED_STRNCASECMP
-+#define NF_NEED_STRTOU16
-+#include <linux/netfilter_helpers.h>
-+#define NF_NEED_MIME_NEXTLINE
-+#include <linux/netfilter_mime.h>
-+
-+#define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
-+#ifdef IP_NF_RTSP_DEBUG
-+#define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
-+#else
-+#define DEBUGP(fmt, args...)
-+#endif
-+
-+#define MAX_PORTS       8
-+#define DSTACT_AUTO     0
-+#define DSTACT_STRIP    1
-+#define DSTACT_NONE     2
-+
-+static int      ports[MAX_PORTS];
-+static char*    stunaddr = NULL;
-+static char*    destaction = NULL;
-+
-+static int       num_ports = 0;
-+static u_int32_t extip = 0;
-+static int       dstact = 0;
-+
-+MODULE_AUTHOR("Tom Marshall <tmarshall@real.com>");
-+MODULE_DESCRIPTION("RTSP network address translation module");
-+MODULE_LICENSE("GPL");
-+#ifdef MODULE_PARM
-+MODULE_PARM(ports, "1-" __MODULE_STRING(MAX_PORTS) "i");
-+MODULE_PARM_DESC(ports, "port numbers of RTSP servers");
-+MODULE_PARM(stunaddr, "s");
-+MODULE_PARM_DESC(stunaddr, "Address for detecting STUN");
-+MODULE_PARM(destaction, "s");
-+MODULE_PARM_DESC(destaction, "Action for destination parameter (auto/strip/none)");
-+#endif
-+
-+/* protects rtsp part of conntracks */
-+DECLARE_LOCK_EXTERN(ip_rtsp_lock);
-+
-+#define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
-+
-+/*** helper functions ***/
-+
-+static void
-+get_skb_tcpdata(struct sk_buff* skb, char** pptcpdata, uint* ptcpdatalen)
-+{
-+    struct iphdr*   iph  = (struct iphdr*)skb->nh.iph;
-+    struct tcphdr*  tcph = (struct tcphdr*)((char*)iph + iph->ihl*4);
-+
-+    *pptcpdata = (char*)tcph + tcph->doff*4;
-+    *ptcpdatalen = ((char*)skb->h.raw + skb->len) - *pptcpdata;
-+}
-+
-+/*** nat functions ***/
-+
-+/*
-+ * Mangle the "Transport:" header:
-+ *   - Replace all occurences of "client_port=<spec>"
-+ *   - Handle destination parameter
-+ *
-+ * In:
-+ *   ct, ctinfo = conntrack context
-+ *   pskb       = packet
-+ *   tranoff    = Transport header offset from TCP data
-+ *   tranlen    = Transport header length (incl. CRLF)
-+ *   rport_lo   = replacement low  port (host endian)
-+ *   rport_hi   = replacement high port (host endian)
-+ *
-+ * Returns packet size difference.
-+ *
-+ * Assumes that a complete transport header is present, ending with CR or LF
-+ */
-+static int
-+rtsp_mangle_tran(struct ip_conntrack* ct, enum ip_conntrack_info ctinfo,
-+                 struct ip_conntrack_expect* exp,
-+                 struct sk_buff** pskb, uint tranoff, uint tranlen)
-+{
-+    char*       ptcp;
-+    uint        tcplen;
-+    char*       ptran;
-+    char        rbuf1[16];      /* Replacement buffer (one port) */
-+    uint        rbuf1len;       /* Replacement len (one port) */
-+    char        rbufa[16];      /* Replacement buffer (all ports) */
-+    uint        rbufalen;       /* Replacement len (all ports) */
-+    u_int32_t   newip;
-+    u_int16_t   loport, hiport;
-+    uint        off = 0;
-+    uint        diff;           /* Number of bytes we removed */
-+
-+    struct ip_ct_rtsp_expect* prtspexp = &exp->help.exp_rtsp_info;
-+    struct ip_conntrack_tuple t;
-+
-+    char    szextaddr[15+1];
-+    uint    extaddrlen;
-+    int     is_stun;
-+
-+    get_skb_tcpdata(*pskb, &ptcp, &tcplen);
-+    ptran = ptcp+tranoff;
-+
-+    if (tranoff+tranlen > tcplen || tcplen-tranoff < tranlen ||
-+        tranlen < 10 || !iseol(ptran[tranlen-1]) ||
-+        nf_strncasecmp(ptran, "Transport:", 10) != 0)
-+    {
-+        INFOP("sanity check failed\n");
-+        return 0;
-+    }
-+    off += 10;
-+    SKIP_WSPACE(ptcp+tranoff, tranlen, off);
-+
-+    newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+    t = exp->tuple;
-+    t.dst.ip = newip;
-+
-+    extaddrlen = extip ? sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(extip))
-+                       : sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(newip));
-+    DEBUGP("stunaddr=%s (%s)\n", szextaddr, (extip?"forced":"auto"));
-+
-+    rbuf1len = rbufalen = 0;
-+    switch (prtspexp->pbtype)
-+    {
-+    case pb_single:
-+        for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
-+        {
-+            t.dst.u.udp.port = htons(loport);
-+            if (ip_conntrack_change_expect(exp, &t) == 0)
-+            {
-+                DEBUGP("using port %hu\n", loport);
-+                break;
-+            }
-+        }
-+        if (loport != 0)
-+        {
-+            rbuf1len = sprintf(rbuf1, "%hu", loport);
-+            rbufalen = sprintf(rbufa, "%hu", loport);
-+        }
-+        break;
-+    case pb_range:
-+        for (loport = prtspexp->loport; loport != 0; loport += 2) /* XXX: improper wrap? */
-+        {
-+            t.dst.u.udp.port = htons(loport);
-+            if (ip_conntrack_change_expect(exp, &t) == 0)
-+            {
-+                hiport = loport + ~exp->mask.dst.u.udp.port;
-+                DEBUGP("using ports %hu-%hu\n", loport, hiport);
-+                break;
-+            }
-+        }
-+        if (loport != 0)
-+        {
-+            rbuf1len = sprintf(rbuf1, "%hu", loport);
-+            rbufalen = sprintf(rbufa, "%hu-%hu", loport, loport+1);
-+        }
-+        break;
-+    case pb_discon:
-+        for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
-+        {
-+            t.dst.u.udp.port = htons(loport);
-+            if (ip_conntrack_change_expect(exp, &t) == 0)
-+            {
-+                DEBUGP("using port %hu (1 of 2)\n", loport);
-+                break;
-+            }
-+        }
-+        for (hiport = prtspexp->hiport; hiport != 0; hiport++) /* XXX: improper wrap? */
-+        {
-+            t.dst.u.udp.port = htons(hiport);
-+            if (ip_conntrack_change_expect(exp, &t) == 0)
-+            {
-+                DEBUGP("using port %hu (2 of 2)\n", hiport);
-+                break;
-+            }
-+        }
-+        if (loport != 0 && hiport != 0)
-+        {
-+            rbuf1len = sprintf(rbuf1, "%hu", loport);
-+            if (hiport == loport+1)
-+            {
-+                rbufalen = sprintf(rbufa, "%hu-%hu", loport, hiport);
-+            }
-+            else
-+            {
-+                rbufalen = sprintf(rbufa, "%hu/%hu", loport, hiport);
-+            }
-+        }
-+        break;
-+    }
-+
-+    if (rbuf1len == 0)
-+    {
-+        return 0;   /* cannot get replacement port(s) */
-+    }
-+
-+    /* Transport: tran;field;field=val,tran;field;field=val,... */
-+    while (off < tranlen)
-+    {
-+        uint        saveoff;
-+        const char* pparamend;
-+        uint        nextparamoff;
-+
-+        pparamend = memchr(ptran+off, ',', tranlen-off);
-+        pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
-+        nextparamoff = pparamend-ptcp;
-+
-+        /*
-+         * We pass over each param twice.  On the first pass, we look for a
-+         * destination= field.  It is handled by the security policy.  If it
-+         * is present, allowed, and equal to our external address, we assume
-+         * that STUN is being used and we leave the client_port= field alone.
-+         */
-+        is_stun = 0;
-+        saveoff = off;
-+        while (off < nextparamoff)
-+        {
-+            const char* pfieldend;
-+            uint        nextfieldoff;
-+
-+            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
-+            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
-+
-+            if (dstact != DSTACT_NONE && strncmp(ptran+off, "destination=", 12) == 0)
-+            {
-+                if (strncmp(ptran+off+12, szextaddr, extaddrlen) == 0)
-+                {
-+                    is_stun = 1;
-+                }
-+                if (dstact == DSTACT_STRIP || (dstact == DSTACT_AUTO && !is_stun))
-+                {
-+                    diff = nextfieldoff-off;
-+                    if (!ip_nat_mangle_tcp_packet(pskb, ct, ctinfo,
-+                                                         off, diff, NULL, 0))
-+                    {
-+                        /* mangle failed, all we can do is bail */
-+                        return 0;
-+                    }
-+                    get_skb_tcpdata(*pskb, &ptcp, &tcplen);
-+                    ptran = ptcp+tranoff;
-+                    tranlen -= diff;
-+                    nextparamoff -= diff;
-+                    nextfieldoff -= diff;
-+                }
-+            }
-+
-+            off = nextfieldoff;
-+        }
-+        if (is_stun)
-+        {
-+            continue;
-+        }
-+        off = saveoff;
-+        while (off < nextparamoff)
-+        {
-+            const char* pfieldend;
-+            uint        nextfieldoff;
-+
-+            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
-+            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
-+
-+            if (strncmp(ptran+off, "client_port=", 12) == 0)
-+            {
-+                u_int16_t   port;
-+                uint        numlen;
-+                uint        origoff;
-+                uint        origlen;
-+                char*       rbuf    = rbuf1;
-+                uint        rbuflen = rbuf1len;
-+
-+                off += 12;
-+                origoff = (ptran-ptcp)+off;
-+                origlen = 0;
-+                numlen = nf_strtou16(ptran+off, &port);
-+                off += numlen;
-+                origlen += numlen;
-+                if (port != prtspexp->loport)
-+                {
-+                    DEBUGP("multiple ports found, port %hu ignored\n", port);
-+                }
-+                else
-+                {
-+                    if (ptran[off] == '-' || ptran[off] == '/')
-+                    {
-+                        off++;
-+                        origlen++;
-+                        numlen = nf_strtou16(ptran+off, &port);
-+                        off += numlen;
-+                        origlen += numlen;
-+                        rbuf = rbufa;
-+                        rbuflen = rbufalen;
-+                    }
-+
-+                    /*
-+                     * note we cannot just memcpy() if the sizes are the same.
-+                     * the mangle function does skb resizing, checks for a
-+                     * cloned skb, and updates the checksums.
-+                     *
-+                     * parameter 4 below is offset from start of tcp data.
-+                     */
-+                    diff = origlen-rbuflen;
-+                    if (!ip_nat_mangle_tcp_packet(pskb, ct, ctinfo,
-+                                              origoff, origlen, rbuf, rbuflen))
-+                    {
-+                        /* mangle failed, all we can do is bail */
-+                        return 0;
-+                    }
-+                    get_skb_tcpdata(*pskb, &ptcp, &tcplen);
-+                    ptran = ptcp+tranoff;
-+                    tranlen -= diff;
-+                    nextparamoff -= diff;
-+                    nextfieldoff -= diff;
-+                }
-+            }
-+
-+            off = nextfieldoff;
-+        }
-+
-+        off = nextparamoff;
-+    }
-+
-+    return 1;
-+}
-+
-+static unsigned int
-+expected(struct sk_buff **pskb, uint hooknum, struct ip_conntrack* ct, struct ip_nat_info* info)
-+{
-+    struct ip_nat_multi_range mr;
-+    u_int32_t newdstip, newsrcip, newip;
-+
-+    struct ip_conntrack *master = master_ct(ct);
-+
-+    IP_NF_ASSERT(info);
-+    IP_NF_ASSERT(master);
-+
-+    IP_NF_ASSERT(!(info->initialized & (1 << HOOK2MANIP(hooknum))));
-+
-+    newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+    newsrcip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+    newip = (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) ? newsrcip : newdstip;
-+
-+    DEBUGP("newsrcip=%u.%u.%u.%u, newdstip=%u.%u.%u.%u, newip=%u.%u.%u.%u\n",
-+           NIPQUAD(newsrcip), NIPQUAD(newdstip), NIPQUAD(newip));
-+
-+    mr.rangesize = 1;
-+    /* We don't want to manip the per-protocol, just the IPs. */
-+    mr.range[0].flags = IP_NAT_RANGE_MAP_IPS;
-+    mr.range[0].min_ip = mr.range[0].max_ip = newip;
-+
-+    return ip_nat_setup_info(ct, &mr, hooknum);
-+}
-+
-+static uint
-+help_out(struct ip_conntrack* ct, enum ip_conntrack_info ctinfo,
-+         struct ip_conntrack_expect* exp, struct sk_buff** pskb)
-+{
-+    char*   ptcp;
-+    uint    tcplen;
-+    uint    hdrsoff;
-+    uint    hdrslen;
-+    uint    lineoff;
-+    uint    linelen;
-+    uint    off;
-+
-+    struct iphdr* iph = (struct iphdr*)(*pskb)->nh.iph;
-+    struct tcphdr* tcph = (struct tcphdr*)((void*)iph + iph->ihl*4);
-+
-+    struct ip_ct_rtsp_expect* prtspexp = &exp->help.exp_rtsp_info;
-+
-+    get_skb_tcpdata(*pskb, &ptcp, &tcplen);
-+
-+    hdrsoff = exp->seq - ntohl(tcph->seq);
-+    hdrslen = prtspexp->len;
-+    off = hdrsoff;
-+
-+    while (nf_mime_nextline(ptcp, hdrsoff+hdrslen, &off, &lineoff, &linelen))
-+    {
-+        if (linelen == 0)
-+        {
-+            break;
-+        }
-+        if (off > hdrsoff+hdrslen)
-+        {
-+            INFOP("!! overrun !!");
-+            break;
-+        }
-+        DEBUGP("hdr: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
-+
-+        if (nf_strncasecmp(ptcp+lineoff, "Transport:", 10) == 0)
-+        {
-+            uint oldtcplen = tcplen;
-+            if (!rtsp_mangle_tran(ct, ctinfo, exp, pskb, lineoff, linelen))
-+            {
-+                break;
-+            }
-+            get_skb_tcpdata(*pskb, &ptcp, &tcplen);
-+            hdrslen -= (oldtcplen-tcplen);
-+            off -= (oldtcplen-tcplen);
-+            lineoff -= (oldtcplen-tcplen);
-+            linelen -= (oldtcplen-tcplen);
-+            DEBUGP("rep: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
-+        }
-+    }
-+
-+    return NF_ACCEPT;
-+}
-+
-+static uint
-+help_in(struct ip_conntrack* ct, enum ip_conntrack_info ctinfo,
-+         struct ip_conntrack_expect* exp, struct sk_buff** pskb)
-+{
-+    /* XXX: unmangle */
-+    return NF_ACCEPT;
-+}
-+
-+static uint
-+help(struct ip_conntrack* ct,
-+     struct ip_conntrack_expect* exp,
-+     struct ip_nat_info* info,
-+     enum ip_conntrack_info ctinfo,
-+     unsigned int hooknum,
-+     struct sk_buff** pskb)
-+{
-+    struct iphdr*  iph  = (struct iphdr*)(*pskb)->nh.iph;
-+    struct tcphdr* tcph = (struct tcphdr*)((char*)iph + iph->ihl * 4);
-+    uint datalen;
-+    int dir;
-+    struct ip_ct_rtsp_expect* ct_rtsp_info;
-+    int rc = NF_ACCEPT;
-+
-+    if (ct == NULL || exp == NULL || info == NULL || pskb == NULL)
-+    {
-+        DEBUGP("!! null ptr (%p,%p,%p,%p) !!\n", ct, exp, info, pskb);
-+        return NF_ACCEPT;
-+    }
-+
-+    ct_rtsp_info = &exp->help.exp_rtsp_info;
-+
-+    /*
-+     * Only mangle things once: original direction in POST_ROUTING
-+     * and reply direction on PRE_ROUTING.
-+     */
-+    dir = CTINFO2DIR(ctinfo);
-+    if (!((hooknum == NF_IP_POST_ROUTING && dir == IP_CT_DIR_ORIGINAL)
-+          || (hooknum == NF_IP_PRE_ROUTING && dir == IP_CT_DIR_REPLY)))
-+    {
-+        DEBUGP("Not touching dir %s at hook %s\n",
-+               dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
-+               hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+               : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+               : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???");
-+        return NF_ACCEPT;
-+    }
-+    DEBUGP("got beyond not touching\n");
-+
-+    datalen = (*pskb)->len - iph->ihl * 4 - tcph->doff * 4;
-+
-+    LOCK_BH(&ip_rtsp_lock);
-+    /* Ensure the packet contains all of the marked data */
-+    if (!between(exp->seq + ct_rtsp_info->len,
-+                 ntohl(tcph->seq), ntohl(tcph->seq) + datalen))
-+    {
-+        /* Partial retransmission?  Probably a hacker. */
-+        if (net_ratelimit())
-+        {
-+            INFOP("partial packet %u/%u in %u/%u\n",
-+                   exp->seq, ct_rtsp_info->len, ntohl(tcph->seq), ntohl(tcph->seq) + datalen);
-+        }
-+        UNLOCK_BH(&ip_rtsp_lock);
-+        return NF_DROP;
-+    }
-+
-+    switch (dir)
-+    {
-+    case IP_CT_DIR_ORIGINAL:
-+        rc = help_out(ct, ctinfo, exp, pskb);
-+        break;
-+    case IP_CT_DIR_REPLY:
-+        rc = help_in(ct, ctinfo, exp, pskb);
-+        break;
-+    }
-+    UNLOCK_BH(&ip_rtsp_lock);
-+
-+    return rc;
-+}
-+
-+static struct ip_nat_helper ip_nat_rtsp_helpers[MAX_PORTS];
-+static char rtsp_names[MAX_PORTS][10];
-+
-+/* This function is intentionally _NOT_ defined as  __exit */
-+static void
-+fini(void)
-+{
-+    int i;
-+
-+    for (i = 0; i < num_ports; i++)
-+    {
-+        DEBUGP("unregistering helper for port %d\n", ports[i]);
-+        ip_nat_helper_unregister(&ip_nat_rtsp_helpers[i]);
-+    }
-+}
-+
-+static int __init
-+init(void)
-+{
-+    int ret = 0;
-+    int i;
-+    struct ip_nat_helper* hlpr;
-+    char* tmpname;
-+
-+    printk("ip_nat_rtsp v" IP_NF_RTSP_VERSION " loading\n");
-+
-+    if (ports[0] == 0)
-+    {
-+        ports[0] = RTSP_PORT;
-+    }
-+
-+    for (i = 0; (i < MAX_PORTS) && ports[i] != 0; i++)
-+    {
-+        hlpr = &ip_nat_rtsp_helpers[i];
-+        memset(hlpr, 0, sizeof(struct ip_nat_helper));
-+
-+        hlpr->tuple.dst.protonum = IPPROTO_TCP;
-+        hlpr->tuple.src.u.tcp.port = htons(ports[i]);
-+        hlpr->mask.src.u.tcp.port = 0xFFFF;
-+        hlpr->mask.dst.protonum = 0xFFFF;
-+        hlpr->help = help;
-+        hlpr->flags = 0;
-+        hlpr->me = THIS_MODULE;
-+        hlpr->expect = expected;
-+
-+        tmpname = &rtsp_names[i][0];
-+        if (ports[i] == RTSP_PORT)
-+        {
-+                sprintf(tmpname, "rtsp");
-+        }
-+        else
-+        {
-+                sprintf(tmpname, "rtsp-%d", i);
-+        }
-+        hlpr->name = tmpname;
-+
-+        DEBUGP("registering helper for port %d: name %s\n", ports[i], hlpr->name);
-+        ret = ip_nat_helper_register(hlpr);
-+
-+        if (ret)
-+        {
-+            printk("ip_nat_rtsp: error registering helper for port %d\n", ports[i]);
-+            fini();
-+            return 1;
-+        }
-+        num_ports++;
-+    }
-+    if (stunaddr != NULL)
-+    {
-+        extip = in_aton(stunaddr);
-+    }
-+    if (destaction != NULL)
-+    {
-+        if (strcmp(destaction, "auto") == 0)
-+        {
-+            dstact = DSTACT_AUTO;
-+        }
-+        if (strcmp(destaction, "strip") == 0)
-+        {
-+            dstact = DSTACT_STRIP;
-+        }
-+        if (strcmp(destaction, "none") == 0)
-+        {
-+            dstact = DSTACT_NONE;
-+        }
-+    }
-+    return ret;
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/arch/mips/kernel/mips_ksyms.c
-===================================================================
---- linux-2.4.35.4.orig/arch/mips/kernel/mips_ksyms.c
-+++ linux-2.4.35.4/arch/mips/kernel/mips_ksyms.c
-@@ -52,6 +52,7 @@ EXPORT_SYMBOL(EISA_bus);
- /*
-  * String functions
-  */
-+EXPORT_SYMBOL_NOVERS(memchr);
- EXPORT_SYMBOL_NOVERS(memcmp);
- EXPORT_SYMBOL_NOVERS(memset);
- EXPORT_SYMBOL_NOVERS(memcpy);
-Index: linux-2.4.35.4/include/linux/netfilter_helpers.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_helpers.h
-@@ -0,0 +1,133 @@
-+/*
-+ * Helpers for netfiler modules.  This file provides implementations for basic
-+ * functions such as strncasecmp(), etc.
-+ *
-+ * gcc will warn for defined but unused functions, so we only include the
-+ * functions requested.  The following macros are used:
-+ *   NF_NEED_STRNCASECMP        nf_strncasecmp()
-+ *   NF_NEED_STRTOU16           nf_strtou16()
-+ *   NF_NEED_STRTOU32           nf_strtou32()
-+ */
-+#ifndef _NETFILTER_HELPERS_H
-+#define _NETFILTER_HELPERS_H
-+
-+/* Only include these functions for kernel code. */
-+#ifdef __KERNEL__
-+
-+#include <linux/ctype.h>
-+#define iseol(c) ( (c) == '\r' || (c) == '\n' )
-+
-+/*
-+ * The standard strncasecmp()
-+ */
-+#ifdef NF_NEED_STRNCASECMP
-+static int
-+nf_strncasecmp(const char* s1, const char* s2, u_int32_t len)
-+{
-+    if (s1 == NULL || s2 == NULL)
-+    {
-+        if (s1 == NULL && s2 == NULL)
-+        {
-+            return 0;
-+        }
-+        return (s1 == NULL) ? -1 : 1;
-+    }
-+    while (len > 0 && tolower(*s1) == tolower(*s2))
-+    {
-+        len--;
-+        s1++;
-+        s2++;
-+    }
-+    return ( (len == 0) ? 0 : (tolower(*s1) - tolower(*s2)) );
-+}
-+#endif /* NF_NEED_STRNCASECMP */
-+
-+/*
-+ * Parse a string containing a 16-bit unsigned integer.
-+ * Returns the number of chars used, or zero if no number is found.
-+ */
-+#ifdef NF_NEED_STRTOU16
-+static int
-+nf_strtou16(const char* pbuf, u_int16_t* pval)
-+{
-+    int n = 0;
-+
-+    *pval = 0;
-+    while (isdigit(pbuf[n]))
-+    {
-+        *pval = (*pval * 10) + (pbuf[n] - '0');
-+        n++;
-+    }
-+
-+    return n;
-+}
-+#endif /* NF_NEED_STRTOU16 */
-+
-+/*
-+ * Parse a string containing a 32-bit unsigned integer.
-+ * Returns the number of chars used, or zero if no number is found.
-+ */
-+#ifdef NF_NEED_STRTOU32
-+static int
-+nf_strtou32(const char* pbuf, u_int32_t* pval)
-+{
-+    int n = 0;
-+
-+    *pval = 0;
-+    while (pbuf[n] >= '0' && pbuf[n] <= '9')
-+    {
-+        *pval = (*pval * 10) + (pbuf[n] - '0');
-+        n++;
-+    }
-+
-+    return n;
-+}
-+#endif /* NF_NEED_STRTOU32 */
-+
-+/*
-+ * Given a buffer and length, advance to the next line and mark the current
-+ * line.
-+ */
-+#ifdef NF_NEED_NEXTLINE
-+static int
-+nf_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
-+{
-+    uint    off = *poff;
-+    uint    physlen = 0;
-+
-+    if (off >= len)
-+    {
-+        return 0;
-+    }
-+
-+    while (p[off] != '\n')
-+    {
-+        if (len-off <= 1)
-+        {
-+            return 0;
-+        }
-+
-+        physlen++;
-+        off++;
-+    }
-+
-+    /* if we saw a crlf, physlen needs adjusted */
-+    if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
-+    {
-+        physlen--;
-+    }
-+
-+    /* advance past the newline */
-+    off++;
-+
-+    *plineoff = *poff;
-+    *plinelen = physlen;
-+    *poff = off;
-+
-+    return 1;
-+}
-+#endif /* NF_NEED_NEXTLINE */
-+
-+#endif /* __KERNEL__ */
-+
-+#endif /* _NETFILTER_HELPERS_H */
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h
-@@ -0,0 +1,68 @@
-+/*
-+ * RTSP extension for IP connection tracking.
-+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
-+ * based on ip_conntrack_irc.h
-+ *
-+ *      This program is free software; you can redistribute it and/or
-+ *      modify it under the terms of the GNU General Public License
-+ *      as published by the Free Software Foundation; either version
-+ *      2 of the License, or (at your option) any later version.
-+ */
-+#ifndef _IP_CONNTRACK_RTSP_H
-+#define _IP_CONNTRACK_RTSP_H
-+
-+/* #define IP_NF_RTSP_DEBUG */
-+#define IP_NF_RTSP_VERSION "0.01"
-+
-+/* port block types */
-+typedef enum {
-+    pb_single,  /* client_port=x */
-+    pb_range,   /* client_port=x-y */
-+    pb_discon   /* client_port=x/y (rtspbis) */
-+} portblock_t;
-+
-+/* We record seq number and length of rtsp headers here, all in host order. */
-+
-+/*
-+ * This structure is per expected connection.  It is a member of struct
-+ * ip_conntrack_expect.  The TCP SEQ for the conntrack expect is stored
-+ * there and we are expected to only store the length of the data which
-+ * needs replaced.  If a packet contains multiple RTSP messages, we create
-+ * one expected connection per message.
-+ *
-+ * We use these variables to mark the entire header block.  This may seem
-+ * like overkill, but the nature of RTSP requires it.  A header may appear
-+ * multiple times in a message.  We must treat two Transport headers the
-+ * same as one Transport header with two entries.
-+ */
-+struct ip_ct_rtsp_expect
-+{
-+    u_int32_t   len;        /* length of header block */
-+    portblock_t pbtype;     /* Type of port block that was requested */
-+    u_int16_t   loport;     /* Port that was requested, low or first */
-+    u_int16_t   hiport;     /* Port that was requested, high or second */
-+#if 0
-+    uint        method;     /* RTSP method */
-+    uint        cseq;       /* CSeq from request */
-+#endif
-+};
-+
-+/* This structure exists only once per master */
-+struct ip_ct_rtsp_master
-+{
-+    /* Empty (?) */
-+};
-+
-+
-+#ifdef __KERNEL__
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+
-+#define RTSP_PORT   554
-+
-+/* Protects rtsp part of conntracks */
-+DECLARE_LOCK_EXTERN(ip_rtsp_lock);
-+
-+#endif /* __KERNEL__ */
-+
-+#endif /* _IP_CONNTRACK_RTSP_H */
-Index: linux-2.4.35.4/include/linux/netfilter_mime.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_mime.h
-@@ -0,0 +1,90 @@
-+/*
-+ * MIME functions for netfilter modules.  This file provides implementations
-+ * for basic MIME parsing.  MIME headers are used in many protocols, such as
-+ * HTTP, RTSP, SIP, etc.
-+ *
-+ * gcc will warn for defined but unused functions, so we only include the
-+ * functions requested.  The following macros are used:
-+ *   NF_NEED_MIME_NEXTLINE      nf_mime_nextline()
-+ */
-+#ifndef _NETFILTER_MIME_H
-+#define _NETFILTER_MIME_H
-+
-+/* Only include these functions for kernel code. */
-+#ifdef __KERNEL__
-+
-+#include <linux/kernel.h>
-+#include <linux/ctype.h>
-+
-+/*
-+ * Given a buffer and length, advance to the next line and mark the current
-+ * line.  If the current line is empty, *plinelen will be set to zero.  If
-+ * not, it will be set to the actual line length (including CRLF).
-+ *
-+ * 'line' in this context means logical line (includes LWS continuations).
-+ * Returns 1 on success, 0 on failure.
-+ */
-+#ifdef NF_NEED_MIME_NEXTLINE
-+static int
-+nf_mime_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
-+{
-+    uint    off = *poff;
-+    uint    physlen = 0;
-+    int     is_first_line = 1;
-+
-+    if (off >= len)
-+    {
-+        return 0;
-+    }
-+
-+    do
-+    {
-+        while (p[off] != '\n')
-+        {
-+            if (len-off <= 1)
-+            {
-+                return 0;
-+            }
-+
-+            physlen++;
-+            off++;
-+        }
-+
-+        /* if we saw a crlf, physlen needs adjusted */
-+        if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
-+        {
-+            physlen--;
-+        }
-+
-+        /* advance past the newline */
-+        off++;
-+
-+        /* check for an empty line */
-+        if (physlen == 0)
-+        {
-+            break;
-+        }
-+
-+        /* check for colon on the first physical line */
-+        if (is_first_line)
-+        {
-+            is_first_line = 0;
-+            if (memchr(p+(*poff), ':', physlen) == NULL)
-+            {
-+                return 0;
-+            }
-+        }
-+    }
-+    while (p[off] == ' ' || p[off] == '\t');
-+
-+    *plineoff = *poff;
-+    *plinelen = (physlen == 0) ? 0 : (off - *poff);
-+    *poff = off;
-+
-+    return 1;
-+}
-+#endif /* NF_NEED_MIME_NEXTLINE */
-+
-+#endif /* __KERNEL__ */
-+
-+#endif /* _NETFILTER_MIME_H */
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/netfilter_ipv4/ip_conntrack.h
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-@@ -72,6 +72,7 @@ union ip_conntrack_expect_proto {
- #include <linux/netfilter_ipv4/ip_conntrack_irc.h>
- #include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
- #include <linux/netfilter_ipv4/ip_conntrack_h323.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_rtsp.h>
- 
- /* per expectation: application helper private data */
- union ip_conntrack_expect_help {
-@@ -81,6 +82,7 @@ union ip_conntrack_expect_help {
- 	struct ip_ct_irc_expect exp_irc_info;
- 	struct ip_ct_pptp_expect exp_pptp_info;
- 	struct ip_ct_h225_expect exp_h225_info;
-+	struct ip_ct_rtsp_expect exp_rtsp_info;
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
- 	union {
-@@ -96,6 +98,7 @@ union ip_conntrack_help {
- 	struct ip_ct_irc_master ct_irc_info;
- 	struct ip_ct_pptp_master ct_pptp_info;
- 	struct ip_ct_h225_master ct_h225_info;
-+	struct ip_ct_rtsp_master ct_rtsp_info;
- };
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/615-netfilter_nat_mms.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,745 +0,0 @@
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -17,6 +17,7 @@ if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ];
-   dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
-   dep_tristate '  H.323 (netmeeting) support' CONFIG_IP_NF_H323 $CONFIG_IP_NF_CONNTRACK
-   dep_tristate '  RTSP protocol support' CONFIG_IP_NF_RTSP $CONFIG_IP_NF_CONNTRACK
-+  dep_tristate '  MMS protocol support' CONFIG_IP_NF_MMS $CONFIG_IP_NF_CONNTRACK
- fi
- 
- if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-@@ -126,6 +127,13 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-          define_tristate CONFIG_IP_NF_NAT_RTSP $CONFIG_IP_NF_NAT
-        fi
-       fi
-+      if [ "$CONFIG_IP_NF_MMS" = "m" ]; then
-+       define_tristate CONFIG_IP_NF_NAT_MMS m
-+      else
-+       if [ "$CONFIG_IP_NF_MMS" = "y" ]; then
-+         define_tristate CONFIG_IP_NF_NAT_MMS $CONFIG_IP_NF_NAT
-+       fi
-+      fi
-       if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-         dep_tristate '    Basic SNMP-ALG support (EXPERIMENTAL)' CONFIG_IP_NF_NAT_SNMP_BASIC $CONFIG_IP_NF_NAT
-       fi
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -61,6 +61,10 @@ obj-$(CONFIG_IP_NF_RTSP) += ip_conntrack
- ifdef CONFIG_IP_NF_NAT_RTSP
-        export-objs += ip_conntrack_rtsp.o
- endif
-+obj-$(CONFIG_IP_NF_MMS) += ip_conntrack_mms.o
-+ifdef CONFIG_IP_NF_NAT_MMS
-+       export-objs += ip_conntrack_mms.o
-+endif
- 
- 
- 
-@@ -73,6 +77,7 @@ obj-$(CONFIG_IP_NF_NAT_PROTO_GRE) += ip_
- obj-$(CONFIG_IP_NF_NAT_PPTP) += ip_nat_pptp.o
- obj-$(CONFIG_IP_NF_NAT_H323) += ip_nat_h323.o
- obj-$(CONFIG_IP_NF_NAT_RTSP) += ip_nat_rtsp.o
-+obj-$(CONFIG_IP_NF_NAT_MMS) += ip_nat_mms.o
- 
- # generic IP tables 
- obj-$(CONFIG_IP_NF_IPTABLES) += ip_tables.o
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_mms.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_conntrack_mms.c
-@@ -0,0 +1,292 @@
-+/* MMS extension for IP connection tracking
-+ * (C) 2002 by Filip Sneppe <filip.sneppe@cronos.be>
-+ * based on ip_conntrack_ftp.c and ip_conntrack_irc.c
-+ *
-+ * ip_conntrack_mms.c v0.3 2002-09-22
-+ *
-+ *      This program is free software; you can redistribute it and/or
-+ *      modify it under the terms of the GNU General Public License
-+ *      as published by the Free Software Foundation; either version
-+ *      2 of the License, or (at your option) any later version.
-+ *
-+ *      Module load syntax:
-+ *      insmod ip_conntrack_mms.o ports=port1,port2,...port<MAX_PORTS>
-+ *
-+ *      Please give the ports of all MMS servers You wish to connect to.
-+ *      If you don't specify ports, the default will be TCP port 1755.
-+ *
-+ *      More info on MMS protocol, firewalls and NAT:
-+ *      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwmt/html/MMSFirewall.asp
-+ *      http://www.microsoft.com/windows/windowsmedia/serve/firewall.asp
-+ *
-+ *      The SDP project people are reverse-engineering MMS:
-+ *      http://get.to/sdp
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/netfilter.h>
-+#include <linux/ip.h>
-+#include <linux/ctype.h>
-+#include <net/checksum.h>
-+#include <net/tcp.h>
-+
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_mms.h>
-+
-+DECLARE_LOCK(ip_mms_lock);
-+struct module *ip_conntrack_mms = THIS_MODULE;
-+
-+#define MAX_PORTS 8
-+static int ports[MAX_PORTS];
-+static int ports_c;
-+#ifdef MODULE_PARM
-+MODULE_PARM(ports, "1-" __MODULE_STRING(MAX_PORTS) "i");
-+#endif
-+
-+#define DEBUGP(format, args...)
-+
-+#ifdef CONFIG_IP_NF_NAT_NEEDED
-+EXPORT_SYMBOL(ip_mms_lock);
-+#endif
-+
-+MODULE_AUTHOR("Filip Sneppe <filip.sneppe@cronos.be>");
-+MODULE_DESCRIPTION("Microsoft Windows Media Services (MMS) connection tracking module");
-+MODULE_LICENSE("GPL");
-+
-+/* #define isdigit(c) (c >= '0' && c <= '9') */
-+
-+/* copied from drivers/usb/serial/io_edgeport.c - not perfect but will do the trick */
-+static void unicode_to_ascii (char *string, short *unicode, int unicode_size)
-+{
-+	int i;
-+	for (i = 0; i < unicode_size; ++i) {
-+		string[i] = (char)(unicode[i]);
-+	}
-+	string[unicode_size] = 0x00;
-+}
-+
-+__inline static int atoi(char *s) 
-+{
-+	int i=0;
-+	while (isdigit(*s)) {
-+		i = i*10 + *(s++) - '0';
-+	}
-+	return i;
-+}
-+
-+/* convert ip address string like "192.168.0.10" to unsigned int */
-+__inline static u_int32_t asciiiptoi(char *s)
-+{
-+	unsigned int i, j, k;
-+
-+	for(i=k=0; k<3; ++k, ++s, i<<=8) {
-+		i+=atoi(s);
-+		for(j=0; (*(++s) != '.') && (j<3); ++j)
-+			;
-+	}
-+	i+=atoi(s);
-+	return ntohl(i);
-+}
-+
-+int parse_mms(const char *data, 
-+	      const unsigned int datalen,
-+	      u_int32_t *mms_ip,
-+	      u_int16_t *mms_proto,
-+	      u_int16_t *mms_port,
-+	      char **mms_string_b,
-+	      char **mms_string_e,
-+	      char **mms_padding_e)
-+{
-+	int unicode_size, i;
-+	char tempstring[28];       /* "\\255.255.255.255\UDP\65535" */
-+	char getlengthstring[28];
-+	
-+	for(unicode_size=0; 
-+	    (char) *(data+(MMS_SRV_UNICODE_STRING_OFFSET+unicode_size*2)) != (char)0;
-+	    unicode_size++)
-+		if ((unicode_size == 28) || (MMS_SRV_UNICODE_STRING_OFFSET+unicode_size*2 >= datalen)) 
-+			return -1; /* out of bounds - incomplete packet */
-+	
-+	unicode_to_ascii(tempstring, (short *)(data+MMS_SRV_UNICODE_STRING_OFFSET), unicode_size);
-+	DEBUGP("ip_conntrack_mms: offset 60: %s\n", (const char *)(tempstring));
-+	
-+	/* IP address ? */
-+	*mms_ip = asciiiptoi(tempstring+2);
-+	
-+	i=sprintf(getlengthstring, "%u.%u.%u.%u", HIPQUAD(*mms_ip));
-+		
-+	/* protocol ? */
-+	if(strncmp(tempstring+3+i, "TCP", 3)==0)
-+		*mms_proto = IPPROTO_TCP;
-+	else if(strncmp(tempstring+3+i, "UDP", 3)==0)
-+		*mms_proto = IPPROTO_UDP;
-+
-+	/* port ? */
-+	*mms_port = atoi(tempstring+7+i);
-+
-+	/* we store a pointer to the beginning of the "\\a.b.c.d\proto\port" 
-+	   unicode string, one to the end of the string, and one to the end 
-+	   of the packet, since we must keep track of the number of bytes 
-+	   between end of the unicode string and the end of packet (padding) */
-+	*mms_string_b  = (char *)(data + MMS_SRV_UNICODE_STRING_OFFSET);
-+	*mms_string_e  = (char *)(data + MMS_SRV_UNICODE_STRING_OFFSET + unicode_size * 2);
-+	*mms_padding_e = (char *)(data + datalen); /* looks funny, doesn't it */
-+	return 0;
-+}
-+
-+
-+static int help(const struct iphdr *iph, size_t len,
-+		struct ip_conntrack *ct,
-+		enum ip_conntrack_info ctinfo)
-+{
-+	/* tcplen not negative guaranteed by ip_conntrack_tcp.c */
-+	struct tcphdr *tcph = (void *)iph + iph->ihl * 4;
-+	const char *data = (const char *)tcph + tcph->doff * 4;
-+	unsigned int tcplen = len - iph->ihl * 4;
-+	unsigned int datalen = tcplen - tcph->doff * 4;
-+	int dir = CTINFO2DIR(ctinfo);
-+	struct ip_conntrack_expect expect, *exp = &expect; 
-+	struct ip_ct_mms_expect *exp_mms_info = &exp->help.exp_mms_info;
-+	
-+	u_int32_t mms_ip;
-+	u_int16_t mms_proto;
-+	char mms_proto_string[8];
-+	u_int16_t mms_port;
-+	char *mms_string_b, *mms_string_e, *mms_padding_e;
-+	     
-+	/* Until there's been traffic both ways, don't look in packets. */
-+	if (ctinfo != IP_CT_ESTABLISHED
-+	    && ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY) {
-+		DEBUGP("ip_conntrack_mms: Conntrackinfo = %u\n", ctinfo);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* Not whole TCP header? */
-+	if (tcplen < sizeof(struct tcphdr) || tcplen < tcph->doff*4) {
-+		DEBUGP("ip_conntrack_mms: tcplen = %u\n", (unsigned)tcplen);
-+		return NF_ACCEPT;
-+	}
-+
-+	/* Checksum invalid?  Ignore. */
-+	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
-+	    csum_partial((char *)tcph, tcplen, 0))) {
-+		DEBUGP("mms_help: bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
-+		       tcph, tcplen, NIPQUAD(iph->saddr),
-+		       NIPQUAD(iph->daddr));
-+		return NF_ACCEPT;
-+	}
-+	
-+	/* Only look at packets with 0x00030002/196610 on bytes 36->39 of TCP payload */
-+	if( (MMS_SRV_MSG_OFFSET < datalen) && 
-+	    ((*(u32 *)(data+MMS_SRV_MSG_OFFSET)) == MMS_SRV_MSG_ID)) {
-+		DEBUGP("ip_conntrack_mms: offset 37: %u %u %u %u, datalen:%u\n", 
-+		       (u8)*(data+36), (u8)*(data+37), 
-+		       (u8)*(data+38), (u8)*(data+39),
-+		       datalen);
-+		if(parse_mms(data, datalen, &mms_ip, &mms_proto, &mms_port,
-+		             &mms_string_b, &mms_string_e, &mms_padding_e))
-+			if(net_ratelimit())
-+				printk(KERN_WARNING
-+				       "ip_conntrack_mms: Unable to parse data payload\n");
-+
-+		memset(&expect, 0, sizeof(expect));
-+
-+		sprintf(mms_proto_string, "(%u)", mms_proto);
-+		DEBUGP("ip_conntrack_mms: adding %s expectation %u.%u.%u.%u -> %u.%u.%u.%u:%u\n",
-+		       mms_proto == IPPROTO_TCP ? "TCP"
-+		       : mms_proto == IPPROTO_UDP ? "UDP":mms_proto_string,
-+		       NIPQUAD(ct->tuplehash[!dir].tuple.src.ip),
-+		       NIPQUAD(mms_ip),
-+		       mms_port);
-+		
-+		/* it's possible that the client will just ask the server to tunnel
-+		   the stream over the same TCP session (from port 1755): there's 
-+		   shouldn't be a need to add an expectation in that case, but it
-+		   makes NAT packet mangling so much easier */
-+		LOCK_BH(&ip_mms_lock);
-+
-+		DEBUGP("ip_conntrack_mms: tcph->seq = %u\n", tcph->seq);
-+		
-+		exp->seq = ntohl(tcph->seq) + (mms_string_b - data);
-+		exp_mms_info->len     = (mms_string_e  - mms_string_b);
-+		exp_mms_info->padding = (mms_padding_e - mms_string_e);
-+		exp_mms_info->port    = mms_port;
-+		
-+		DEBUGP("ip_conntrack_mms: wrote info seq=%u (ofs=%u), len=%d, padding=%u\n",
-+		       exp->seq, (mms_string_e - data), exp_mms_info->len, exp_mms_info->padding);
-+		
-+		exp->tuple = ((struct ip_conntrack_tuple)
-+		              { { ct->tuplehash[!dir].tuple.src.ip, { 0 } },
-+		              { mms_ip,
-+		                { (__u16) ntohs(mms_port) },
-+		                mms_proto } }
-+		             );
-+		exp->mask  = ((struct ip_conntrack_tuple)
-+		             { { 0xFFFFFFFF, { 0 } },
-+		               { 0xFFFFFFFF, { 0xFFFF }, 0xFFFF }});
-+		exp->expectfn = NULL;
-+		ip_conntrack_expect_related(ct, &expect);
-+		UNLOCK_BH(&ip_mms_lock);
-+	}
-+
-+	return NF_ACCEPT;
-+}
-+
-+static struct ip_conntrack_helper mms[MAX_PORTS];
-+static char mms_names[MAX_PORTS][10];
-+
-+/* Not __exit: called from init() */
-+static void fini(void)
-+{
-+	int i;
-+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
-+		DEBUGP("ip_conntrack_mms: unregistering helper for port %d\n",
-+				ports[i]);
-+		ip_conntrack_helper_unregister(&mms[i]);
-+	}
-+}
-+
-+static int __init init(void)
-+{
-+	int i, ret;
-+	char *tmpname;
-+
-+	if (ports[0] == 0)
-+		ports[0] = MMS_PORT;
-+
-+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
-+		memset(&mms[i], 0, sizeof(struct ip_conntrack_helper));
-+		mms[i].tuple.src.u.tcp.port = htons(ports[i]);
-+		mms[i].tuple.dst.protonum = IPPROTO_TCP;
-+		mms[i].mask.src.u.tcp.port = 0xFFFF;
-+		mms[i].mask.dst.protonum = 0xFFFF;
-+		mms[i].max_expected = 1;
-+		mms[i].timeout = 0;
-+		mms[i].flags = IP_CT_HELPER_F_REUSE_EXPECT;
-+		mms[i].me = THIS_MODULE;
-+		mms[i].help = help;
-+
-+		tmpname = &mms_names[i][0];
-+		if (ports[i] == MMS_PORT)
-+			sprintf(tmpname, "mms");
-+		else
-+			sprintf(tmpname, "mms-%d", ports[i]);
-+		mms[i].name = tmpname;
-+
-+		DEBUGP("ip_conntrack_mms: registering helper for port %d\n", 
-+				ports[i]);
-+		ret = ip_conntrack_helper_register(&mms[i]);
-+
-+		if (ret) {
-+			fini();
-+			return ret;
-+		}
-+		ports_c++;
-+	}
-+	return 0;
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/ip_nat_mms.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ip_nat_mms.c
-@@ -0,0 +1,330 @@
-+/* MMS extension for TCP NAT alteration.
-+ * (C) 2002 by Filip Sneppe <filip.sneppe@cronos.be>
-+ * based on ip_nat_ftp.c and ip_nat_irc.c
-+ *
-+ * ip_nat_mms.c v0.3 2002-09-22
-+ *
-+ *      This program is free software; you can redistribute it and/or
-+ *      modify it under the terms of the GNU General Public License
-+ *      as published by the Free Software Foundation; either version
-+ *      2 of the License, or (at your option) any later version.
-+ *
-+ *      Module load syntax:
-+ *      insmod ip_nat_mms.o ports=port1,port2,...port<MAX_PORTS>
-+ *
-+ *      Please give the ports of all MMS servers You wish to connect to.
-+ *      If you don't specify ports, the default will be TCP port 1755.
-+ *
-+ *      More info on MMS protocol, firewalls and NAT:
-+ *      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwmt/html/MMSFirewall.asp
-+ *      http://www.microsoft.com/windows/windowsmedia/serve/firewall.asp
-+ *
-+ *      The SDP project people are reverse-engineering MMS:
-+ *      http://get.to/sdp
-+ */
-+
-+
-+#include <linux/module.h>
-+#include <linux/netfilter_ipv4.h>
-+#include <linux/ip.h>
-+#include <linux/tcp.h>
-+#include <net/tcp.h>
-+#include <linux/netfilter_ipv4/ip_nat.h>
-+#include <linux/netfilter_ipv4/ip_nat_helper.h>
-+#include <linux/netfilter_ipv4/ip_nat_rule.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_mms.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
-+
-+#define DEBUGP(format, args...)
-+#define DUMP_BYTES(address, counter)
-+
-+#define MAX_PORTS 8
-+static int ports[MAX_PORTS];
-+static int ports_c = 0;
-+
-+#ifdef MODULE_PARM
-+MODULE_PARM(ports, "1-" __MODULE_STRING(MAX_PORTS) "i");
-+#endif
-+
-+MODULE_AUTHOR("Filip Sneppe <filip.sneppe@cronos.be>");
-+MODULE_DESCRIPTION("Microsoft Windows Media Services (MMS) NAT module");
-+MODULE_LICENSE("GPL");
-+
-+DECLARE_LOCK_EXTERN(ip_mms_lock);
-+
-+
-+static int mms_data_fixup(const struct ip_ct_mms_expect *ct_mms_info,
-+                          struct ip_conntrack *ct,
-+                          struct sk_buff **pskb,
-+                          enum ip_conntrack_info ctinfo,
-+                          struct ip_conntrack_expect *expect)
-+{
-+	u_int32_t newip;
-+	struct ip_conntrack_tuple t;
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *) iph + iph->ihl * 4;
-+	char *data = (char *)tcph + tcph->doff * 4;
-+	int i, j, k, port;
-+	u_int16_t mms_proto;
-+
-+	u_int32_t *mms_chunkLenLV    = (u_int32_t *)(data + MMS_SRV_CHUNKLENLV_OFFSET);
-+	u_int32_t *mms_chunkLenLM    = (u_int32_t *)(data + MMS_SRV_CHUNKLENLM_OFFSET);
-+	u_int32_t *mms_messageLength = (u_int32_t *)(data + MMS_SRV_MESSAGELENGTH_OFFSET);
-+
-+	int zero_padding;
-+
-+	char buffer[28];         /* "\\255.255.255.255\UDP\65635" * 2 (for unicode) */
-+	char unicode_buffer[75]; /* 27*2 (unicode) + 20 + 1 */
-+	char proto_string[6];
-+	
-+	MUST_BE_LOCKED(&ip_mms_lock);
-+
-+	/* what was the protocol again ? */
-+	mms_proto = expect->tuple.dst.protonum;
-+	sprintf(proto_string, "%u", mms_proto);
-+	
-+	DEBUGP("ip_nat_mms: mms_data_fixup: info (seq %u + %u) in %u, proto %s\n",
-+	       expect->seq, ct_mms_info->len, ntohl(tcph->seq),
-+	       mms_proto == IPPROTO_UDP ? "UDP"
-+	       : mms_proto == IPPROTO_TCP ? "TCP":proto_string);
-+	
-+	newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+
-+	/* Alter conntrack's expectations. */
-+	t = expect->tuple;
-+	t.dst.ip = newip;
-+	for (port = ct_mms_info->port; port != 0; port++) {
-+		t.dst.u.tcp.port = htons(port);
-+		if (ip_conntrack_change_expect(expect, &t) == 0) {
-+			DEBUGP("ip_nat_mms: mms_data_fixup: using port %d\n", port);
-+			break;
-+		}
-+	}
-+	
-+	if(port == 0)
-+		return 0;
-+
-+	sprintf(buffer, "\\\\%u.%u.%u.%u\\%s\\%u",
-+	        NIPQUAD(newip),
-+		expect->tuple.dst.protonum == IPPROTO_UDP ? "UDP"
-+		: expect->tuple.dst.protonum == IPPROTO_TCP ? "TCP":proto_string,
-+		port);
-+	DEBUGP("ip_nat_mms: new unicode string=%s\n", buffer);
-+	
-+	memset(unicode_buffer, 0, sizeof(char)*75);
-+
-+	for (i=0; i<strlen(buffer); ++i)
-+		*(unicode_buffer+i*2)=*(buffer+i);
-+	
-+	DEBUGP("ip_nat_mms: mms_data_fixup: padding: %u len: %u\n", ct_mms_info->padding, ct_mms_info->len);
-+	DEBUGP("ip_nat_mms: mms_data_fixup: offset: %u\n", MMS_SRV_UNICODE_STRING_OFFSET+ct_mms_info->len);
-+	DUMP_BYTES(data+MMS_SRV_UNICODE_STRING_OFFSET, 60);
-+	
-+	/* add end of packet to it */
-+	for (j=0; j<ct_mms_info->padding; ++j) {
-+		DEBUGP("ip_nat_mms: mms_data_fixup: i=%u j=%u byte=%u\n", 
-+		       i, j, (u8)*(data+MMS_SRV_UNICODE_STRING_OFFSET+ct_mms_info->len+j));
-+		*(unicode_buffer+i*2+j) = *(data+MMS_SRV_UNICODE_STRING_OFFSET+ct_mms_info->len+j);
-+	}
-+
-+	/* pad with zeroes at the end ? see explanation of weird math below */
-+	zero_padding = (8-(strlen(buffer)*2 + ct_mms_info->padding + 4)%8)%8;
-+	for (k=0; k<zero_padding; ++k)
-+		*(unicode_buffer+i*2+j+k)= (char)0;
-+	
-+	DEBUGP("ip_nat_mms: mms_data_fixup: zero_padding = %u\n", zero_padding);
-+	DEBUGP("ip_nat_mms: original=> chunkLenLV=%u chunkLenLM=%u messageLength=%u\n",
-+	       *mms_chunkLenLV, *mms_chunkLenLM, *mms_messageLength);
-+	
-+	/* explanation, before I forget what I did:
-+	   strlen(buffer)*2 + ct_mms_info->padding + 4 must be divisable by 8;
-+	   divide by 8 and add 3 to compute the mms_chunkLenLM field,
-+	   but note that things may have to be padded with zeroes to align by 8 
-+	   bytes, hence we add 7 and divide by 8 to get the correct length */ 
-+	*mms_chunkLenLM    = (u_int32_t) (3+(strlen(buffer)*2+ct_mms_info->padding+11)/8);
-+	*mms_chunkLenLV    = *mms_chunkLenLM+2;
-+	*mms_messageLength = *mms_chunkLenLV*8;
-+	
-+	DEBUGP("ip_nat_mms: modified=> chunkLenLV=%u chunkLenLM=%u messageLength=%u\n",
-+	       *mms_chunkLenLV, *mms_chunkLenLM, *mms_messageLength);
-+	
-+	ip_nat_mangle_tcp_packet(pskb, ct, ctinfo, 
-+	                         expect->seq - ntohl(tcph->seq),
-+	                         ct_mms_info->len + ct_mms_info->padding, unicode_buffer,
-+	                         strlen(buffer)*2 + ct_mms_info->padding + zero_padding);
-+	DUMP_BYTES(unicode_buffer, 60);
-+	
-+	return 1;
-+}
-+
-+static unsigned int
-+mms_nat_expected(struct sk_buff **pskb,
-+                 unsigned int hooknum,
-+                 struct ip_conntrack *ct,
-+                 struct ip_nat_info *info)
-+{
-+	struct ip_nat_multi_range mr;
-+	u_int32_t newdstip, newsrcip, newip;
-+
-+	struct ip_conntrack *master = master_ct(ct);
-+
-+	IP_NF_ASSERT(info);
-+	IP_NF_ASSERT(master);
-+
-+	IP_NF_ASSERT(!(info->initialized & (1 << HOOK2MANIP(hooknum))));
-+
-+	DEBUGP("ip_nat_mms: mms_nat_expected: We have a connection!\n");
-+
-+	newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+	newsrcip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+	DEBUGP("ip_nat_mms: mms_nat_expected: hook %s: newsrc->newdst %u.%u.%u.%u->%u.%u.%u.%u\n",
-+	       hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+	       : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+	       : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???",
-+	       NIPQUAD(newsrcip), NIPQUAD(newdstip));
-+
-+	if (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC)
-+		newip = newsrcip;
-+	else
-+		newip = newdstip;
-+
-+	DEBUGP("ip_nat_mms: mms_nat_expected: IP to %u.%u.%u.%u\n", NIPQUAD(newip));
-+
-+	mr.rangesize = 1;
-+	/* We don't want to manip the per-protocol, just the IPs. */
-+	mr.range[0].flags = IP_NAT_RANGE_MAP_IPS;
-+	mr.range[0].min_ip = mr.range[0].max_ip = newip;
-+
-+	return ip_nat_setup_info(ct, &mr, hooknum);
-+}
-+
-+
-+static unsigned int mms_nat_help(struct ip_conntrack *ct,
-+			 struct ip_conntrack_expect *exp,
-+			 struct ip_nat_info *info,
-+			 enum ip_conntrack_info ctinfo,
-+			 unsigned int hooknum,
-+			 struct sk_buff **pskb)
-+{
-+	struct iphdr *iph = (*pskb)->nh.iph;
-+	struct tcphdr *tcph = (void *) iph + iph->ihl * 4;
-+	unsigned int datalen;
-+	int dir;
-+	struct ip_ct_mms_expect *ct_mms_info;
-+
-+	if (!exp)
-+		DEBUGP("ip_nat_mms: no exp!!");
-+
-+	ct_mms_info = &exp->help.exp_mms_info;
-+	
-+	/* Only mangle things once: original direction in POST_ROUTING
-+	   and reply direction on PRE_ROUTING. */
-+	dir = CTINFO2DIR(ctinfo);
-+	if (!((hooknum == NF_IP_POST_ROUTING && dir == IP_CT_DIR_ORIGINAL)
-+	    ||(hooknum == NF_IP_PRE_ROUTING && dir == IP_CT_DIR_REPLY))) {
-+		DEBUGP("ip_nat_mms: mms_nat_help: not touching dir %s at hook %s\n",
-+		       dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
-+		       hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+		       : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+		       : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???");
-+		return NF_ACCEPT;
-+	}
-+	DEBUGP("ip_nat_mms: mms_nat_help: beyond not touching (dir %s at hook %s)\n",
-+	       dir == IP_CT_DIR_ORIGINAL ? "ORIG" : "REPLY",
-+	       hooknum == NF_IP_POST_ROUTING ? "POSTROUTING"
-+	       : hooknum == NF_IP_PRE_ROUTING ? "PREROUTING"
-+	       : hooknum == NF_IP_LOCAL_OUT ? "OUTPUT" : "???");
-+	
-+	datalen = (*pskb)->len - iph->ihl * 4 - tcph->doff * 4;
-+	
-+	DEBUGP("ip_nat_mms: mms_nat_help: %u+%u=%u %u %u\n", exp->seq, ct_mms_info->len,
-+	       exp->seq + ct_mms_info->len,
-+	       ntohl(tcph->seq),
-+	       ntohl(tcph->seq) + datalen);
-+	
-+	LOCK_BH(&ip_mms_lock);
-+	/* Check wether the whole IP/proto/port pattern is carried in the payload */
-+	if (between(exp->seq + ct_mms_info->len,
-+	    ntohl(tcph->seq),
-+	    ntohl(tcph->seq) + datalen)) {
-+		if (!mms_data_fixup(ct_mms_info, ct, pskb, ctinfo, exp)) {
-+			UNLOCK_BH(&ip_mms_lock);
-+			return NF_DROP;
-+		}
-+	} else {
-+		/* Half a match?  This means a partial retransmisison.
-+		   It's a cracker being funky. */
-+		if (net_ratelimit()) {
-+			printk("ip_nat_mms: partial packet %u/%u in %u/%u\n",
-+			       exp->seq, ct_mms_info->len,
-+			       ntohl(tcph->seq),
-+			       ntohl(tcph->seq) + datalen);
-+		}
-+		UNLOCK_BH(&ip_mms_lock);
-+		return NF_DROP;
-+	}
-+	UNLOCK_BH(&ip_mms_lock);
-+	
-+	return NF_ACCEPT;
-+}
-+
-+static struct ip_nat_helper mms[MAX_PORTS];
-+static char mms_names[MAX_PORTS][10];
-+
-+/* Not __exit: called from init() */
-+static void fini(void)
-+{
-+	int i;
-+
-+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
-+		DEBUGP("ip_nat_mms: unregistering helper for port %d\n", ports[i]);
-+		ip_nat_helper_unregister(&mms[i]);
-+	}
-+}
-+
-+static int __init init(void)
-+{
-+	int i, ret = 0;
-+	char *tmpname;
-+
-+	if (ports[0] == 0)
-+		ports[0] = MMS_PORT;
-+
-+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
-+
-+		memset(&mms[i], 0, sizeof(struct ip_nat_helper));
-+
-+		mms[i].tuple.dst.protonum = IPPROTO_TCP;
-+		mms[i].tuple.src.u.tcp.port = htons(ports[i]);
-+		mms[i].mask.dst.protonum = 0xFFFF;
-+		mms[i].mask.src.u.tcp.port = 0xFFFF;
-+		mms[i].help = mms_nat_help;
-+		mms[i].me = THIS_MODULE;
-+		mms[i].flags = 0;
-+		mms[i].expect = mms_nat_expected;
-+
-+		tmpname = &mms_names[i][0];
-+		if (ports[i] == MMS_PORT)
-+			sprintf(tmpname, "mms");
-+		else
-+			sprintf(tmpname, "mms-%d", i);
-+		mms[i].name = tmpname;
-+
-+		DEBUGP("ip_nat_mms: register helper for port %d\n",
-+				ports[i]);
-+		ret = ip_nat_helper_register(&mms[i]);
-+
-+		if (ret) {
-+			printk("ip_nat_mms: error registering "
-+			       "helper for port %d\n", ports[i]);
-+			fini();
-+			return ret;
-+		}
-+		ports_c++;
-+	}
-+
-+	return ret;
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/netfilter_ipv4/ip_conntrack.h
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack.h
-@@ -73,6 +73,7 @@ union ip_conntrack_expect_proto {
- #include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
- #include <linux/netfilter_ipv4/ip_conntrack_h323.h>
- #include <linux/netfilter_ipv4/ip_conntrack_rtsp.h>
-+#include <linux/netfilter_ipv4/ip_conntrack_mms.h>
- 
- /* per expectation: application helper private data */
- union ip_conntrack_expect_help {
-@@ -83,6 +84,7 @@ union ip_conntrack_expect_help {
- 	struct ip_ct_pptp_expect exp_pptp_info;
- 	struct ip_ct_h225_expect exp_h225_info;
- 	struct ip_ct_rtsp_expect exp_rtsp_info;
-+	struct ip_ct_mms_expect exp_mms_info;
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
- 	union {
-@@ -99,6 +101,7 @@ union ip_conntrack_help {
- 	struct ip_ct_pptp_master ct_pptp_info;
- 	struct ip_ct_h225_master ct_h225_info;
- 	struct ip_ct_rtsp_master ct_rtsp_info;
-+	struct ip_ct_mms_master ct_mms_info;
- };
- 
- #ifdef CONFIG_IP_NF_NAT_NEEDED
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_mms.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_conntrack_mms.h
-@@ -0,0 +1,31 @@
-+#ifndef _IP_CONNTRACK_MMS_H
-+#define _IP_CONNTRACK_MMS_H
-+/* MMS tracking. */
-+
-+#ifdef __KERNEL__
-+#include <linux/netfilter_ipv4/lockhelp.h>
-+
-+DECLARE_LOCK_EXTERN(ip_mms_lock);
-+
-+#define MMS_PORT                         1755
-+#define MMS_SRV_MSG_ID                   196610
-+
-+#define MMS_SRV_MSG_OFFSET               36
-+#define MMS_SRV_UNICODE_STRING_OFFSET    60
-+#define MMS_SRV_CHUNKLENLV_OFFSET        16
-+#define MMS_SRV_CHUNKLENLM_OFFSET        32
-+#define MMS_SRV_MESSAGELENGTH_OFFSET     8
-+#endif
-+
-+/* This structure is per expected connection */
-+struct ip_ct_mms_expect {
-+	u_int32_t len;
-+	u_int32_t padding;
-+	u_int16_t port;
-+};
-+
-+/* This structure exists only once per master */
-+struct ip_ct_mms_master {
-+};
-+
-+#endif /* _IP_CONNTRACK_MMS_H */
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/617-netfilter_time.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,242 +0,0 @@
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -47,6 +47,7 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-   dep_tristate '  netfilter MARK match support' CONFIG_IP_NF_MATCH_MARK $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  Multiple port match support' CONFIG_IP_NF_MATCH_MULTIPORT $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  TOS match support' CONFIG_IP_NF_MATCH_TOS $CONFIG_IP_NF_IPTABLES
-+  dep_tristate '  TIME match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_TIME $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  condition match support' CONFIG_IP_NF_MATCH_CONDITION $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  recent match support' CONFIG_IP_NF_MATCH_RECENT $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  ECN match support' CONFIG_IP_NF_MATCH_ECN $CONFIG_IP_NF_IPTABLES
-Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_time.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ipt_time.c
-@@ -0,0 +1,193 @@
-+/*
-+  This is a module which is used for time matching
-+  It is using some modified code from dietlibc (localtime() function)
-+  that you can find at http://www.fefe.de/dietlibc/
-+  This file is distributed under the terms of the GNU General Public
-+  License (GPL). Copies of the GPL can be obtained from: ftp://prep.ai.mit.edu/pub/gnu/GPL
-+  2001-05-04 Fabrice MARIE <fabrice@netfilter.org> : initial development.
-+  2001-21-05 Fabrice MARIE <fabrice@netfilter.org> : bug fix in the match code,
-+     thanks to "Zeng Yu" <zengy@capitel.com.cn> for bug report.
-+  2001-26-09 Fabrice MARIE <fabrice@netfilter.org> : force the match to be in LOCAL_IN or PRE_ROUTING only.
-+  2001-30-11 Fabrice : added the possibility to use the match in FORWARD/OUTPUT with a little hack,
-+     added Nguyen Dang Phuoc Dong <dongnd@tlnet.com.vn> patch to support timezones.
-+  2004-05-02 Fabrice : added support for date matching, from an idea of Fabien COELHO.
-+*/
-+
-+#include <linux/module.h>
-+#include <linux/skbuff.h>
-+#include <linux/netfilter_ipv4/ip_tables.h>
-+#include <linux/netfilter_ipv4/ipt_time.h>
-+#include <linux/time.h>
-+
-+MODULE_AUTHOR("Fabrice MARIE <fabrice@netfilter.org>");
-+MODULE_DESCRIPTION("Match arrival timestamp/date");
-+MODULE_LICENSE("GPL");
-+
-+struct tm
-+{
-+	int tm_sec;                   /* Seconds.     [0-60] (1 leap second) */
-+	int tm_min;                   /* Minutes.     [0-59] */
-+	int tm_hour;                  /* Hours.       [0-23] */
-+	int tm_mday;                  /* Day.         [1-31] */
-+	int tm_mon;                   /* Month.       [0-11] */
-+	int tm_year;                  /* Year - 1900.  */
-+	int tm_wday;                  /* Day of week. [0-6] */
-+	int tm_yday;                  /* Days in year.[0-365] */
-+	int tm_isdst;                 /* DST.         [-1/0/1]*/
-+
-+	long int tm_gmtoff;           /* we don't care, we count from GMT */
-+	const char *tm_zone;          /* we don't care, we count from GMT */
-+};
-+
-+void
-+localtime(const time_t *timepr, struct tm *r);
-+
-+static int
-+match(const struct sk_buff *skb,
-+      const struct net_device *in,
-+      const struct net_device *out,
-+      const void *matchinfo,
-+      int offset,
-+      const void *hdr,
-+      u_int16_t datalen,
-+      int *hotdrop)
-+{
-+	const struct ipt_time_info *info = matchinfo;   /* match info for rule */
-+	struct tm currenttime;                          /* time human readable */
-+	u_int8_t days_of_week[7] = {64, 32, 16, 8, 4, 2, 1};
-+	u_int16_t packet_time;
-+	struct timeval kerneltimeval;
-+	time_t packet_local_time;
-+
-+	/* if kerneltime=1, we don't read the skb->timestamp but kernel time instead */
-+	if (info->kerneltime)
-+	{
-+		do_gettimeofday(&kerneltimeval);
-+		packet_local_time = kerneltimeval.tv_sec;
-+	}
-+	else
-+		packet_local_time = skb->stamp.tv_sec;
-+
-+	/* First we make sure we are in the date start-stop boundaries */
-+	if ((packet_local_time < info->date_start) || (packet_local_time > info->date_stop))
-+		return 0; /* We are outside the date boundaries */
-+
-+	/* Transform the timestamp of the packet, in a human readable form */
-+	localtime(&packet_local_time, &currenttime);
-+
-+	/* check if we match this timestamp, we start by the days... */
-+	if ((days_of_week[currenttime.tm_wday] & info->days_match) != days_of_week[currenttime.tm_wday])
-+		return 0; /* the day doesn't match */
-+
-+	/* ... check the time now */
-+	packet_time = (currenttime.tm_hour * 60) + currenttime.tm_min;
-+	if ((packet_time < info->time_start) || (packet_time > info->time_stop))
-+		return 0;
-+
-+	/* here we match ! */
-+	return 1;
-+}
-+
-+static int
-+checkentry(const char *tablename,
-+           const struct ipt_ip *ip,
-+           void *matchinfo,
-+           unsigned int matchsize,
-+           unsigned int hook_mask)
-+{
-+	struct ipt_time_info *info = matchinfo;   /* match info for rule */
-+
-+	/* First, check that we are in the correct hooks */
-+	if (hook_mask
-+            & ~((1 << NF_IP_PRE_ROUTING) | (1 << NF_IP_LOCAL_IN) | (1 << NF_IP_FORWARD) | (1 << NF_IP_LOCAL_OUT)))
-+	{
-+		printk("ipt_time: error, only valid for PRE_ROUTING, LOCAL_IN, FORWARD and OUTPUT)\n");
-+		return 0;
-+	}
-+	/* we use the kerneltime if we are in forward or output */
-+	info->kerneltime = 1;
-+	if (hook_mask & ~((1 << NF_IP_FORWARD) | (1 << NF_IP_LOCAL_OUT))) 
-+		/* we use the skb time */
-+		info->kerneltime = 0;
-+
-+	/* Check the size */
-+	if (matchsize != IPT_ALIGN(sizeof(struct ipt_time_info)))
-+		return 0;
-+	/* Now check the coherence of the data ... */
-+	if ((info->time_start > 1439) ||        /* 23*60+59 = 1439*/
-+	    (info->time_stop  > 1439))
-+	{
-+		printk(KERN_WARNING "ipt_time: invalid argument\n");
-+		return 0;
-+	}
-+
-+	return 1;
-+}
-+
-+static struct ipt_match time_match = {
-+	.name		= "time",
-+	.match		= match,
-+	.checkentry	= checkentry,
-+	.me		= THIS_MODULE,
-+};
-+
-+static int __init init(void)
-+{
-+	printk("ipt_time loading\n");
-+	return ipt_register_match(&time_match);
-+}
-+
-+static void __exit fini(void)
-+{
-+	ipt_unregister_match(&time_match);
-+	printk("ipt_time unloaded\n");
-+}
-+
-+module_init(init);
-+module_exit(fini);
-+
-+
-+/* The part below is borowed and modified from dietlibc */
-+
-+/* seconds per day */
-+#define SPD 24*60*60
-+
-+void
-+localtime(const time_t *timepr, struct tm *r) {
-+	time_t i;
-+	time_t timep;
-+	extern struct timezone sys_tz;
-+	const unsigned int __spm[12] =
-+		{ 0,
-+		  (31),
-+		  (31+28),
-+		  (31+28+31),
-+		  (31+28+31+30),
-+		  (31+28+31+30+31),
-+		  (31+28+31+30+31+30),
-+		  (31+28+31+30+31+30+31),
-+		  (31+28+31+30+31+30+31+31),
-+		  (31+28+31+30+31+30+31+31+30),
-+		  (31+28+31+30+31+30+31+31+30+31),
-+		  (31+28+31+30+31+30+31+31+30+31+30),
-+		};
-+	register time_t work;
-+
-+	timep = (*timepr) - (sys_tz.tz_minuteswest * 60);
-+	work=timep%(SPD);
-+	r->tm_sec=work%60; work/=60;
-+	r->tm_min=work%60; r->tm_hour=work/60;
-+	work=timep/(SPD);
-+	r->tm_wday=(4+work)%7;
-+	for (i=1970; ; ++i) {
-+		register time_t k= (!(i%4) && ((i%100) || !(i%400)))?366:365;
-+		if (work>k)
-+			work-=k;
-+		else
-+			break;
-+	}
-+	r->tm_year=i-1900;
-+	for (i=11; i && __spm[i]>work; --i) ;
-+	r->tm_mon=i;
-+	r->tm_mday=work-__spm[i]+1;
-+}
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -111,6 +111,7 @@ obj-$(CONFIG_IP_NF_MATCH_PKTTYPE) += ipt
- obj-$(CONFIG_IP_NF_MATCH_MULTIPORT) += ipt_multiport.o
- obj-$(CONFIG_IP_NF_MATCH_OWNER) += ipt_owner.o
- obj-$(CONFIG_IP_NF_MATCH_TOS) += ipt_tos.o
-+obj-$(CONFIG_IP_NF_MATCH_TIME) += ipt_time.o
- obj-$(CONFIG_IP_NF_MATCH_CONDITION) += ipt_condition.o
- 
- obj-$(CONFIG_IP_NF_MATCH_RECENT) += ipt_recent.o
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_time.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_time.h
-@@ -0,0 +1,15 @@
-+#ifndef __ipt_time_h_included__
-+#define __ipt_time_h_included__
-+
-+
-+struct ipt_time_info {
-+	u_int8_t  days_match;   /* 1 bit per day. -SMTWTFS                      */
-+	u_int16_t time_start;   /* 0 < time_start < 23*60+59 = 1439             */
-+	u_int16_t time_stop;    /* 0:0 < time_stat < 23:59                      */
-+	u_int8_t  kerneltime;   /* ignore skb time (and use kerneltime) or not. */
-+	time_t    date_start;
-+	time_t    date_stop;
-+};
-+
-+
-+#endif /* __ipt_time_h_included__ */
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/620-netfilter_iprange.patch	2009-04-12 13:27:08.000000000 -0400
+++ kamikaze-8.09-new/target/linux/generic-2.4/patches/620-netfilter_iprange.patch	2009-04-12 14:58:37.000000000 -0400
@@ -1,22 +1,3 @@
-Index: linux-2.4.35.4/Documentation/Configure.help
-===================================================================
---- linux-2.4.35.4.orig/Documentation/Configure.help
-+++ linux-2.4.35.4/Documentation/Configure.help
-@@ -2986,6 +2986,14 @@ CONFIG_IP_NF_MATCH_TOS
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+iprange match support
-+CONFIG_IP_NF_MATCH_IPRANGE
-+  This option makes possible to match IP addresses against
-+  IP address ranges.
-+
-+  If you want to compile it as a module, say M here and read
-+  <file:Documentation/modules.txt>.  If unsure, say `N'.
-+
- Condition variable match support
- CONFIG_IP_NF_MATCH_CONDITION
-   This option allows you to match firewall rules against condition
 Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_iprange.h
 ===================================================================
 --- /dev/null
@@ -45,18 +26,6 @@
 +};
 +
 +#endif /* _IPT_IPRANGE_H */
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -27,6 +27,7 @@ tristate 'IP tables support (required fo
- if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; then
- # The simple matches.
-   dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
-+  dep_tristate '  IP range match support' CONFIG_IP_NF_MATCH_IPRANGE $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  quota match support' CONFIG_IP_NF_MATCH_QUOTA $CONFIG_IP_NF_IPTABLES
- 
-   dep_tristate '  IP set support' CONFIG_IP_NF_SET $CONFIG_IP_NF_IPTABLES
 Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_iprange.c
 ===================================================================
 --- /dev/null
@@ -163,15 +132,24 @@
 +
 +module_init(init);
 +module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -90,6 +90,7 @@ obj-$(CONFIG_IP_NF_NAT) += iptable_nat.o
+--- linux.orig/net/ipv4/netfilter/Config.in	2009-04-12 14:41:33.000000000 -0400
++++ linux.new/net/ipv4/netfilter/Config.in	2009-04-12 14:52:17.000000000 -0400
+@@ -22,6 +22,7 @@
+ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; then
+ # The simple matches.
+   dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
++  dep_tristate '  IP range match support' CONFIG_IP_NF_MATCH_IPRANGE $CONFIG_IP_NF_IPTABLES
+ 
+   dep_tristate '  IP set support' CONFIG_IP_NF_SET $CONFIG_IP_NF_IPTABLES
+   if [ "$CONFIG_IP_NF_SET" != "n" ]; then
+--- linux.orig/net/ipv4/netfilter/Makefile	2009-04-12 14:41:33.000000000 -0400
++++ linux.new/net/ipv4/netfilter/Makefile	2009-04-12 14:53:19.000000000 -0400
+@@ -65,6 +65,7 @@
  # matches
  obj-$(CONFIG_IP_NF_MATCH_HELPER) += ipt_helper.o
  obj-$(CONFIG_IP_NF_MATCH_LIMIT) += ipt_limit.o
 +obj-$(CONFIG_IP_NF_MATCH_IPRANGE) += ipt_iprange.o
- obj-$(CONFIG_IP_NF_MATCH_QUOTA) += ipt_quota.o
  obj-$(CONFIG_IP_NF_MATCH_MARK) += ipt_mark.o
  obj-$(CONFIG_IP_NF_MATCH_SET) += ipt_set.o
+ obj-$(CONFIG_IP_NF_TARGET_SET) += ipt_SET.o
+
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/621-netfilter_random.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,327 +0,0 @@
-Index: linux-2.4.35.4/Documentation/Configure.help
-===================================================================
---- linux-2.4.35.4.orig/Documentation/Configure.help
-+++ linux-2.4.35.4/Documentation/Configure.help
-@@ -2914,6 +2914,15 @@ CONFIG_IP_NF_MATCH_MAC
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+Random match support
-+CONFIG_IP_NF_MATCH_RANDOM
-+  This option adds a `random' match,
-+  which allow you to match packets randomly
-+  following a given probability.
-+ 
-+  If you want to compile it as a module, say M here and read
-+  Documentation/modules.txt.  If unsure, say `N'.
-+
- Netfilter MARK match support
- CONFIG_IP_NF_MATCH_MARK
-   Netfilter mark matching allows you to match packets based on the
-@@ -3229,6 +3238,7 @@ CONFIG_IP_NF_MATCH_HELPER
-   If you want to compile it as a module, say M here and read
-   Documentation/modules.txt.  If unsure, say `Y'.
- 
-+
- TCPMSS match support
- CONFIG_IP_NF_MATCH_TCPMSS
-   This option adds a `tcpmss' match, which allows you to examine the
-@@ -3376,6 +3386,14 @@ CONFIG_IP6_NF_MATCH_MAC
-   If you want to compile it as a module, say M here and read
-   <file:Documentation/modules.txt>.  If unsure, say `N'.
- 
-+CONFIG_IP6_NF_MATCH_RANDOM
-+  This option adds a `random' match,
-+  which allow you to match packets randomly
-+  following a given probability.
-+ 
-+  If you want to compile it as a module, say M here and read
-+  Documentation/modules.txt.  If unsure, say `N'.
-+
- length match support
- CONFIG_IP6_NF_MATCH_LENGTH
-   This option allows you to match the length of a packet against a
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_random.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ipt_random.h
-@@ -0,0 +1,11 @@
-+#ifndef _IPT_RAND_H
-+#define _IPT_RAND_H
-+
-+#include <linux/param.h>
-+#include <linux/types.h>
-+
-+struct ipt_rand_info {
-+	u_int8_t average;
-+};
-+
-+#endif /*_IPT_RAND_H*/
-Index: linux-2.4.35.4/include/linux/netfilter_ipv6/ip6t_random.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv6/ip6t_random.h
-@@ -0,0 +1,11 @@
-+#ifndef _IP6T_RAND_H
-+#define _IP6T_RAND_H
-+
-+#include <linux/param.h>
-+#include <linux/types.h>
-+
-+struct ip6t_rand_info {
-+	u_int8_t average;
-+};
-+
-+#endif /*_IP6T_RAND_H*/
-Index: linux-2.4.35.4/net/ipv4/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv4/netfilter/Config.in
-@@ -48,6 +48,7 @@ if [ "$CONFIG_IP_NF_IPTABLES" != "n" ]; 
-   dep_tristate '  netfilter MARK match support' CONFIG_IP_NF_MATCH_MARK $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  Multiple port match support' CONFIG_IP_NF_MATCH_MULTIPORT $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  TOS match support' CONFIG_IP_NF_MATCH_TOS $CONFIG_IP_NF_IPTABLES
-+  dep_tristate '  random match support' CONFIG_IP_NF_MATCH_RANDOM $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  TIME match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_TIME $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  condition match support' CONFIG_IP_NF_MATCH_CONDITION $CONFIG_IP_NF_IPTABLES
-   dep_tristate '  recent match support' CONFIG_IP_NF_MATCH_RECENT $CONFIG_IP_NF_IPTABLES
-Index: linux-2.4.35.4/net/ipv4/netfilter/ipt_random.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv4/netfilter/ipt_random.c
-@@ -0,0 +1,96 @@
-+/*
-+  This is a module which is used for a "random" match support.
-+  This file is distributed under the terms of the GNU General Public
-+  License (GPL). Copies of the GPL can be obtained from:
-+     ftp://prep.ai.mit.edu/pub/gnu/GPL
-+
-+  2001-10-14 Fabrice MARIE <fabrice@netfilter.org> : initial implementation.
-+*/
-+
-+#include <linux/module.h>
-+#include <linux/skbuff.h>
-+#include <linux/ip.h>
-+#include <linux/random.h>
-+#include <net/tcp.h>
-+#include <linux/spinlock.h>
-+#include <linux/netfilter_ipv4/ip_tables.h>
-+#include <linux/netfilter_ipv4/ipt_random.h>
-+
-+MODULE_LICENSE("GPL");
-+
-+static int
-+ipt_rand_match(const struct sk_buff *pskb,
-+	       const struct net_device *in,
-+	       const struct net_device *out,
-+	       const void *matchinfo,
-+	       int offset,
-+	       const void *hdr,
-+	       u_int16_t datalen,
-+	       int *hotdrop)
-+{
-+	/* Parameters from userspace */
-+	const struct ipt_rand_info *info = matchinfo;
-+	u_int8_t random_number;
-+
-+	/* get 1 random number from the kernel random number generation routine */
-+	get_random_bytes((void *)(&random_number), 1);
-+
-+	/* Do we match ? */
-+	if (random_number <= info->average)
-+		return 1;
-+	else
-+		return 0;
-+}
-+
-+static int
-+ipt_rand_checkentry(const char *tablename,
-+		   const struct ipt_ip *e,
-+		   void *matchinfo,
-+		   unsigned int matchsize,
-+		   unsigned int hook_mask)
-+{
-+	/* Parameters from userspace */
-+	const struct ipt_rand_info *info = matchinfo;
-+
-+	if (matchsize != IPT_ALIGN(sizeof(struct ipt_rand_info))) {
-+		printk("ipt_random: matchsize %u != %u\n", matchsize,
-+		       IPT_ALIGN(sizeof(struct ipt_rand_info)));
-+		return 0;
-+	}
-+
-+	/* must be  1 <= average % <= 99 */
-+	/* 1  x 2.55 = 2   */
-+	/* 99 x 2.55 = 252 */
-+	if ((info->average < 2) || (info->average > 252)) {
-+		printk("ipt_random:  invalid average %u\n", info->average);
-+		return 0;
-+	}
-+
-+	return 1;
-+}
-+
-+static struct ipt_match ipt_rand_reg = { 
-+	{NULL, NULL},
-+	"random",
-+	ipt_rand_match,
-+	ipt_rand_checkentry,
-+	NULL,
-+	THIS_MODULE };
-+
-+static int __init init(void)
-+{
-+	if (ipt_register_match(&ipt_rand_reg))
-+		return -EINVAL;
-+
-+	printk("ipt_random match loaded\n");
-+	return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+	ipt_unregister_match(&ipt_rand_reg);
-+	printk("ipt_random match unloaded\n");
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv4/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv4/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv4/netfilter/Makefile
-@@ -115,6 +115,8 @@ obj-$(CONFIG_IP_NF_MATCH_TOS) += ipt_tos
- obj-$(CONFIG_IP_NF_MATCH_TIME) += ipt_time.o
- obj-$(CONFIG_IP_NF_MATCH_CONDITION) += ipt_condition.o
- 
-+obj-$(CONFIG_IP_NF_MATCH_RANDOM) += ipt_random.o
-+
- obj-$(CONFIG_IP_NF_MATCH_RECENT) += ipt_recent.o
- 
- obj-$(CONFIG_IP_NF_MATCH_ECN) += ipt_ecn.o
-Index: linux-2.4.35.4/net/ipv6/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv6/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv6/netfilter/Config.in
-@@ -19,6 +19,7 @@ if [ "$CONFIG_IP6_NF_IPTABLES" != "n" ];
-   dep_tristate '  limit match support' CONFIG_IP6_NF_MATCH_LIMIT $CONFIG_IP6_NF_IPTABLES
-   dep_tristate '  condition match support' CONFIG_IP6_NF_MATCH_CONDITION $CONFIG_IP6_NF_IPTABLES
-   dep_tristate '  MAC address match support' CONFIG_IP6_NF_MATCH_MAC $CONFIG_IP6_NF_IPTABLES
-+  dep_tristate '  Random match support' CONFIG_IP6_NF_MATCH_RANDOM $CONFIG_IP6_NF_IPTABLES
-   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-     dep_tristate '  Routing header match support (EXPERIMENTAL)' CONFIG_IP6_NF_MATCH_RT $CONFIG_IP6_NF_IPTABLES
-   fi
-Index: linux-2.4.35.4/net/ipv6/netfilter/ip6t_random.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv6/netfilter/ip6t_random.c
-@@ -0,0 +1,97 @@
-+/*
-+  This is a module which is used for a "random" match support.
-+  This file is distributed under the terms of the GNU General Public
-+  License (GPL). Copies of the GPL can be obtained from:
-+     ftp://prep.ai.mit.edu/pub/gnu/GPL
-+
-+  2001-10-14 Fabrice MARIE <fabrice@netfilter.org> : initial implementation.
-+  2003-04-30 Maciej Soltysiak <solt@dns.toxicfilms.tv> : IPv6 Port
-+*/
-+
-+#include <linux/module.h>
-+#include <linux/skbuff.h>
-+#include <linux/ip.h>
-+#include <linux/random.h>
-+#include <net/tcp.h>
-+#include <linux/spinlock.h>
-+#include <linux/netfilter_ipv6/ip6_tables.h>
-+#include <linux/netfilter_ipv6/ip6t_random.h>
-+
-+MODULE_LICENSE("GPL");
-+
-+static int
-+ip6t_rand_match(const struct sk_buff *pskb,
-+	       const struct net_device *in,
-+	       const struct net_device *out,
-+	       const void *matchinfo,
-+	       int offset,
-+	       const void *hdr,
-+	       u_int16_t datalen,
-+	       int *hotdrop)
-+{
-+	/* Parameters from userspace */
-+	const struct ip6t_rand_info *info = matchinfo;
-+	u_int8_t random_number;
-+
-+	/* get 1 random number from the kernel random number generation routine */
-+	get_random_bytes((void *)(&random_number), 1);
-+
-+	/* Do we match ? */
-+	if (random_number <= info->average)
-+		return 1;
-+	else
-+		return 0;
-+}
-+
-+static int
-+ip6t_rand_checkentry(const char *tablename,
-+		   const struct ip6t_ip6 *e,
-+		   void *matchinfo,
-+		   unsigned int matchsize,
-+		   unsigned int hook_mask)
-+{
-+	/* Parameters from userspace */
-+	const struct ip6t_rand_info *info = matchinfo;
-+
-+	if (matchsize != IP6T_ALIGN(sizeof(struct ip6t_rand_info))) {
-+		printk("ip6t_random: matchsize %u != %u\n", matchsize,
-+		       IP6T_ALIGN(sizeof(struct ip6t_rand_info)));
-+		return 0;
-+	}
-+
-+	/* must be  1 <= average % <= 99 */
-+	/* 1  x 2.55 = 2   */
-+	/* 99 x 2.55 = 252 */
-+	if ((info->average < 2) || (info->average > 252)) {
-+		printk("ip6t_random:  invalid average %u\n", info->average);
-+		return 0;
-+	}
-+
-+	return 1;
-+}
-+
-+static struct ip6t_match ip6t_rand_reg = { 
-+	{NULL, NULL},
-+	"random",
-+	ip6t_rand_match,
-+	ip6t_rand_checkentry,
-+	NULL,
-+	THIS_MODULE };
-+
-+static int __init init(void)
-+{
-+	if (ip6t_register_match(&ip6t_rand_reg))
-+		return -EINVAL;
-+
-+	printk("ip6t_random match loaded\n");
-+	return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+	ip6t_unregister_match(&ip6t_rand_reg);
-+	printk("ip6t_random match unloaded\n");
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/net/ipv6/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv6/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv6/netfilter/Makefile
-@@ -32,6 +32,7 @@ obj-$(CONFIG_IP6_NF_TARGET_MARK) += ip6t
- obj-$(CONFIG_IP6_NF_TARGET_IMQ) += ip6t_IMQ.o
- obj-$(CONFIG_IP6_NF_QUEUE) += ip6_queue.o
- obj-$(CONFIG_IP6_NF_TARGET_LOG) += ip6t_LOG.o
-+obj-$(CONFIG_IP6_NF_MATCH_RANDOM) += ip6t_random.o
- obj-$(CONFIG_IP6_NF_MATCH_HL) += ip6t_hl.o
- 
- include $(TOPDIR)/Rules.make
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/621-tc_esfq.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,748 +0,0 @@
-Index: linux-2.4.35.4/Documentation/Configure.help
-===================================================================
---- linux-2.4.35.4.orig/Documentation/Configure.help
-+++ linux-2.4.35.4/Documentation/Configure.help
-@@ -11153,6 +11153,24 @@ CONFIG_NET_SCH_HFSC
-   whenever you want).  If you want to compile it as a module, say M
-   here and read <file:Documentation/modules.txt>.
- 
-+ESFQ queue
-+CONFIG_NET_SCH_ESFQ
-+  Say Y here if you want to use the Stochastic Fairness Queueing (SFQ)
-+  packet scheduling algorithm for some of your network devices or as a
-+  leaf discipline for the CBQ scheduling algorithm (see the top of
-+  <file:net/sched/sch_esfq.c> for details and references about the SFQ
-+  algorithm).
-+
-+  This is an enchanced SFQ version which allows you to control the
-+  hardcoded values in the SFQ scheduler: queue depth, hash table size,
-+  queues limit. Also adds control to the hash function used to identify
-+  packet flows. Hash by src or dst ip and original sfq hash.
-+
-+  This code is also available as a module called sch_esfq.o ( = code
-+  which can be inserted in and removed from the running kernel
-+  whenever you want). If you want to compile it as a module, say M
-+  here and read <file:Documentation/modules.txt>.
-+
- CSZ packet scheduler
- CONFIG_NET_SCH_CSZ
-   Say Y here if you want to use the Clark-Shenker-Zhang (CSZ) packet
-Index: linux-2.4.35.4/include/linux/pkt_sched.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/pkt_sched.h
-+++ linux-2.4.35.4/include/linux/pkt_sched.h
-@@ -173,8 +173,36 @@ struct tc_sfq_qopt
-  *
-  *	The only reason for this is efficiency, it is possible
-  *	to change these parameters in compile time.
-+ *
-+ *	If you need to play with these values use esfq instead.
-  */
- 
-+/* ESFQ section */
-+
-+enum
-+{
-+	/* traditional */
-+	TCA_SFQ_HASH_CLASSIC,
-+	TCA_SFQ_HASH_DST,
-+	TCA_SFQ_HASH_SRC,
-+	/* conntrack */
-+	TCA_SFQ_HASH_CTORIGDST,
-+	TCA_SFQ_HASH_CTORIGSRC,
-+	TCA_SFQ_HASH_CTREPLDST,
-+	TCA_SFQ_HASH_CTREPLSRC,
-+	TCA_SFQ_HASH_CTNATCHG,
-+};
-+
-+struct tc_esfq_qopt
-+{
-+	unsigned	quantum;	/* Bytes per round allocated to flow */
-+	int		perturb_period; /* Period of hash perturbation */
-+	__u32		limit;		/* Maximal packets in queue */
-+	unsigned	divisor;	/* Hash divisor  */
-+	unsigned	flows;		/* Maximal number of flows  */
-+	unsigned	hash_kind;	/* Hash function to use for flow identification */
-+};
-+
- /* RED section */
- 
- enum
-Index: linux-2.4.35.4/net/sched/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/sched/Config.in
-+++ linux-2.4.35.4/net/sched/Config.in
-@@ -12,6 +12,7 @@ fi
- tristate '  The simplest PRIO pseudoscheduler' CONFIG_NET_SCH_PRIO
- tristate '  RED queue' CONFIG_NET_SCH_RED
- tristate '  SFQ queue' CONFIG_NET_SCH_SFQ
-+tristate '  ESFQ queue' CONFIG_NET_SCH_ESFQ
- tristate '  TEQL queue' CONFIG_NET_SCH_TEQL
- tristate '  TBF queue' CONFIG_NET_SCH_TBF
- tristate '  GRED queue' CONFIG_NET_SCH_GRED
-Index: linux-2.4.35.4/net/sched/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/sched/Makefile
-+++ linux-2.4.35.4/net/sched/Makefile
-@@ -19,6 +19,7 @@ obj-$(CONFIG_NET_SCH_HPFQ)	+= sch_hpfq.o
- obj-$(CONFIG_NET_SCH_HFSC)	+= sch_hfsc.o
- obj-$(CONFIG_NET_SCH_HTB)	+= sch_htb.o
- obj-$(CONFIG_NET_SCH_SFQ)	+= sch_sfq.o
-+obj-$(CONFIG_NET_SCH_ESFQ)	+= sch_esfq.o
- obj-$(CONFIG_NET_SCH_RED)	+= sch_red.o
- obj-$(CONFIG_NET_SCH_TBF)	+= sch_tbf.o
- obj-$(CONFIG_NET_SCH_PRIO)	+= sch_prio.o
-Index: linux-2.4.35.4/net/sched/sch_esfq.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/sched/sch_esfq.c
-@@ -0,0 +1,649 @@
-+/*
-+ * net/sched/sch_esfq.c	Extended Stochastic Fairness Queueing discipline.
-+ *
-+ *		This program is free software; you can redistribute it and/or
-+ *		modify it under the terms of the GNU General Public License
-+ *		as published by the Free Software Foundation; either version
-+ *		2 of the License, or (at your option) any later version.
-+ *
-+ * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
-+ *
-+ * Changes:	Alexander Atanasov, <alex@ssi.bg>
-+ *		Added dynamic depth,limit,divisor,hash_kind options.
-+ *		Added dst and src hashes.
-+ *
-+ * 		Alexander Clouter, <alex@digriz.org.uk>
-+ *		Ported ESFQ to Linux 2.6.
-+ *
-+ * 		Corey Hickey, <bugfood-c@fatooh.org>
-+ *		Maintenance of the Linux 2.6 port.
-+ *		Added fwmark hash (thanks to Robert Kurjata).
-+ *		Added usage of jhash.
-+ *		
-+ */
-+
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <asm/uaccess.h>
-+#include <asm/system.h>
-+#include <linux/bitops.h>
-+#include <linux/types.h>
-+#include <linux/kernel.h>
-+#include <linux/sched.h> 
-+#include <linux/string.h>
-+#include <linux/mm.h>
-+#include <linux/socket.h>
-+#include <linux/sockios.h>
-+#include <linux/in.h>
-+#include <linux/errno.h>
-+#include <linux/interrupt.h>
-+#include <linux/if_ether.h>
-+#include <linux/inet.h>
-+#include <linux/netdevice.h>
-+#include <linux/etherdevice.h>
-+#include <linux/notifier.h>
-+#include <linux/init.h>
-+#include <net/ip.h>
-+#include <net/route.h>
-+#include <linux/skbuff.h>
-+#include <net/sock.h>
-+#include <net/pkt_sched.h>
-+#include <linux/jhash.h>
-+
-+#define IPPROTO_DCCP 33
-+#define qdisc_priv(q)   ((void *)(q->data))
-+
-+#ifdef CONFIG_IP_NF_CONNTRACK
-+/* #include <net/netfilter/nf_conntrack.h> */
-+#include <linux/netfilter_ipv4/ip_conntrack.h>
-+#endif
-+
-+/*	Stochastic Fairness Queuing algorithm.
-+	For more comments look at sch_sfq.c.
-+	The difference is that you can change limit, depth,
-+	hash table size and choose alternate hash types.
-+	
-+	classic:	same as in sch_sfq.c
-+	dst:		destination IP address
-+	src:		source IP address
-+	ctorigdst:	original destination IP address
-+	ctorigsrc:	original source IP address
-+	ctrepldst:	reply destination IP address
-+	ctreplsrc:	reply source IP 
-+	ctnatchg:	use the address which changed via nat
-+	
-+*/
-+
-+
-+/* This type should contain at least SFQ_DEPTH*2 values */
-+typedef unsigned int esfq_index;
-+
-+struct esfq_head
-+{
-+	esfq_index	next;
-+	esfq_index	prev;
-+};
-+
-+struct esfq_sched_data
-+{
-+/* Parameters */
-+	int		perturb_period;
-+	unsigned	quantum;	/* Allotment per round: MUST BE >= MTU */
-+	int		limit;
-+	unsigned	depth;
-+	unsigned	hash_divisor;
-+	unsigned	hash_kind;
-+/* Variables */
-+	struct timer_list perturb_timer;
-+	int		perturbation;
-+	esfq_index	tail;		/* Index of current slot in round */
-+	esfq_index	max_depth;	/* Maximal depth */
-+
-+	esfq_index	*ht;			/* Hash table */
-+	esfq_index	*next;			/* Active slots link */
-+	short		*allot;			/* Current allotment per slot */
-+	unsigned short	*hash;			/* Hash value indexed by slots */
-+	struct sk_buff_head	*qs;		/* Slot queue */
-+	struct esfq_head	*dep;		/* Linked list of slots, indexed by depth */
-+	unsigned	dyn_min;	/* For dynamic divisor adjustment; minimum value seen */
-+	unsigned	dyn_max;	/*                                 maximum value seen */
-+	unsigned	dyn_range;	/*	        		   saved range */
-+};
-+
-+/* This contains the info we will hash. */
-+struct esfq_packet_info
-+{
-+	u32	proto;		/* protocol or port */
-+	u32	src;		/* source from packet header */
-+	u32	dst;		/* destination from packet header */
-+	u32	ctorigsrc;	/* original source from conntrack */
-+	u32	ctorigdst;	/* original destination from conntrack */
-+	u32	ctreplsrc;	/* reply source from conntrack */
-+	u32	ctrepldst;	/* reply destination from conntrack */
-+};
-+
-+static __inline__ unsigned esfq_jhash_1word(struct esfq_sched_data *q,u32 a)
-+{
-+	return jhash_1word(a, q->perturbation) & (q->hash_divisor-1);
-+}
-+
-+static __inline__ unsigned esfq_jhash_2words(struct esfq_sched_data *q, u32 a, u32 b)
-+{
-+	return jhash_2words(a, b, q->perturbation) & (q->hash_divisor-1);
-+}
-+
-+static __inline__ unsigned esfq_jhash_3words(struct esfq_sched_data *q, u32 a, u32 b, u32 c)
-+{
-+	return jhash_3words(a, b, c, q->perturbation) & (q->hash_divisor-1);
-+}
-+
-+
-+static unsigned esfq_hash(struct esfq_sched_data *q, struct sk_buff *skb)
-+{
-+	struct esfq_packet_info info;
-+#ifdef CONFIG_IP_NF_CONNTRACK
-+	enum ip_conntrack_info ctinfo;
-+	struct ip_conntrack *ct = ip_conntrack_get(skb, &ctinfo);
-+#endif
-+	
-+	switch (skb->protocol) {
-+	case __constant_htons(ETH_P_IP):
-+	{
-+		struct iphdr *iph = skb->nh.iph;
-+		info.dst = iph->daddr;
-+		info.src = iph->saddr;
-+		if (!(iph->frag_off&htons(IP_MF|IP_OFFSET)) &&
-+		    (iph->protocol == IPPROTO_TCP ||
-+		     iph->protocol == IPPROTO_UDP ||
-+		     iph->protocol == IPPROTO_SCTP ||
-+		     iph->protocol == IPPROTO_DCCP ||
-+		     iph->protocol == IPPROTO_ESP))
-+			info.proto = *(((u32*)iph) + iph->ihl);
-+		else
-+			info.proto = iph->protocol;
-+		break;
-+	}
-+	default:
-+		info.dst   = (u32)(unsigned long)skb->dst;
-+		info.src   = (u32)(unsigned long)skb->sk;
-+		info.proto = skb->protocol;
-+	}
-+
-+#ifdef CONFIG_IP_NF_CONNTRACK
-+	/* defaults if there is no conntrack info */
-+	info.ctorigsrc = info.src;
-+	info.ctorigdst = info.dst;
-+	info.ctreplsrc = info.dst;
-+	info.ctrepldst = info.src;
-+	/* collect conntrack info */
-+	IP_NF_ASSERT(ct);
-+	if (ct) {
-+		if (skb->protocol == __constant_htons(ETH_P_IP)) {
-+			info.ctorigsrc = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
-+			info.ctorigdst = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
-+			info.ctreplsrc = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.ip;
-+			info.ctrepldst = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
-+		}
-+	}
-+#endif
-+
-+	switch(q->hash_kind)
-+	{
-+	case TCA_SFQ_HASH_CLASSIC:
-+		return esfq_jhash_3words(q, info.dst, info.src, info.proto);
-+	case TCA_SFQ_HASH_DST:
-+		return esfq_jhash_1word(q, info.dst);
-+	case TCA_SFQ_HASH_SRC:
-+		return esfq_jhash_1word(q, info.src);
-+#ifdef CONFIG_IP_NF_CONNTRACK
-+	case TCA_SFQ_HASH_CTORIGDST:
-+		return esfq_jhash_1word(q, info.ctorigdst);
-+	case TCA_SFQ_HASH_CTORIGSRC:
-+		return esfq_jhash_1word(q, info.ctorigsrc);
-+	case TCA_SFQ_HASH_CTREPLDST:
-+		return esfq_jhash_1word(q, info.ctrepldst);
-+	case TCA_SFQ_HASH_CTREPLSRC:
-+		return esfq_jhash_1word(q, info.ctreplsrc);
-+	case TCA_SFQ_HASH_CTNATCHG:
-+	{
-+		if (info.ctorigdst == info.ctreplsrc)
-+			return esfq_jhash_1word(q, info.ctorigsrc);
-+		else
-+			return esfq_jhash_1word(q, info.ctreplsrc);
-+	}
-+#endif
-+	default:
-+		if (net_ratelimit())
-+			printk(KERN_WARNING "ESFQ: Unknown hash method. Falling back to classic.\n");
-+	}
-+	return esfq_jhash_3words(q, info.dst, info.src, info.proto);
-+}
-+
-+static inline void esfq_link(struct esfq_sched_data *q, esfq_index x)
-+{
-+	esfq_index p, n;
-+	int d = q->qs[x].qlen + q->depth;
-+
-+	p = d;
-+	n = q->dep[d].next;
-+	q->dep[x].next = n;
-+	q->dep[x].prev = p;
-+	q->dep[p].next = q->dep[n].prev = x;
-+}
-+
-+static inline void esfq_dec(struct esfq_sched_data *q, esfq_index x)
-+{
-+	esfq_index p, n;
-+
-+	n = q->dep[x].next;
-+	p = q->dep[x].prev;
-+	q->dep[p].next = n;
-+	q->dep[n].prev = p;
-+
-+	if (n == p && q->max_depth == q->qs[x].qlen + 1)
-+		q->max_depth--;
-+
-+	esfq_link(q, x);
-+}
-+
-+static inline void esfq_inc(struct esfq_sched_data *q, esfq_index x)
-+{
-+	esfq_index p, n;
-+	int d;
-+
-+	n = q->dep[x].next;
-+	p = q->dep[x].prev;
-+	q->dep[p].next = n;
-+	q->dep[n].prev = p;
-+	d = q->qs[x].qlen;
-+	if (q->max_depth < d)
-+		q->max_depth = d;
-+
-+	esfq_link(q, x);
-+}
-+
-+static unsigned int esfq_drop(struct Qdisc *sch)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	esfq_index d = q->max_depth;
-+	struct sk_buff *skb;
-+	unsigned int len;
-+
-+	/* Queue is full! Find the longest slot and
-+	   drop a packet from it */
-+
-+	if (d > 1) {
-+		esfq_index x = q->dep[d+q->depth].next;
-+		skb = q->qs[x].prev;
-+		len = skb->len;
-+		__skb_unlink(skb, &q->qs[x]);
-+		kfree_skb(skb);
-+		esfq_dec(q, x);
-+		sch->q.qlen--;
-+		sch->stats.drops++;
-+		sch->stats.backlog -= len;
-+		return len;
-+	}
-+
-+	if (d == 1) {
-+		/* It is difficult to believe, but ALL THE SLOTS HAVE LENGTH 1. */
-+		d = q->next[q->tail];
-+		q->next[q->tail] = q->next[d];
-+		q->allot[q->next[d]] += q->quantum;
-+		skb = q->qs[d].prev;
-+		len = skb->len;
-+		__skb_unlink(skb, &q->qs[d]);
-+		kfree_skb(skb);
-+		esfq_dec(q, d);
-+		sch->q.qlen--;
-+		q->ht[q->hash[d]] = q->depth;
-+		sch->stats.drops++;
-+		sch->stats.backlog -= len;
-+		return len;
-+	}
-+
-+	return 0;
-+}
-+
-+static int
-+esfq_enqueue(struct sk_buff *skb, struct Qdisc* sch)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	unsigned hash = esfq_hash(q, skb);
-+	unsigned depth = q->depth;
-+	esfq_index x;
-+
-+	x = q->ht[hash];
-+	if (x == depth) {
-+		q->ht[hash] = x = q->dep[depth].next;
-+		q->hash[x] = hash;
-+	}
-+	sch->stats.backlog += skb->len;
-+	__skb_queue_tail(&q->qs[x], skb);
-+	esfq_inc(q, x);
-+	if (q->qs[x].qlen == 1) {		/* The flow is new */
-+		if (q->tail == depth) {	/* It is the first flow */
-+			q->tail = x;
-+			q->next[x] = x;
-+			q->allot[x] = q->quantum;
-+		} else {
-+			q->next[x] = q->next[q->tail];
-+			q->next[q->tail] = x;
-+			q->tail = x;
-+		}
-+	}
-+	if (++sch->q.qlen < q->limit-1) {
-+		sch->stats.bytes += skb->len;
-+		sch->stats.packets++;
-+		return 0;
-+	}
-+
-+	esfq_drop(sch);
-+	return NET_XMIT_CN;
-+}
-+
-+static int
-+esfq_requeue(struct sk_buff *skb, struct Qdisc* sch)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	unsigned hash = esfq_hash(q, skb);
-+	unsigned depth = q->depth;
-+	esfq_index x;
-+
-+	x = q->ht[hash];
-+	if (x == depth) {
-+		q->ht[hash] = x = q->dep[depth].next;
-+		q->hash[x] = hash;
-+	}
-+	sch->stats.backlog += skb->len;
-+	__skb_queue_head(&q->qs[x], skb);
-+	esfq_inc(q, x);
-+	if (q->qs[x].qlen == 1) {		/* The flow is new */
-+		if (q->tail == depth) {	/* It is the first flow */
-+			q->tail = x;
-+			q->next[x] = x;
-+			q->allot[x] = q->quantum;
-+		} else {
-+			q->next[x] = q->next[q->tail];
-+			q->next[q->tail] = x;
-+			q->tail = x;
-+		}
-+	}
-+	if (++sch->q.qlen < q->limit - 1) {
-+		return 0;
-+	}
-+
-+	sch->stats.drops++;
-+	esfq_drop(sch);
-+	return NET_XMIT_CN;
-+}
-+
-+
-+
-+
-+static struct sk_buff *
-+esfq_dequeue(struct Qdisc* sch)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	struct sk_buff *skb;
-+	unsigned depth = q->depth;
-+	esfq_index a, old_a;
-+
-+	/* No active slots */
-+	if (q->tail == depth)
-+		return NULL;
-+	
-+	a = old_a = q->next[q->tail];
-+	
-+	/* Grab packet */
-+	skb = __skb_dequeue(&q->qs[a]);
-+	esfq_dec(q, a);
-+	sch->q.qlen--;
-+	sch->stats.backlog -= skb->len;
-+	
-+	/* Is the slot empty? */
-+	if (q->qs[a].qlen == 0) {
-+		q->ht[q->hash[a]] = depth;
-+		a = q->next[a];
-+		if (a == old_a) {
-+			q->tail = depth;
-+			return skb;
-+		}
-+		q->next[q->tail] = a;
-+		q->allot[a] += q->quantum;
-+	} else if ((q->allot[a] -= skb->len) <= 0) {
-+		q->tail = a;
-+		a = q->next[a];
-+		q->allot[a] += q->quantum;
-+	}
-+	
-+	return skb;
-+}
-+
-+static void
-+esfq_reset(struct Qdisc* sch)
-+{
-+	struct sk_buff *skb;
-+
-+	while ((skb = esfq_dequeue(sch)) != NULL)
-+		kfree_skb(skb);
-+}
-+
-+static void esfq_perturbation(unsigned long arg)
-+{
-+	struct Qdisc *sch = (struct Qdisc*)arg;
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+
-+	q->perturbation = net_random()&0x1F;
-+
-+	if (q->perturb_period) {
-+		q->perturb_timer.expires = jiffies + q->perturb_period;
-+		add_timer(&q->perturb_timer);
-+	}
-+}
-+
-+static int esfq_change(struct Qdisc *sch, struct rtattr *opt)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	struct tc_esfq_qopt *ctl = RTA_DATA(opt);
-+	int old_perturb = q->perturb_period;
-+	
-+	if (opt->rta_len < RTA_LENGTH(sizeof(*ctl)))
-+		return -EINVAL;
-+	
-+	sch_tree_lock(sch);
-+	q->quantum = ctl->quantum ? : psched_mtu(sch->dev);
-+	q->perturb_period = ctl->perturb_period*HZ;
-+//	q->hash_divisor = ctl->divisor;
-+//	q->tail = q->limit = q->depth = ctl->flows;
-+	
-+	if (ctl->limit)
-+		q->limit = min_t(u32, ctl->limit, q->depth);
-+	
-+	if (ctl->hash_kind) {
-+		q->hash_kind = ctl->hash_kind;
-+		if (q->hash_kind != TCA_SFQ_HASH_CLASSIC)
-+			q->perturb_period = 0;
-+	}
-+	
-+	// is sch_tree_lock enough to do this ?
-+	while (sch->q.qlen >= q->limit-1)
-+		esfq_drop(sch);
-+	
-+	if (old_perturb)
-+		del_timer(&q->perturb_timer);
-+	if (q->perturb_period) {
-+		q->perturb_timer.expires = jiffies + q->perturb_period;
-+		add_timer(&q->perturb_timer);
-+	} else {
-+		q->perturbation = 0;
-+	}
-+	sch_tree_unlock(sch);
-+	return 0;
-+}
-+
-+static int esfq_init(struct Qdisc *sch, struct rtattr *opt)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	struct tc_esfq_qopt *ctl;
-+	esfq_index p = ~0U/2;
-+	int i;
-+	
-+	if (opt && opt->rta_len < RTA_LENGTH(sizeof(*ctl)))
-+		return -EINVAL;
-+
-+	init_timer(&q->perturb_timer);
-+	q->perturb_timer.data = (unsigned long)sch;
-+	q->perturb_timer.function = esfq_perturbation;
-+	q->perturbation = 0;
-+	q->hash_kind = TCA_SFQ_HASH_CLASSIC;
-+	q->max_depth = 0;
-+	q->dyn_min = ~0U; /* maximum value for this type */
-+	q->dyn_max = 0;  /* dyn_min/dyn_max will be set properly upon first packet */
-+	if (opt == NULL) {
-+		q->quantum = psched_mtu(sch->dev);
-+		q->perturb_period = 0;
-+		q->hash_divisor = 1024;
-+		q->tail = q->limit = q->depth = 128;
-+		
-+	} else {
-+		ctl = RTA_DATA(opt);
-+		q->quantum = ctl->quantum ? : psched_mtu(sch->dev);
-+		q->perturb_period = ctl->perturb_period*HZ;
-+		q->hash_divisor = ctl->divisor ? : 1024;
-+		q->tail = q->limit = q->depth = ctl->flows ? : 128;
-+		
-+		if ( q->depth > p - 1 )
-+			return -EINVAL;
-+		
-+		if (ctl->limit)
-+			q->limit = min_t(u32, ctl->limit, q->depth);
-+		
-+		if (ctl->hash_kind) {
-+			q->hash_kind = ctl->hash_kind;
-+		}
-+		
-+		if (q->perturb_period) {
-+			q->perturb_timer.expires = jiffies + q->perturb_period;
-+			add_timer(&q->perturb_timer);
-+		}
-+	}
-+	
-+	q->ht = kmalloc(q->hash_divisor*sizeof(esfq_index), GFP_KERNEL);
-+	if (!q->ht)
-+		goto err_case;
-+		
-+	q->dep = kmalloc((1+q->depth*2)*sizeof(struct esfq_head), GFP_KERNEL);
-+	if (!q->dep)
-+		goto err_case;
-+	q->next = kmalloc(q->depth*sizeof(esfq_index), GFP_KERNEL);
-+	if (!q->next)
-+		goto err_case;
-+	
-+	q->allot = kmalloc(q->depth*sizeof(short), GFP_KERNEL);
-+	if (!q->allot)
-+		goto err_case;
-+	q->hash = kmalloc(q->depth*sizeof(unsigned short), GFP_KERNEL);
-+	if (!q->hash)
-+		goto err_case;
-+	q->qs = kmalloc(q->depth*sizeof(struct sk_buff_head), GFP_KERNEL);
-+	if (!q->qs)
-+		goto err_case;
-+	
-+	for (i=0; i< q->hash_divisor; i++)
-+		q->ht[i] = q->depth;
-+	for (i=0; i<q->depth; i++) {
-+		skb_queue_head_init(&q->qs[i]);
-+		q->dep[i+q->depth].next = i+q->depth;
-+		q->dep[i+q->depth].prev = i+q->depth;
-+	}
-+	
-+	for (i=0; i<q->depth; i++)
-+		esfq_link(q, i);
-+	return 0;
-+err_case:
-+	del_timer(&q->perturb_timer);
-+	if (q->ht)
-+		kfree(q->ht);
-+	if (q->dep)
-+		kfree(q->dep);
-+	if (q->next)
-+		kfree(q->next);
-+	if (q->allot)
-+		kfree(q->allot);
-+	if (q->hash)
-+		kfree(q->hash);
-+	if (q->qs)
-+		kfree(q->qs);
-+	return -ENOBUFS;
-+}
-+
-+static void esfq_destroy(struct Qdisc *sch)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	del_timer(&q->perturb_timer);
-+	if(q->ht)
-+		kfree(q->ht);
-+	if(q->dep)
-+		kfree(q->dep);
-+	if(q->next)
-+		kfree(q->next);
-+	if(q->allot)
-+		kfree(q->allot);
-+	if(q->hash)
-+		kfree(q->hash);
-+	if(q->qs)
-+		kfree(q->qs);
-+}
-+
-+static int esfq_dump(struct Qdisc *sch, struct sk_buff *skb)
-+{
-+	struct esfq_sched_data *q = qdisc_priv(sch);
-+	unsigned char	 *b = skb->tail;
-+	struct tc_esfq_qopt opt;
-+
-+	opt.quantum = q->quantum;
-+	opt.perturb_period = q->perturb_period/HZ;
-+
-+	opt.limit = q->limit;
-+	opt.divisor = q->hash_divisor;
-+	opt.flows = q->depth;
-+	opt.hash_kind = q->hash_kind;
-+
-+	RTA_PUT(skb, TCA_OPTIONS, sizeof(opt), &opt);
-+
-+	return skb->len;
-+
-+rtattr_failure:
-+	skb_trim(skb, b - skb->data);
-+	return -1;
-+}
-+
-+static struct Qdisc_ops esfq_qdisc_ops =
-+{
-+	.next		=	NULL,
-+	.cl_ops		=	NULL,
-+	.id		=	"esfq",
-+	.priv_size	=	sizeof(struct esfq_sched_data),
-+	.enqueue	=	esfq_enqueue,
-+	.dequeue	=	esfq_dequeue,
-+	.requeue	=	esfq_requeue,
-+	.drop		=	esfq_drop,
-+	.init		=	esfq_init,
-+	.reset		=	esfq_reset,
-+	.destroy	=	esfq_destroy,
-+	.change		=	NULL, /* esfq_change - needs more work */
-+	.dump		=	esfq_dump,
-+};
-+
-+static int __init esfq_module_init(void)
-+{
-+	return register_qdisc(&esfq_qdisc_ops);
-+}
-+static void __exit esfq_module_exit(void) 
-+{
-+	unregister_qdisc(&esfq_qdisc_ops);
-+}
-+module_init(esfq_module_init)
-+module_exit(esfq_module_exit)
-+MODULE_LICENSE("GPL");
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/622-netfilter_ipset_porthash.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,39 +0,0 @@
-Index: linux-2.4.35.4/include/linux/netfilter_ipv4/ip_set_ipporthash.h
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/include/linux/netfilter_ipv4/ip_set_ipporthash.h
-@@ -0,0 +1,34 @@
-+#ifndef __IP_SET_IPPORTHASH_H
-+#define __IP_SET_IPPORTHASH_H
-+
-+#include <linux/netfilter_ipv4/ip_set.h>
-+
-+#define SETTYPE_NAME "ipporthash"
-+#define MAX_RANGE 0x0000FFFF
-+#define INVALID_PORT	(MAX_RANGE + 1)
-+
-+struct ip_set_ipporthash {
-+	ip_set_ip_t *members;		/* the ipporthash proper */
-+	uint32_t elements;		/* number of elements */
-+	uint32_t hashsize;		/* hash size */
-+	uint16_t probes;		/* max number of probes  */
-+	uint16_t resize;		/* resize factor in percent */
-+	ip_set_ip_t first_ip;		/* host byte order, included in range */
-+	ip_set_ip_t last_ip;		/* host byte order, included in range */
-+	void *initval[0];		/* initvals for jhash_1word */
-+};
-+
-+struct ip_set_req_ipporthash_create {
-+	uint32_t hashsize;
-+	uint16_t probes;
-+	uint16_t resize;
-+	ip_set_ip_t from;
-+	ip_set_ip_t to;
-+};
-+
-+struct ip_set_req_ipporthash {
-+	ip_set_ip_t ip;
-+	ip_set_ip_t port;
-+};
-+
-+#endif	/* __IP_SET_IPPORTHASH_H */
--- kamikaze-8.09-orig/target/linux/generic-2.4/patches/623-netfilter_ip6t_reject.patch	2009-04-12 13:27:08.000000000 -0400
+++ /dev/null	2009-04-11 02:34:07.000000000 -0400
@@ -1,360 +0,0 @@
-Index: linux-2.4.35.4/net/ipv6/netfilter/ip6t_REJECT.c
-===================================================================
---- /dev/null
-+++ linux-2.4.35.4/net/ipv6/netfilter/ip6t_REJECT.c
-@@ -0,0 +1,301 @@
-+/*
-+ * This is a module which is used for rejecting packets.
-+ * 	Added support for customized reject packets (Jozsef Kadlecsik).
-+ * Sun 12 Nov 2000
-+ * 	Port to IPv6 / ip6tables (Harald Welte <laforge@gnumonks.org>)
-+ */
-+#include <linux/config.h>
-+#include <linux/module.h>
-+#include <linux/skbuff.h>
-+#include <linux/icmpv6.h>
-+#include <net/tcp.h>
-+#include <net/ipv6.h>
-+#include <net/ip6_fib.h>
-+#include <net/ip6_route.h>
-+#include <linux/netfilter_ipv6/ip6_tables.h>
-+#include <linux/netfilter_ipv6/ip6t_REJECT.h>
-+
-+#if 1
-+#define DEBUGP printk
-+#else
-+#define DEBUGP(format, args...)
-+#endif
-+
-+#if 0
-+/* Send RST reply */
-+static void send_reset(struct sk_buff *oldskb)
-+{
-+	struct sk_buff *nskb;
-+	struct tcphdr *otcph, *tcph;
-+	struct rtable *rt;
-+	unsigned int otcplen;
-+	int needs_ack;
-+
-+	/* IP header checks: fragment, too short. */
-+	if (oldskb->nh.iph->frag_off & htons(IP_OFFSET)
-+	    || oldskb->len < (oldskb->nh.iph->ihl<<2) + sizeof(struct tcphdr))
-+		return;
-+
-+	otcph = (struct tcphdr *)((u_int32_t*)oldskb->nh.iph + oldskb->nh.iph->ihl);
-+	otcplen = oldskb->len - oldskb->nh.iph->ihl*4;
-+
-+	/* No RST for RST. */
-+	if (otcph->rst)
-+		return;
-+
-+	/* Check checksum. */
-+	if (tcp_v4_check(otcph, otcplen, oldskb->nh.iph->saddr,
-+			 oldskb->nh.iph->daddr,
-+			 csum_partial((char *)otcph, otcplen, 0)) != 0)
-+		return;
-+
-+	/* Copy skb (even if skb is about to be dropped, we can't just
-+           clone it because there may be other things, such as tcpdump,
-+           interested in it) */
-+	nskb = skb_copy(oldskb, GFP_ATOMIC);
-+	if (!nskb)
-+		return;
-+
-+	/* This packet will not be the same as the other: clear nf fields */
-+	nf_conntrack_put(nskb->nfct);
-+	nskb->nfct = NULL;
-+	nskb->nfcache = 0;
-+#ifdef CONFIG_NETFILTER_DEBUG
-+	nskb->nf_debug = 0;
-+#endif
-+
-+	tcph = (struct tcphdr *)((u_int32_t*)nskb->nh.iph + nskb->nh.iph->ihl);
-+
-+	nskb->nh.iph->daddr = xchg(&nskb->nh.iph->saddr, nskb->nh.iph->daddr);
-+	tcph->source = xchg(&tcph->dest, tcph->source);
-+
-+	/* Truncate to length (no data) */
-+	tcph->doff = sizeof(struct tcphdr)/4;
-+	skb_trim(nskb, nskb->nh.iph->ihl*4 + sizeof(struct tcphdr));
-+	nskb->nh.iph->tot_len = htons(nskb->len);
-+
-+	if (tcph->ack) {
-+		needs_ack = 0;
-+		tcph->seq = otcph->ack_seq;
-+		tcph->ack_seq = 0;
-+	} else {
-+		needs_ack = 1;
-+		tcph->ack_seq = htonl(ntohl(otcph->seq) + otcph->syn + otcph->fin
-+				      + otcplen - (otcph->doff<<2));
-+		tcph->seq = 0;
-+	}
-+
-+	/* Reset flags */
-+	((u_int8_t *)tcph)[13] = 0;
-+	tcph->rst = 1;
-+	tcph->ack = needs_ack;
-+
-+	tcph->window = 0;
-+	tcph->urg_ptr = 0;
-+
-+	/* Adjust TCP checksum */
-+	tcph->check = 0;
-+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr),
-+				   nskb->nh.iph->saddr,
-+				   nskb->nh.iph->daddr,
-+				   csum_partial((char *)tcph,
-+						sizeof(struct tcphdr), 0));
-+
-+	/* Adjust IP TTL, DF */
-+	nskb->nh.iph->ttl = MAXTTL;
-+	/* Set DF, id = 0 */
-+	nskb->nh.iph->frag_off = htons(IP_DF);
-+	nskb->nh.iph->id = 0;
-+
-+	/* Adjust IP checksum */
-+	nskb->nh.iph->check = 0;
-+	nskb->nh.iph->check = ip_fast_csum((unsigned char *)nskb->nh.iph,
-+					   nskb->nh.iph->ihl);
-+
-+	/* Routing */
-+	if (ip_route_output(&rt, nskb->nh.iph->daddr, nskb->nh.iph->saddr,
-+			    RT_TOS(nskb->nh.iph->tos) | RTO_CONN,
-+			    0) != 0)
-+		goto free_nskb;
-+
-+	dst_release(nskb->dst);
-+	nskb->dst = &rt->u.dst;
-+
-+	/* "Never happens" */
-+	if (nskb->len > nskb->dst->pmtu)
-+		goto free_nskb;
-+
-+	NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, nskb, NULL, nskb->dst->dev,
-+		ip_finish_output);
-+	return;
-+
-+ free_nskb:
-+	kfree_skb(nskb);
-+}
-+#endif
-+
-+static unsigned int reject6_target(struct sk_buff **pskb,
-+			   unsigned int hooknum,
-+			   const struct net_device *in,
-+			   const struct net_device *out,
-+			   const void *targinfo,
-+			   void *userinfo)
-+{
-+	const struct ip6t_reject_info *reject = targinfo;
-+	struct sk_buff *skb2 = NULL;
-+	struct rt6_info *rt6i;
-+	struct net_device odev;
-+
-+	if (!out) {
-+		skb2 = skb_clone(*pskb, GFP_ATOMIC);
-+		if (skb2 == NULL) {
-+			return NF_DROP;
-+		}
-+		dst_release(skb2->dst);
-+		skb2->dst = NULL;
-+
-+		rt6i = rt6_lookup(&skb2->nh.ipv6h->saddr, NULL, 0, 0);
-+		if (rt6i && rt6i->rt6i_dev) {
-+			skb2->dev = rt6i->rt6i_dev;
-+			rt6i = rt6_lookup(&skb2->nh.ipv6h->daddr, &skb2->nh.ipv6h->saddr, 0, 0);
-+		}
-+		memcpy(&odev, skb2->dev, sizeof(odev)); /* XXX 'out' has 'const' qualifier... */
-+	} else {
-+		memcpy(&odev, out, sizeof(odev));
-+	}
-+
-+	printk(KERN_DEBUG "%s: medium point\n", __FUNCTION__);
-+	/* WARNING: This code causes reentry within ip6tables.
-+	   This means that the ip6tables jump stack is now crap.  We
-+	   must return an absolute verdict. --RR */
-+	DEBUGP("REJECTv6: calling icmpv6_send\n");
-+    	switch (reject->with) {
-+    	case IP6T_ICMP6_NO_ROUTE:
-+    		icmpv6_send(*pskb, ICMPV6_DEST_UNREACH, ICMPV6_NOROUTE, 0, &odev);
-+    		break;
-+    	case IP6T_ICMP6_ADM_PROHIBITED:
-+    		icmpv6_send(*pskb, ICMPV6_DEST_UNREACH, ICMPV6_ADM_PROHIBITED, 0, &odev);
-+    		break;
-+    	case IP6T_ICMP6_NOT_NEIGHBOUR:
-+    		icmpv6_send(*pskb, ICMPV6_DEST_UNREACH, ICMPV6_NOT_NEIGHBOUR, 0, &odev);
-+    		break;
-+    	case IP6T_ICMP6_ADDR_UNREACH:
-+    		icmpv6_send(*pskb, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH, 0, &odev);
-+    		break;
-+    	case IP6T_ICMP6_PORT_UNREACH:
-+    		icmpv6_send(*pskb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0, &odev);
-+    		break;
-+#if 0
-+    	case IPT_ICMP_ECHOREPLY: {
-+		struct icmp6hdr *icmph  = (struct icmphdr *)
-+			((u_int32_t *)(*pskb)->nh.iph + (*pskb)->nh.iph->ihl);
-+		unsigned int datalen = (*pskb)->len - (*pskb)->nh.iph->ihl * 4;
-+
-+		/* Not non-head frags, or truncated */
-+		if (((ntohs((*pskb)->nh.iph->frag_off) & IP_OFFSET) == 0)
-+		    && datalen >= 4) {
-+			/* Usually I don't like cut & pasting code,
-+                           but dammit, my party is starting in 45
-+                           mins! --RR */
-+			struct icmp_bxm icmp_param;
-+
-+			icmp_param.icmph=*icmph;
-+			icmp_param.icmph.type=ICMP_ECHOREPLY;
-+			icmp_param.data_ptr=(icmph+1);
-+			icmp_param.data_len=datalen;
-+			icmp_reply(&icmp_param, *pskb);
-+		}
-+	}
-+	break;
-+	case IPT_TCP_RESET:
-+		send_reset(*pskb);
-+		break;
-+#endif
-+	default:
-+		printk(KERN_WARNING "REJECTv6: case %u not handled yet\n", reject->with);
-+		break;
-+	}
-+
-+	if (skb2) kfree_skb(skb2);
-+
-+	return NF_DROP;
-+}
-+
-+static inline int find_ping_match(const struct ip6t_entry_match *m)
-+{
-+	const struct ip6t_icmp *icmpinfo = (const struct ip6t_icmp *)m->data;
-+
-+	if (strcmp(m->u.kernel.match->name, "icmp6") == 0
-+	    && icmpinfo->type == ICMPV6_ECHO_REQUEST
-+	    && !(icmpinfo->invflags & IP6T_ICMP_INV))
-+		return 1;
-+
-+	return 0;
-+}
-+
-+static int check(const char *tablename,
-+		 const struct ip6t_entry *e,
-+		 void *targinfo,
-+		 unsigned int targinfosize,
-+		 unsigned int hook_mask)
-+{
-+ 	const struct ip6t_reject_info *rejinfo = targinfo;
-+
-+ 	if (targinfosize != IP6T_ALIGN(sizeof(struct ip6t_reject_info))) {
-+  		DEBUGP("REJECTv6: targinfosize %u != 0\n", targinfosize);
-+  		return 0;
-+  	}
-+
-+	/* Only allow these for packet filtering. */
-+	if (strcmp(tablename, "filter") != 0) {
-+		DEBUGP("REJECTv6: bad table `%s'.\n", tablename);
-+		return 0;
-+	}
-+	if ((hook_mask & ~((1 << NF_IP6_LOCAL_IN)
-+			   | (1 << NF_IP6_FORWARD)
-+			   | (1 << NF_IP6_LOCAL_OUT))) != 0) {
-+		DEBUGP("REJECTv6: bad hook mask %X\n", hook_mask);
-+		return 0;
-+	}
-+
-+	if (rejinfo->with == IP6T_ICMP6_ECHOREPLY) {
-+		/* Must specify that it's an ICMP ping packet. */
-+		if (e->ipv6.proto != IPPROTO_ICMPV6
-+		    || (e->ipv6.invflags & IP6T_INV_PROTO)) {
-+			DEBUGP("REJECTv6: ECHOREPLY illegal for non-icmp\n");
-+			return 0;
-+		}
-+		/* Must contain ICMP match. */
-+		if (IP6T_MATCH_ITERATE(e, find_ping_match) == 0) {
-+			DEBUGP("REJECTv6: ECHOREPLY illegal for non-ping\n");
-+			return 0;
-+		}
-+	} else if (rejinfo->with == IP6T_TCP_RESET) {
-+		/* Must specify that it's a TCP packet */
-+		if (e->ipv6.proto != IPPROTO_TCP
-+		    || (e->ipv6.invflags & IP6T_INV_PROTO)) {
-+			DEBUGP("REJECTv6: TCP_RESET illegal for non-tcp\n");
-+			return 0;
-+		}
-+	}
-+
-+	return 1;
-+}
-+
-+static struct ip6t_target ip6t_reject_reg
-+= { { NULL, NULL }, "REJECT", reject6_target, check, NULL, THIS_MODULE };
-+
-+static int __init init(void)
-+{
-+	if (ip6t_register_target(&ip6t_reject_reg))
-+		return -EINVAL;
-+	return 0;
-+}
-+
-+static void __exit fini(void)
-+{
-+	ip6t_unregister_target(&ip6t_reject_reg);
-+}
-+
-+module_init(init);
-+module_exit(fini);
-Index: linux-2.4.35.4/include/linux/netfilter_ipv6/ip6t_REJECT.h
-===================================================================
---- linux-2.4.35.4.orig/include/linux/netfilter_ipv6/ip6t_REJECT.h
-+++ linux-2.4.35.4/include/linux/netfilter_ipv6/ip6t_REJECT.h
-@@ -2,15 +2,17 @@
- #define _IP6T_REJECT_H
- 
- enum ip6t_reject_with {
--	IP6T_ICMP_NET_UNREACHABLE,
--	IP6T_ICMP_HOST_UNREACHABLE,
--	IP6T_ICMP_PROT_UNREACHABLE,
--	IP6T_ICMP_PORT_UNREACHABLE,
--	IP6T_ICMP_ECHOREPLY
-+	IP6T_ICMP6_NO_ROUTE,
-+	IP6T_ICMP6_ADM_PROHIBITED,
-+	IP6T_ICMP6_NOT_NEIGHBOUR,
-+	IP6T_ICMP6_ADDR_UNREACH,
-+	IP6T_ICMP6_PORT_UNREACH,
-+	IP6T_ICMP6_ECHOREPLY,
-+	IP6T_TCP_RESET
- };
- 
- struct ip6t_reject_info {
- 	enum ip6t_reject_with with;      /* reject type */
- };
- 
--#endif /*_IPT_REJECT_H*/
-+#endif /*_IP6T_REJECT_H*/
-Index: linux-2.4.35.4/net/ipv6/netfilter/Makefile
-===================================================================
---- linux-2.4.35.4.orig/net/ipv6/netfilter/Makefile
-+++ linux-2.4.35.4/net/ipv6/netfilter/Makefile
-@@ -34,5 +34,7 @@ obj-$(CONFIG_IP6_NF_QUEUE) += ip6_queue.
- obj-$(CONFIG_IP6_NF_TARGET_LOG) += ip6t_LOG.o
- obj-$(CONFIG_IP6_NF_MATCH_RANDOM) += ip6t_random.o
- obj-$(CONFIG_IP6_NF_MATCH_HL) += ip6t_hl.o
-+obj-$(CONFIG_IP6_NF_TARGET_REJECT) += ip6t_REJECT.o
-+
- 
- include $(TOPDIR)/Rules.make
-Index: linux-2.4.35.4/net/ipv6/netfilter/Config.in
-===================================================================
---- linux-2.4.35.4.orig/net/ipv6/netfilter/Config.in
-+++ linux-2.4.35.4/net/ipv6/netfilter/Config.in
-@@ -61,6 +61,9 @@ if [ "$CONFIG_IP6_NF_IPTABLES" != "n" ];
-   if [ "$CONFIG_IP6_NF_FILTER" != "n" ]; then
-     dep_tristate '    LOG target support' CONFIG_IP6_NF_TARGET_LOG $CONFIG_IP6_NF_FILTER
-   fi
-+  if [ "$CONFIG_IP6_NF_FILTER" != "n" ]; then
-+    dep_tristate '    REJECT target support' CONFIG_IP6_NF_TARGET_REJECT $CONFIG_IP6_NF_FILTER
-+  fi
- 
- #  if [ "$CONFIG_IP6_NF_FILTER" != "n" ]; then
- #    dep_tristate '    REJECT target support' CONFIG_IP6_NF_TARGET_REJECT $CONFIG_IP6_NF_FILTER
--- kamikaze-8.09-orig/package/kernel/modules/netfilter.mk	2009-04-12 13:27:11.000000000 -0400
+++ kamikaze-8.09-new/package/kernel/modules/netfilter.mk	2009-04-12 13:41:21.000000000 -0400
@@ -303,6 +303,7 @@
 define KernelPackage/ipt-ipset
   SUBMENU:=$(NF_MENU)
   TITLE:=IPSET Modules
+  DEPENDS:=@LINUX_2_6
   KCONFIG:=$(KCONFIG_IPT_IPSET)
   FILES:=$(foreach mod,$(IPT_IPSET-m),$(LINUX_DIR)/net/$(mod).$(LINUX_KMOD_SUFFIX))
   AUTOLOAD:=$(call AutoLoad,45,$(notdir $(IPT_IPSET-m)))
