--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -455,6 +455,9 @@ ar71xx_board_detect() {
 		name="gl-inet"
 		gl_inet_board_detect
 		;;
+	*"GL-AR150")
+        name="gl-ar150"
+        ;;
 	*"EnGenius EPG5000")
 		name="epg5000"
 		;;
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar150.c
@@ -0,0 +1,131 @@
+/*
+ *  GL_ar150 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR150_GPIO_LED_WLAN		   0
+#define GL_AR150_GPIO_LED_LAN		   13
+#define GL_AR150_GPIO_LED_WAN		   15
+
+#define GL_AR150_GPIO_USB_POW         6
+#define GL_AR150_GPIO_BTN_MANUAL      7
+#define GL_AR150_GPIO_BTN_AUTO	   	   8
+#define GL_AR150_GPIO_BTN_RESET	   11
+
+#define GL_AR150_KEYS_POLL_INTERVAL   20	/* msecs */
+#define GL_AR150_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR150_KEYS_POLL_INTERVAL)
+
+#define GL_AR150_MAC0_OFFSET	0x0000
+#define GL_AR150_MAC1_OFFSET	0x0000
+#define GL_AR150_CALDATA_OFFSET	0x1000
+#define GL_AR150_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_ar150_leds_gpio[] __initdata = {
+	{
+		.name = "gl_ar150:wlan",
+		.gpio = GL_AR150_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_ar150:lan",
+		.gpio = GL_AR150_GPIO_LED_LAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_ar150:wan",
+		.gpio = GL_AR150_GPIO_LED_WAN,
+		.active_low = 0,
+ 		.default_state = 1,
+	},
+	{
+		.name = "gl_ar150:usbpow",
+		.gpio = GL_AR150_GPIO_USB_POW,
+		.active_low = 0,
+		.default_state = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar150_gpio_keys[] __initdata = {
+	{
+		.desc = "BTN_7",
+		.type = EV_KEY,
+		.code = BTN_7,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_MANUAL,
+		.active_low = 0,
+	},
+	{
+		.desc = "BTN_8",
+		.type = EV_KEY,
+		.code = BTN_8,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_AUTO,
+		.active_low = 0,
+	},
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init gl_ar150_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar150_leds_gpio),
+				 gl_ar150_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR150_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar150_gpio_keys),
+					gl_ar150_gpio_keys);
+
+	/* enable usb */
+	gpio_request_one(GL_AR150_GPIO_USB_POW,
+				 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+	 			 "USB power");
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_AR150_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_AR150_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_AR150_CALDATA_OFFSET, art + GL_AR150_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR150, "GL-AR150", "GL-AR150",gl_ar150_setup);
--- /dev/null
+++ b/target/linux/ar71xx/generic/profiles/gli.mk
@@ -0,0 +1,27 @@
+#
+# Copyright (C) 2013 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+define Profile/GLINET
+	NAME:=GL.iNet 6416
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+
+define Profile/GLINET/Description
+	Package set optimized for the GL-Connect GL.iNet v1.
+endef
+
+$(eval $(call Profile,GLINET))
+
+define Profile/GL-AR150
+	NAME:=GL-AR150
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+
+define Profile/GL-AR150/Description
+	Configuration of GL-AR150.
+endef
+
+$(eval $(call Profile,GL-AR150))
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
@@ -376,6 +376,7 @@ dir-505-a1)
 alfa-ap96 |\
 alfa-nx |\
 ap83 |\
+gl-ar150 |\
 gl-inet |\
 jwap003 |\
 pb42 |\
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
@@ -181,6 +181,10 @@ dlan-pro-1200-ac)
 	ucidef_set_led_trigger_gpio "plcr" "dLAN" "devolo:error:dlan" "16" "0"
 	;;
 
+gl-ar150)
+	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar150:wlan" "phy0tpt"
+	;;
+
 gl-inet)
 	ucidef_set_led_netdev "lan" "LAN" "gl-connect:green:lan" "eth1"
 	ucidef_set_led_wlan "wlan" "WLAN" "gl-connect:red:wlan" "phy0tpt"
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -211,6 +211,7 @@ platform_check_image() {
 	dlan-pro-500-wp | \
 	dlan-pro-1200-ac | \
 	dragino2 | \
+	gl-ar150 | \
 	epg5000 | \
 	esr1750 | \
 	esr900 | \
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -144,6 +144,14 @@ define Device/weio
 endef
 TARGET_DEVICES += weio
 
+define Device/gl-ar150
+  BOARDNAME = GL-AR150
+  IMAGE_SIZE = 16000k
+  CONSOLE = ttyATH0,115200
+  MTDPARTS = spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,16000k(firmware),64k(art)ro
+endef
+TARGET_DEVICES += gl-ar150
+
 define Device/wndr3700
   BOARDNAME = WNDR3700
   NETGEAR_KERNEL_MAGIC = 0x33373030
--- /dev/null
+++ b/target/linux/ar71xx/patches-3.18/911-MIPS-ath79-add-gl_ar150.patch
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -533,6 +533,16 @@ config ATH79_MACH_GL_INET
+ 	select ATH79_DEV_USB
+ 	select ATH79_DEV_WMAC
+ 
++config ATH79_MACH_GL_AR150
++   bool "GL AR150 support"
++   select SOC_AR933X
++   select ATH79_DEV_ETH
++   select ATH79_DEV_GPIO_BUTTONS
++   select ATH79_DEV_LEDS_GPIO
++   select ATH79_DEV_M25P80
++   select ATH79_DEV_USB
++   select ATH79_DEV_WMAC
++
+ config ATH79_MACH_EAP300V2
+ 	bool "EnGenius EAP300 v2 support"
+ 	select SOC_AR934X
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -78,6 +78,7 @@ obj-$(CONFIG_ATH79_MACH_EL_MINI)	+= mach
+ obj-$(CONFIG_ATH79_MACH_EPG5000)	+= mach-epg5000.o
+ obj-$(CONFIG_ATH79_MACH_ESR1750)	+= mach-esr1750.o
+ obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= mach-f9k1115v2.o
++obj-$(CONFIG_ATH79_MACH_GL_AR150)	+= mach-gl-ar150.o
+ obj-$(CONFIG_ATH79_MACH_GL_INET)	+= mach-gl-inet.o
+ obj-$(CONFIG_ATH79_MACH_GS_MINIBOX_V1)	+= mach-gs-minibox-v1.o
+ obj-$(CONFIG_ATH79_MACH_GS_OOLITE)	+= mach-gs-oolite.o
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -67,6 +67,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_ESR1750,		/* EnGenius ESR1750 */
+ 	ATH79_MACH_EPG5000,		/* EnGenius EPG5000 */
+ 	ATH79_MACH_F9K1115V2,		/* Belkin AC1750DB */
++	ATH79_MACH_GL_AR150,	/* GL-AR150 support */
+ 	ATH79_MACH_GL_INET,		/* GL-CONNECT GL-INET */
+ 	ATH79_MACH_GS_MINIBOX_V1,	/* Gainstrong MiniBox V1.0 */
+ 	ATH79_MACH_GS_OOLITE,           /* GS OOLITE V1.0 */
--- a/target/linux/ar71xx/generic/profiles/gl-connect.mk
+++ /dev/null
@@ -1,17 +0,0 @@
-#
-# Copyright (C) 2014 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-define Profile/GLINET
-	NAME:=GL.iNet
-	PACKAGES:=kmod-usb-core kmod-usb2
-endef
-
-define Profile/GLINET/Description
-	Package set optimized for the GL-Connect GL.iNet v1.
-endef
-
-$(eval $(call Profile,GLINET))
--- a/target/linux/ar71xx/config-3.18
+++ b/target/linux/ar71xx/config-3.18
@@ -68,6 +68,7 @@ CONFIG_ATH79_MACH_ESR1750=y
 CONFIG_ATH79_MACH_ESR900=y
 CONFIG_ATH79_MACH_EW_DORIN=y
 CONFIG_ATH79_MACH_F9K1115V2=y
+CONFIG_ATH79_MACH_GL_AR150=y
 CONFIG_ATH79_MACH_GL_INET=y
 CONFIG_ATH79_MACH_GS_MINIBOX_V1=y
 CONFIG_ATH79_MACH_GS_OOLITE=y
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
@@ -185,6 +185,10 @@ gl-ar150)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar150:wlan" "phy0tpt"
 	;;
 
+gl-ar300)
+	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar300:wlan" "phy0tpt"
+	;;
+
 gl-inet)
 	ucidef_set_led_netdev "lan" "LAN" "gl-connect:green:lan" "eth1"
 	ucidef_set_led_wlan "wlan" "WLAN" "gl-connect:red:wlan" "phy0tpt"
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
@@ -388,6 +388,12 @@ wpe72)
 	ucidef_set_interfaces_lan_wan "eth1" "eth0"
 	;;
 
+gl-ar300)
+	ucidef_set_interfaces_lan_wan "eth1" "eth0"
+	ucidef_add_switch "switch0" "1" "1"
+	ucidef_add_switch_vlan "switch0" "1" "0 1 2 3 4"
+	;;
+
 wpj344)
 	ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
 	ucidef_add_switch "switch0" "1" "1"
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -439,6 +439,9 @@ ar71xx_board_detect() {
 	*"Dragino v2")
 		name="dragino2"
 		;;
+	*"GL-AR300")
+		name="gl-ar300"
+		;;
 	*"EAP300 v2")
 		name="eap300v2"
 		;;
--- /dev/null
+++ b/target/linux/ar71xx/patches-3.18/912-MIPS-ath79-add-gl_ar300.patch
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -543,6 +543,16 @@ config ATH79_MACH_GL_AR150
+    select ATH79_DEV_USB
+    select ATH79_DEV_WMAC
+ 
++config ATH79_MACH_GL_AR300
++   bool "GL_AR300 support"
++   select SOC_AR934X
++   select ATH79_DEV_ETH
++   select ATH79_DEV_GPIO_BUTTONS
++   select ATH79_DEV_LEDS_GPIO
++   select ATH79_DEV_M25P80
++   select ATH79_DEV_USB
++   select ATH79_DEV_WMAC
++
+ config ATH79_MACH_EAP300V2
+ 	bool "EnGenius EAP300 v2 support"
+ 	select SOC_AR934X
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -79,6 +79,7 @@ obj-$(CONFIG_ATH79_MACH_EPG5000)	+= mach
+ obj-$(CONFIG_ATH79_MACH_ESR1750)	+= mach-esr1750.o
+ obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= mach-f9k1115v2.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR150)	+= mach-gl-ar150.o
++obj-$(CONFIG_ATH79_MACH_GL_AR300)	+= mach-gl-ar300.o
+ obj-$(CONFIG_ATH79_MACH_GL_INET)	+= mach-gl-inet.o
+ obj-$(CONFIG_ATH79_MACH_GS_MINIBOX_V1)	+= mach-gs-minibox-v1.o
+ obj-$(CONFIG_ATH79_MACH_GS_OOLITE)	+= mach-gs-oolite.o
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -68,6 +68,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_EPG5000,		/* EnGenius EPG5000 */
+ 	ATH79_MACH_F9K1115V2,		/* Belkin AC1750DB */
+ 	ATH79_MACH_GL_AR150,	/* GL-AR150 support */
++	ATH79_MACH_GL_AR300,		/* GL-AR300 */
+ 	ATH79_MACH_GL_INET,		/* GL-CONNECT GL-INET */
+ 	ATH79_MACH_GS_MINIBOX_V1,	/* Gainstrong MiniBox V1.0 */
+ 	ATH79_MACH_GS_OOLITE,           /* GS OOLITE V1.0 */
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -212,6 +212,7 @@ platform_check_image() {
 	dlan-pro-1200-ac | \
 	dragino2 | \
 	gl-ar150 | \
+	gl-ar300 | \
 	epg5000 | \
 	esr1750 | \
 	esr900 | \
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300.c
@@ -0,0 +1,106 @@
+/*
+ *  Domino board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR300_GPIO_LED_WLAN	13
+#define GL_AR300_GPIO_LED_WAN	14
+#define GL_AR300_GPIO_BTN_RESET	16
+
+
+#define GL_AR300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_AR300_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR300_KEYS_POLL_INTERVAL)
+
+#define GL_AR300_MAC0_OFFSET	0x0000
+#define	GL_AR300_MAC1_OFFSET	0x0000
+#define GL_AR300_CALDATA_OFFSET	0x1000
+#define GL_AR300_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_ar300_leds_gpio[] __initdata = {
+	{
+		.name = "gl_ar300:wlan",
+		.gpio = GL_AR300_GPIO_LED_WLAN,
+		.active_low = 1,
+	},
+	{
+		.name = "gl_ar300:wan",
+		.gpio = GL_AR300_GPIO_LED_WAN,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar300_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR300_GPIO_BTN_RESET,
+		.active_low = 1,
+	},
+};
+
+static void __init gl_ar300_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	//ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar300_leds_gpio),
+				 gl_ar300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar300_gpio_keys),
+					gl_ar300_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+	ath79_register_mdio(1, 0x0);
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_AR300_MAC0_OFFSET, 0);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_AR300_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_AR300_CALDATA_OFFSET, art + GL_AR300_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR300, "GL-AR300", "GL-AR300",gl_ar300_setup);
--- a/target/linux/ar71xx/generic/profiles/gli.mk
+++ b/target/linux/ar71xx/generic/profiles/gli.mk
@@ -25,3 +25,14 @@ define Profile/GL-AR150/Description
 endef
 
 $(eval $(call Profile,GL-AR150))
+
+define Profile/GL-AR300
+	NAME:=GL-AR300
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+
+define Profile/GL-AR300/Description
+	Configuration of GL-AR300.
+endef
+
+$(eval $(call Profile,GL-AR300))
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -152,6 +152,14 @@ define Device/gl-ar150
 endef
 TARGET_DEVICES += gl-ar150
 
+define Device/gl-ar300
+  BOARDNAME = GL-AR300
+  IMAGE_SIZE = 16000k
+  CONSOLE = ttyS0,115200
+  MTDPARTS = spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,16000k(firmware),64k(art)ro
+endef
+TARGET_DEVICES += gl-ar300
+
 define Device/wndr3700
   BOARDNAME = WNDR3700
   NETGEAR_KERNEL_MAGIC = 0x33373030
--- a/target/linux/ar71xx/config-3.18
+++ b/target/linux/ar71xx/config-3.18
@@ -69,6 +69,7 @@ CONFIG_ATH79_MACH_ESR900=y
 CONFIG_ATH79_MACH_EW_DORIN=y
 CONFIG_ATH79_MACH_F9K1115V2=y
 CONFIG_ATH79_MACH_GL_AR150=y
+CONFIG_ATH79_MACH_GL_AR300=y
 CONFIG_ATH79_MACH_GL_INET=y
 CONFIG_ATH79_MACH_GS_MINIBOX_V1=y
 CONFIG_ATH79_MACH_GS_OOLITE=y
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
@@ -189,6 +189,10 @@ gl-ar300)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar300:wlan" "phy0tpt"
 	;;
 
+gl-domino)
+	ucidef_set_led_wlan "wlan" "WLAN" "domino:blue:wlan" "phy0tpt"
+	;;
+
 gl-inet)
 	ucidef_set_led_netdev "lan" "LAN" "gl-connect:green:lan" "eth1"
 	ucidef_set_led_wlan "wlan" "WLAN" "gl-connect:red:wlan" "phy0tpt"
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -439,6 +439,9 @@ ar71xx_board_detect() {
 	*"Dragino v2")
 		name="dragino2"
 		;;
+	*"Domino Pi")
+		name="gl-domino"
+		;;
 	*"GL-AR300")
 		name="gl-ar300"
 		;;
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -213,6 +213,7 @@ platform_check_image() {
 	dragino2 | \
 	gl-ar150 | \
 	gl-ar300 | \
+	gl-domino | \
 	epg5000 | \
 	esr1750 | \
 	esr900 | \
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-domino.c
@@ -0,0 +1,136 @@
+/*
+ *  Domino board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DOMINO_GPIO_LED_WLAN		0
+#define DOMINO_GPIO_LED_WAN			17
+#define DOMINO_GPIO_LED_USB			1
+#define DOMINO_GPIO_LED_LAN1		13
+#define DOMINO_GPIO_LED_LAN2		14
+#define DOMINO_GPIO_LED_LAN3		15
+#define DOMINO_GPIO_LED_LAN4		16
+#define DOMINO_GPIO_LED_SYS			27
+#define DOMINO_GPIO_LED_WPS			26
+#define DOMINO_GPIO_USB_POWER		6
+
+#define DOMINO_GPIO_BTN_RESET		11
+#define DOMINO_GPIO_BTN_WPS			20
+
+#define DOMINO_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DOMINO_KEYS_DEBOUNCE_INTERVAL	(3 * DOMINO_KEYS_POLL_INTERVAL)
+
+#define DOMINO_MAC0_OFFSET	0x0000
+#define	DOMINO_MAC1_OFFSET	0x0000
+#define DOMINO_CALDATA_OFFSET	0x1000
+#define DOMINO_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led domino_leds_gpio[] __initdata = {
+	{
+		.name = "domino:blue:wlan",
+		.gpio = DOMINO_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "domino:red:wan",
+		.gpio = DOMINO_GPIO_LED_WAN,
+		.active_low = 1,
+	},
+	{
+		.name = "domino:white:usb",
+		.gpio = DOMINO_GPIO_LED_USB,
+		.active_low = 0,
+	},
+	{
+		.name = "domino:green:lan1",
+		.gpio = DOMINO_GPIO_LED_LAN1,
+		.active_low = 0,
+	},
+	{
+		.name = "domino:yellow:wps",
+		.gpio = DOMINO_GPIO_LED_WPS,
+		.active_low = 1,
+	},
+	{
+		.name = "domino:orange:sys",
+		.gpio = DOMINO_GPIO_LED_SYS,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button domino_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = DOMINO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = DOMINO_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+	{
+		.desc = "wps",
+		.type = EV_KEY,
+		.code = KEY_WPS_BUTTON,
+		.debounce_interval = DOMINO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = DOMINO_GPIO_BTN_WPS,
+		.active_low = 0,
+	}
+};
+
+static void __init domino_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(domino_leds_gpio),
+				 domino_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DOMINO_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(domino_gpio_keys),
+					domino_gpio_keys);
+
+	gpio_request_one(DOMINO_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+DOMINO_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+DOMINO_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + DOMINO_CALDATA_OFFSET, art + DOMINO_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_DOMINO, "DOMINO", "Domino Pi", domino_setup);
--- /dev/null
+++ b/target/linux/ar71xx/patches-3.18/913-MIPS-ath79-add-domino-support.patch
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -553,6 +553,16 @@ config ATH79_MACH_GL_AR300
+    select ATH79_DEV_USB
+    select ATH79_DEV_WMAC
+ 
++config ATH79_MACH_GL_DOMINO
++   bool "DOMINO support"
++   select SOC_AR933X
++   select ATH79_DEV_ETH
++   select ATH79_DEV_GPIO_BUTTONS
++   select ATH79_DEV_LEDS_GPIO
++   select ATH79_DEV_M25P80
++   select ATH79_DEV_USB
++   select ATH79_DEV_WMAC
++
+ config ATH79_MACH_EAP300V2
+ 	bool "EnGenius EAP300 v2 support"
+ 	select SOC_AR934X
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -80,6 +80,7 @@ obj-$(CONFIG_ATH79_MACH_ESR1750)	+= mach
+ obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= mach-f9k1115v2.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR150)	+= mach-gl-ar150.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR300)	+= mach-gl-ar300.o
++obj-$(CONFIG_ATH79_MACH_GL_DOMINO)	+= mach-gl-domino.o
+ obj-$(CONFIG_ATH79_MACH_GL_INET)	+= mach-gl-inet.o
+ obj-$(CONFIG_ATH79_MACH_GS_MINIBOX_V1)	+= mach-gs-minibox-v1.o
+ obj-$(CONFIG_ATH79_MACH_GS_OOLITE)	+= mach-gs-oolite.o
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -69,6 +69,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_F9K1115V2,		/* Belkin AC1750DB */
+ 	ATH79_MACH_GL_AR150,	/* GL-AR150 support */
+ 	ATH79_MACH_GL_AR300,		/* GL-AR300 */
++	ATH79_MACH_GL_DOMINO,		/* Domino */
+ 	ATH79_MACH_GL_INET,		/* GL-CONNECT GL-INET */
+ 	ATH79_MACH_GS_MINIBOX_V1,	/* Gainstrong MiniBox V1.0 */
+ 	ATH79_MACH_GS_OOLITE,           /* GS OOLITE V1.0 */
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
@@ -377,6 +377,7 @@ alfa-ap96 |\
 alfa-nx |\
 ap83 |\
 gl-ar150 |\
+gl-domino |\
 gl-inet |\
 jwap003 |\
 pb42 |\
--- a/target/linux/ar71xx/generic/profiles/gli.mk
+++ b/target/linux/ar71xx/generic/profiles/gli.mk
@@ -36,3 +36,14 @@ define Profile/GL-AR300/Description
 endef
 
 $(eval $(call Profile,GL-AR300))
+
+define Profile/DOMINO
+	NAME:=GL Domino Pi
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+
+define Profile/DOMINO/Description
+	Configuration of Domino, Wifi for everything.
+endef
+
+$(eval $(call Profile,DOMINO))
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -160,6 +160,14 @@ define Device/gl-ar300
 endef
 TARGET_DEVICES += gl-ar300
 
+define Device/gl-domino
+  BOARDNAME = DOMINO
+  IMAGE_SIZE = 16000k
+  CONSOLE = ttyATH0,115200
+  MTDPARTS = spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,16000k(firmware),64k(art)ro
+endef
+TARGET_DEVICES += gl-domino
+
 define Device/wndr3700
   BOARDNAME = WNDR3700
   NETGEAR_KERNEL_MAGIC = 0x33373030
--- a/target/linux/ar71xx/config-3.18
+++ b/target/linux/ar71xx/config-3.18
@@ -70,6 +70,7 @@ CONFIG_ATH79_MACH_EW_DORIN=y
 CONFIG_ATH79_MACH_F9K1115V2=y
 CONFIG_ATH79_MACH_GL_AR150=y
 CONFIG_ATH79_MACH_GL_AR300=y
+CONFIG_ATH79_MACH_GL_DOMINO=y
 CONFIG_ATH79_MACH_GL_INET=y
 CONFIG_ATH79_MACH_GS_MINIBOX_V1=y
 CONFIG_ATH79_MACH_GS_OOLITE=y
--- a/target/linux/ramips/base-files/lib/ramips.sh
+++ b/target/linux/ramips/base-files/lib/ramips.sh
@@ -169,6 +169,9 @@ ramips_board_detect() {
 	*"F5D8235 v2")
 		name="f5d8235-v2"
 		;;
+	*"GL-MT300A")
+		name="gl-mt300a"
+		;;
 	*"Hauppauge Broadway")
 		name="broadway"
 		;;
--- a/target/linux/ramips/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ramips/base-files/lib/upgrade/platform.sh
@@ -55,6 +55,7 @@ platform_check_image() {
 	fonera20n | \
 	freestation5 | \
 	firewrt |\
+	gl-mt300a |\
 	pbr-m1 |\
 	hg255d | \
 	hlk-rm04 | \
--- /dev/null
+++ b/target/linux/ramips/mt7620/profiles/gli.mk
@@ -0,0 +1,16 @@
+#
+# Copyright (C) 2015 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+define Profile/GL-MT300A
+	NAME:=GL-MT300A 
+	PACKAGES:=kmod-usb-core kmod-usb-dwc2 kmod-usb2 kmod-usb-ohci kmod-mt76
+endef
+
+define Profile/GL-MT300A/Description
+	Support for gl-mt300a Router
+endef
+$(eval $(call Profile,GL-MT300A))
--- a/target/linux/ramips/image/Makefile
+++ b/target/linux/ramips/image/Makefile
@@ -910,6 +910,7 @@ Image/Build/Profile/WR8305RT=$(call Buil
 Image/Build/Profile/WRTNODE=$(call BuildFirmware/Default16M/$(1),$(1),wrtnode,WRTNODE)
 Image/Build/Profile/WT3020=$(call BuildFirmware/PorayDualSize/$(1),$(1),wt3020,WT3020)
 Image/Build/Profile/XIAOMI-MIWIFI-MINI=$(call BuildFirmware/Default16M/$(1),$(1),xiaomi-miwifi-mini,XIAOMI-MIWIFI-MINI)
+Image/Build/Profile/GL-MT300A=$(call BuildFirmware/Default16M/$(1),$(1),gl-mt300a,GL-MT300A)
 Image/Build/Profile/ZTE-Q7=$(call BuildFirmware/Default8M/$(1),$(1),zte-q7,ZTE-Q7)
 Image/Build/Profile/ZBT-WA05=$(call BuildFirmware/Default8M/$(1),$(1),zbt-wa05,ZBT-WA05)
 Image/Build/Profile/ArcherC20i=$(call BuildFirmware/Tplink/$(1),$(1),ArcherC20i,ArcherC20i)
@@ -944,6 +945,7 @@ define Image/Build/Profile/Default
 	$(call Image/Build/Profile/WRTNODE,$(1))
 	$(call Image/Build/Profile/WT3020,$(1))
 	$(call Image/Build/Profile/XIAOMI-MIWIFI-MINI,$(1))
+	$(call Image/Build/Profile/GL-MT300A,$(1))
 	$(call Image/Build/Profile/ZTE-Q7,$(1))
 	$(call Image/Build/Profile/ZBT-WA05,$(1))
 	$(call Image/Build/Profile/ArcherC20i,$(1))
--- /dev/null
+++ b/target/linux/ramips/dts/GL-MT300A.dts
@@ -0,0 +1,163 @@
+/dts-v1/;
+
+/include/ "mt7620a.dtsi"
+
+/ {
+	compatible = "GL-MT300A", "ralink,mt7620a-soc";
+	model = "GL-MT300A";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	palmbus@10000000 {
+		gpio0: gpio@600 {
+			status = "okay";
+		};
+
+		gpio1: gpio@638 {
+			status = "okay";
+		};
+
+		gpio2: gpio@660 {
+			status = "okay";
+		};
+
+		gpio3: gpio@688 {
+		      status = "okay";
+		 };
+
+		spi@b00 {
+			status = "okay";
+
+			m25p80@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "w25q128";
+				reg = <0 0>;
+				linux,modalias = "m25p80", "w25q128";
+				spi-max-frequency = <10000000>;
+
+				partition@0 {
+					label = "u-boot";
+					reg = <0x0 0x30000>;
+					read-only;
+				};
+
+				partition@30000 {
+					label = "u-boot-env";
+					reg = <0x30000 0x10000>;
+				};
+
+				factory: partition@40000 {
+					label = "factory";
+					reg = <0x40000 0x10000>;
+				};
+
+				partition@50000 {
+					label = "firmware";
+					reg = <0x50000 0xf80000>;
+				};
+
+				partition@ff0000 {
+					label = "art";
+					reg = <0xff0000 0x10000>;
+				};
+			};
+		};
+	};
+
+	sdhci@10130000 {
+		status = "okay";
+	};
+
+	ehci@101c0000 {
+		status = "okay";
+	};
+
+	ohci@101c1000 {
+		status = "okay";
+	};
+
+	ethernet@10100000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ephy_pins>;
+		mtd-mac-address = <&factory 0x4000>;
+		ralink,port-map = "wllll";
+	};
+
+	wmac@10180000 {
+		ralink,mtd-eeprom = <&factory 0>;
+	};
+
+	pcie@10140000 {
+		status = "okay";
+
+		pcie-bridge {
+			mt76@0,0 {
+				reg = <0x0000 0 0 0 0>;
+				device_type = "pci";
+				mediatek,mtd-eeprom = <&factory 0x8000>;
+				mediatek,2ghz = <0>;
+			};
+		};
+	};
+
+	pinctrl {
+		state_default: pinctrl0 {
+			gpio {
+				ralink,group = "wled","ephy","uartf","i2c";
+				ralink,function = "gpio";
+			};
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		wan {
+			label = "gl-mt300a:wan";
+			gpios = <&gpio2 0 1>;
+		};
+
+		lan {
+			label = "gl-mt300a:lan";
+			gpios = <&gpio2 1 1>;
+		};
+
+		wlan {
+			label = "gl-mt300a:wlan";
+			gpios = <&gpio3 0 1>;
+		};
+
+		usb {
+			label = "gl-mt300a:usbpow";
+			gpios = <&gpio0 7 1>;
+		};
+
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+		reset {
+			label = "reset";
+			gpios = <&gpio0 13 1>;
+			linux,code = <0x198>;
+		};
+
+		BTN_0 {
+			label = "BTN_0";
+			gpios = <&gpio0 1 1>;
+			linux,code = <0x100>;
+		};
+
+  	    BTN_1 {
+			label = "BTN_1";
+			gpios = <&gpio0 2 1>;
+			linux,code = <0x101>;
+		};
+ 	};
+};
--- a/target/linux/ramips/base-files/etc/board.d/01_leds
+++ b/target/linux/ramips/base-files/etc/board.d/01_leds
@@ -147,6 +147,9 @@ case $board in
 	mofi3500-3gn)
 		set_usb_led "mofi3500-3gn:green:usb"
 		;;
+    gl-mt300a)
+		set_wifi_led "gl-mt300a:wlan"
+		;;
 	mpr-a1)
 		set_wifi_led "hame:blue:system"
 		;;
--- a/target/linux/ramips/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/base-files/etc/board.d/02_network
@@ -153,6 +153,13 @@ ramips_setup_interfaces()
 		ucidef_add_switch_vlan "switch0" "1" "0 1 2 3 6t"
 		ucidef_add_switch_vlan "switch0" "2" "4 6t"
 		;;
+	
+	gl-mt300a)
+		ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
+		ucidef_add_switch "switch0" "1" "1"
+		ucidef_add_switch_vlan "switch0" "2" "0 6t"
+		ucidef_add_switch_vlan "switch0" "1" "1 2 3 4 6t"
+		;;
 
 	whr-1166d)
 		ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
--- a/target/linux/ramips/base-files/lib/ramips.sh
+++ b/target/linux/ramips/base-files/lib/ramips.sh
@@ -172,6 +172,9 @@ ramips_board_detect() {
 	*"GL-MT300A")
 		name="gl-mt300a"
 		;;
+	*"GL-MT300N")
+		name="gl-mt300n"
+		;;
 	*"Hauppauge Broadway")
 		name="broadway"
 		;;
--- a/target/linux/ramips/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ramips/base-files/lib/upgrade/platform.sh
@@ -56,6 +56,7 @@ platform_check_image() {
 	freestation5 | \
 	firewrt |\
 	gl-mt300a |\
+	gl-mt300n |\
 	pbr-m1 |\
 	hg255d | \
 	hlk-rm04 | \
--- a/target/linux/ramips/mt7620/profiles/gli.mk
+++ b/target/linux/ramips/mt7620/profiles/gli.mk
@@ -14,3 +14,13 @@ define Profile/GL-MT300A/Description
 	Support for gl-mt300a Router
 endef
 $(eval $(call Profile,GL-MT300A))
+
+define Profile/GL-MT300N
+    NAME:=GL-MT300N
+    PACKAGES:=kmod-usb-core kmod-usb-dwc2 kmod-usb2 kmod-usb-ohci kmod-mt76
+endef
+
+define Profile/GL-MT300N/Description
+    Support for gl-mt300n Router
+endef
+$(eval $(call Profile,GL-MT300N))
--- a/target/linux/ramips/image/Makefile
+++ b/target/linux/ramips/image/Makefile
@@ -911,6 +911,7 @@ Image/Build/Profile/WRTNODE=$(call Build
 Image/Build/Profile/WT3020=$(call BuildFirmware/PorayDualSize/$(1),$(1),wt3020,WT3020)
 Image/Build/Profile/XIAOMI-MIWIFI-MINI=$(call BuildFirmware/Default16M/$(1),$(1),xiaomi-miwifi-mini,XIAOMI-MIWIFI-MINI)
 Image/Build/Profile/GL-MT300A=$(call BuildFirmware/Default16M/$(1),$(1),gl-mt300a,GL-MT300A)
+Image/Build/Profile/GL-MT300N=$(call BuildFirmware/Default16M/$(1),$(1),gl-mt300n,GL-MT300N)
 Image/Build/Profile/ZTE-Q7=$(call BuildFirmware/Default8M/$(1),$(1),zte-q7,ZTE-Q7)
 Image/Build/Profile/ZBT-WA05=$(call BuildFirmware/Default8M/$(1),$(1),zbt-wa05,ZBT-WA05)
 Image/Build/Profile/ArcherC20i=$(call BuildFirmware/Tplink/$(1),$(1),ArcherC20i,ArcherC20i)
@@ -946,6 +947,7 @@ define Image/Build/Profile/Default
 	$(call Image/Build/Profile/WT3020,$(1))
 	$(call Image/Build/Profile/XIAOMI-MIWIFI-MINI,$(1))
 	$(call Image/Build/Profile/GL-MT300A,$(1))
+	$(call Image/Build/Profile/GL-MT300N,$(1))
 	$(call Image/Build/Profile/ZTE-Q7,$(1))
 	$(call Image/Build/Profile/ZBT-WA05,$(1))
 	$(call Image/Build/Profile/ArcherC20i,$(1))
--- a/target/linux/ramips/base-files/etc/board.d/01_leds
+++ b/target/linux/ramips/base-files/etc/board.d/01_leds
@@ -150,6 +150,9 @@ case $board in
     gl-mt300a)
 		set_wifi_led "gl-mt300a:wlan"
 		;;
+	gl-mt300n)
+		set_wifi_led "gl-mt300n:wlan"
+		;;
 	mpr-a1)
 		set_wifi_led "hame:blue:system"
 		;;
--- a/target/linux/ramips/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/base-files/etc/board.d/02_network
@@ -160,6 +160,13 @@ ramips_setup_interfaces()
 		ucidef_add_switch_vlan "switch0" "2" "0 6t"
 		ucidef_add_switch_vlan "switch0" "1" "1 2 3 4 6t"
 		;;
+	
+	gl-mt300n)
+		ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
+		ucidef_add_switch "switch0" "1" "1"
+		ucidef_add_switch_vlan "switch0" "2" "0 6t"
+		ucidef_add_switch_vlan "switch0" "1" "1 2 3 4 6t"
+		;;
 
 	whr-1166d)
 		ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
--- /dev/null
+++ b/target/linux/ramips/dts/GL-MT300N.dts
@@ -0,0 +1,157 @@
+/dts-v1/;
+
+/include/ "mt7620n.dtsi"
+
+/ {
+	compatible = "GL-MT300N", "ralink,mt7620n-soc";
+	model = "GL-MT300N";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	palmbus@10000000 {
+		gpio0: gpio@600 {
+			status = "okay";
+		};
+
+		gpio1: gpio@638 {
+			status = "okay";
+		};
+
+		gpio2: gpio@660 {
+			status = "okay";
+		};
+
+		gpio3: gpio@688 {
+		      status = "okay";
+		 };
+
+		spi@b00 {
+			status = "okay";
+
+			m25p80@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "w25q128";
+				reg = <0 0>;
+				linux,modalias = "m25p80", "w25q128";
+				spi-max-frequency = <10000000>;
+
+				partition@0 {
+					label = "u-boot";
+					reg = <0x0 0x30000>;
+					read-only;
+				};
+
+				partition@30000 {
+					label = "u-boot-env";
+					reg = <0x30000 0x10000>;
+				};
+
+				factory: partition@40000 {
+					label = "factory";
+					reg = <0x40000 0x10000>;
+				};
+
+				partition@50000 {
+					label = "firmware";
+					reg = <0x50000 0xf80000>;
+				};
+
+				partition@ff0000 {
+					label = "art";
+					reg = <0xff0000 0x10000>;
+				};
+			};
+		};
+	};
+
+	ehci@101c0000 {
+		status = "okay";
+	};
+
+	ohci@101c1000 {
+		status = "okay";
+	};
+
+	ethernet@10100000 {
+		mtd-mac-address = <&factory 0x4000>;
+		ralink,port-map = "wllll";
+	};
+
+	wmac@10180000 {
+		ralink,mtd-eeprom = <&factory 0>;
+	};
+
+	pcie@10140000 {
+		status = "okay";
+
+		pcie-bridge {
+			mt76@0,0 {
+				reg = <0x0000 0 0 0 0>;
+				device_type = "pci";
+				mediatek,mtd-eeprom = <&factory 0x8000>;
+				mediatek,2ghz = <0>;
+			};
+		};
+	};
+
+	pinctrl {
+		state_default: pinctrl0 {
+			gpio {
+				ralink,group = "wled","ephy","i2c";
+				ralink,function = "gpio";
+			};
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		wan {
+			label = "gl-mt300n:wan";
+			gpios = <&gpio2 0 1>;
+		};
+
+		lan {
+			label = "gl-mt300n:lan";
+			gpios = <&gpio2 1 1>;
+		};
+
+		wlan {
+			label = "gl-mt300n:wlan";
+			gpios = <&gpio3 0 1>;
+		};
+
+		usb {
+			label = "gl-mt300n:usbpow";
+			gpios = <&gpio0 0 1>;
+		};
+
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+		reset {
+			label = "reset";
+			gpios = <&gpio0 1 1>;
+			linux,code = <0x198>;
+		};
+
+		BTN_0 {
+			label = "BTN_0";
+			gpios = <&gpio2 2 1>;
+			linux,code = <0x100>;
+		};
+
+  	    BTN_1 {
+			label = "BTN_1";
+			gpios = <&gpio2 3 1>;
+			linux,code = <0x101>;
+		};
+	};
+};
--- a/target/linux/ramips/base-files/lib/ramips.sh
+++ b/target/linux/ramips/base-files/lib/ramips.sh
@@ -175,6 +175,9 @@ ramips_board_detect() {
 	*"GL-MT300N")
 		name="gl-mt300n"
 		;;
+	*"GL-MT750")
+		name="gl-mt750"
+		;;
 	*"Hauppauge Broadway")
 		name="broadway"
 		;;
--- a/target/linux/ramips/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ramips/base-files/lib/upgrade/platform.sh
@@ -57,6 +57,7 @@ platform_check_image() {
 	firewrt |\
 	gl-mt300a |\
 	gl-mt300n |\
+	gl-mt750 |\
 	pbr-m1 |\
 	hg255d | \
 	hlk-rm04 | \
--- a/target/linux/ramips/image/Makefile
+++ b/target/linux/ramips/image/Makefile
@@ -912,6 +912,7 @@ Image/Build/Profile/WT3020=$(call BuildF
 Image/Build/Profile/XIAOMI-MIWIFI-MINI=$(call BuildFirmware/Default16M/$(1),$(1),xiaomi-miwifi-mini,XIAOMI-MIWIFI-MINI)
 Image/Build/Profile/GL-MT300A=$(call BuildFirmware/Default16M/$(1),$(1),gl-mt300a,GL-MT300A)
 Image/Build/Profile/GL-MT300N=$(call BuildFirmware/Default16M/$(1),$(1),gl-mt300n,GL-MT300N)
+Image/Build/Profile/GL-MT750=$(call BuildFirmware/Default16M/$(1),$(1),gl-mt750,GL-MT750)
 Image/Build/Profile/ZTE-Q7=$(call BuildFirmware/Default8M/$(1),$(1),zte-q7,ZTE-Q7)
 Image/Build/Profile/ZBT-WA05=$(call BuildFirmware/Default8M/$(1),$(1),zbt-wa05,ZBT-WA05)
 Image/Build/Profile/ArcherC20i=$(call BuildFirmware/Tplink/$(1),$(1),ArcherC20i,ArcherC20i)
@@ -948,6 +949,7 @@ define Image/Build/Profile/Default
 	$(call Image/Build/Profile/XIAOMI-MIWIFI-MINI,$(1))
 	$(call Image/Build/Profile/GL-MT300A,$(1))
 	$(call Image/Build/Profile/GL-MT300N,$(1))
+	$(call Image/Build/Profile/GL-MT750,$(1))
 	$(call Image/Build/Profile/ZTE-Q7,$(1))
 	$(call Image/Build/Profile/ZBT-WA05,$(1))
 	$(call Image/Build/Profile/ArcherC20i,$(1))
--- a/target/linux/ramips/mt7620/profiles/gli.mk
+++ b/target/linux/ramips/mt7620/profiles/gli.mk
@@ -16,11 +16,21 @@ endef
 $(eval $(call Profile,GL-MT300A))
 
 define Profile/GL-MT300N
-    NAME:=GL-MT300N
-    PACKAGES:=kmod-usb-core kmod-usb-dwc2 kmod-usb2 kmod-usb-ohci kmod-mt76
+	NAME:=GL-MT300N
+	PACKAGES:=kmod-usb-core kmod-usb-dwc2 kmod-usb2 kmod-usb-ohci kmod-mt76
 endef
 
 define Profile/GL-MT300N/Description
     Support for gl-mt300n Router
 endef
 $(eval $(call Profile,GL-MT300N))
+
+define Profile/GL-MT750
+	NAME:=GL-MT750
+	PACKAGES:=kmod-usb-core kmod-usb-dwc2 kmod-usb2 kmod-usb-ohci kmod-mt76 kmod-mt7610e
+endef
+
+define Profile/GL-MT750/Description
+    Support for gl-mt750 Router
+endef
+$(eval $(call Profile,GL-MT750))
--- a/target/linux/ramips/base-files/etc/board.d/01_leds
+++ b/target/linux/ramips/base-files/etc/board.d/01_leds
@@ -153,6 +153,9 @@ case $board in
 	gl-mt300n)
 		set_wifi_led "gl-mt300n:wlan"
 		;;
+	gl-mt750)
+		set_wifi_led "gl-mt750:wlan"
+		;;
 	mpr-a1)
 		set_wifi_led "hame:blue:system"
 		;;
--- a/target/linux/ramips/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/base-files/etc/board.d/02_network
@@ -167,6 +167,13 @@ ramips_setup_interfaces()
 		ucidef_add_switch_vlan "switch0" "2" "0 6t"
 		ucidef_add_switch_vlan "switch0" "1" "1 2 3 4 6t"
 		;;
+	
+	gl-mt750)
+		ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
+		ucidef_add_switch "switch0" "1" "1"
+		ucidef_add_switch_vlan "switch0" "2" "0 6t"
+		ucidef_add_switch_vlan "switch0" "1" "1 2 3 4 6t"
+		;;
 
 	whr-1166d)
 		ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
--- /dev/null
+++ b/target/linux/ramips/dts/GL-MT750.dts
@@ -0,0 +1,158 @@
+/dts-v1/;
+
+/include/ "mt7620a.dtsi"
+
+/ {
+	compatible = "GL-MT750", "ralink,mt7620a-soc";
+	model = "GL-MT750";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	palmbus@10000000 {
+		gpio0: gpio@600 {
+			status = "okay";
+		};
+
+		gpio1: gpio@638 {
+			status = "okay";
+		};
+
+		gpio2: gpio@660 {
+			status = "okay";
+		};
+		
+		gpio3: gpio@688 {
+		      status = "okay";
+		 };
+
+		spi@b00 {
+			status = "okay";
+
+			m25p80@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "w25q128";
+				reg = <0 0>;
+				linux,modalias = "m25p80", "w25q128";
+				spi-max-frequency = <10000000>;
+
+				partition@0 {
+					label = "u-boot";
+					reg = <0x0 0x30000>;
+					read-only;
+				};
+
+				partition@30000 {
+					label = "u-boot-env";
+					reg = <0x30000 0x10000>;
+				};
+
+				factory: partition@40000 {
+					label = "factory";
+					reg = <0x40000 0x10000>;
+				};
+
+				partition@50000 {
+					label = "firmware";
+					reg = <0x50000 0xf80000>;
+				};
+
+				partition@ff0000 {
+					label = "art";
+					reg = <0xff0000 0x10000>;
+				};
+			};
+		};
+	};
+
+	sdhci@10130000 {
+		status = "okay";
+	};
+
+	ehci@101c0000 {
+		status = "okay";
+	};
+
+	ohci@101c1000 {
+		status = "okay";
+	};
+
+	ethernet@10100000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ephy_pins>;
+		mtd-mac-address = <&factory 0x4000>;
+		ralink,port-map = "llllw";
+	};
+
+	wmac@10180000 {
+		ralink,mtd-eeprom = <&factory 0>;
+	};
+
+	pcie@10140000 {
+		status = "okay";
+
+		pcie-bridge {
+			mt76@0,0 {
+				reg = <0x0000 0 0 0 0>;
+				device_type = "pci";
+				mediatek,mtd-eeprom = <&factory 0x8000>;
+				mediatek,2ghz = <0>;
+			};
+		};
+	};
+
+	pinctrl {
+		state_default: pinctrl0 {
+			gpio {
+				ralink,group = "wled","ephy","uartf";
+				ralink,function = "gpio";
+			};
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		wan {
+			label = "gl-mt750:wan";
+			gpios = <&gpio2 0 1>;
+		};
+
+		lan {
+			label = "gl-mt750:lan";
+			gpios = <&gpio2 1 1>;
+		};
+
+		wlan {
+			label = "gl-mt750:wlan";
+			gpios = <&gpio3 0 1>;
+		};
+
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+		reset {
+			label = "reset";
+			gpios = <&gpio0 13 1>;
+			linux,code = <0x198>;
+		};
+
+		BTN_0 {
+			label = "BTN_0";
+			gpios = <&gpio2 2 1>;
+			linux,code = <0x100>;
+		};
+
+  	    BTN_1 {
+			label = "BTN_1";
+			gpios = <&gpio2 3 1>;
+			linux,code = <0x101>;
+		};
+ 	};
+};
--- a/target/linux/ramips/image/Makefile
+++ b/target/linux/ramips/image/Makefile
@@ -955,6 +955,11 @@ define Image/Build/Profile/Default
 	$(call Image/Build/Profile/ArcherC20i,$(1))
 	$(call Image/Build/Profile/MicroWRT,$(1))
 endef
+define Image/Build/Profile/GL-MT-ALL
+	$(call Image/Build/Profile/GL-MT300A,$(1))
+	$(call Image/Build/Profile/GL-MT300N,$(1))
+	$(call Image/Build/Profile/GL-MT750,$(1))
+endef
 endif
 
 #
--- a/target/linux/ramips/mt7620/profiles/gli.mk
+++ b/target/linux/ramips/mt7620/profiles/gli.mk
@@ -34,3 +34,12 @@ define Profile/GL-MT750/Description
     Support for gl-mt750 Router
 endef
 $(eval $(call Profile,GL-MT750))
+
+define Profile/GL-MT-ALL
+	NAME:=GL-MT-ALL
+	PACKAGES:=kmod-usb-core kmod-usb-dwc2 kmod-usb2 kmod-usb-ohci kmod-mt76 kmod-mt7610e
+endef
+define Profile/GL-MT-ALL/Description
+	All profiles including GL-MT300A, GL-MT300N, GL-MT750
+endef
+$(eval $(call Profile,GL-MT-ALL))
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -464,6 +464,9 @@ ar71xx_board_detect() {
 	*"GL-AR150")
         name="gl-ar150"
         ;;
+	*"GL-MIFI")
+        name="gl-mifi"
+        ;;
 	*"EnGenius EPG5000")
 		name="epg5000"
 		;;
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c
@@ -0,0 +1,114 @@
+/*
+ *  Mifi board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_MIFI_GPIO_LED_WAN		27
+#define GL_MIFI_GPIO_LED_LAN		16
+#define GL_MIFI_GPIO_LED_WLAN		1
+#define GL_MIFI_GPIO_LED_NET		0
+#define GL_MIFI_GPIO_LED_USB_POW	7
+
+#define GL_MIFI_GPIO_BTN_RESET    11
+
+#define GL_MIFI_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_MIFI_KEYS_DEBOUNCE_INTERVAL	(3 * GL_MIFI_KEYS_POLL_INTERVAL)
+
+#define GL_MIFI_MAC0_OFFSET	    0x0000
+#define GL_MIFI_MAC1_OFFSET	    0x0000
+#define GL_MIFI_CALDATA_OFFSET	0x1000
+#define GL_MIFI_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_mifi_leds_gpio[] __initdata = {
+	{
+		.name = "gl_mifi:wan",
+		.gpio = GL_MIFI_GPIO_LED_WAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_mifi:lan",
+		.gpio = GL_MIFI_GPIO_LED_LAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_mifi:wlan",
+		.gpio = GL_MIFI_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_mifi:net",
+		.gpio = GL_MIFI_GPIO_LED_NET,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_mifi:usbpow",
+		.gpio = GL_MIFI_GPIO_LED_USB_POW,
+		.active_low = 0,
+	}
+};
+
+static struct gpio_keys_button gl_mifi_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_MIFI_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_MIFI_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init gl_mifi_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_mifi_leds_gpio),
+				 gl_mifi_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_MIFI_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_mifi_gpio_keys),
+					gl_mifi_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_MIFI_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_MIFI_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_MIFI_CALDATA_OFFSET, art + GL_MIFI_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_MIFI, "GL-MIFI", "GL-MIFI",gl_mifi_setup);
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
@@ -377,6 +377,7 @@ alfa-ap96 |\
 alfa-nx |\
 ap83 |\
 gl-ar150 |\
+gl-mifi |\
 gl-domino |\
 gl-inet |\
 jwap003 |\
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
@@ -185,6 +185,13 @@ gl-ar150)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar150:wlan" "phy0tpt"
 	;;
 
+gl-mifi)
+	ucidef_set_led_netdev "wan" "WAN" "gl_mifi:wan" "eth0"
+	ucidef_set_led_netdev "lan" "LAN" "gl_mifi:lan" "eth1"
+	ucidef_set_led_netdev "3gnet" "3GNET" "gl_mifi:net" "3g-modem"
+	ucidef_set_led_wlan "wlan" "WLAN" "gl_mifi:wlan" "phy0tpt"
+	;;
+
 gl-ar300)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar300:wlan" "phy0tpt"
 	;;
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -212,6 +212,7 @@ platform_check_image() {
 	dlan-pro-1200-ac | \
 	dragino2 | \
 	gl-ar150 | \
+	gl-mifi | \
 	gl-ar300 | \
 	gl-domino | \
 	epg5000 | \
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -152,6 +152,14 @@ define Device/gl-ar150
 endef
 TARGET_DEVICES += gl-ar150
 
+define Device/gl-mifi
+  BOARDNAME = GL-MIFI
+  IMAGE_SIZE = 16000k
+  CONSOLE = ttyATH0,115200
+  MTDPARTS = spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,16000k(firmware),64k(art)ro
+endef
+TARGET_DEVICES += gl-mifi
+
 define Device/gl-ar300
   BOARDNAME = GL-AR300
   IMAGE_SIZE = 16000k
--- a/target/linux/ar71xx/config-3.18
+++ b/target/linux/ar71xx/config-3.18
@@ -69,6 +69,7 @@ CONFIG_ATH79_MACH_ESR900=y
 CONFIG_ATH79_MACH_EW_DORIN=y
 CONFIG_ATH79_MACH_F9K1115V2=y
 CONFIG_ATH79_MACH_GL_AR150=y
+CONFIG_ATH79_MACH_GL_MIFI=y
 CONFIG_ATH79_MACH_GL_AR300=y
 CONFIG_ATH79_MACH_GL_DOMINO=y
 CONFIG_ATH79_MACH_GL_INET=y
--- /dev/null
+++ b/target/linux/ar71xx/patches-3.18/915-MIPS-ath79-add-gl_mifi.patch
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -543,6 +543,16 @@ config ATH79_MACH_GL_AR150
+    select ATH79_DEV_USB
+    select ATH79_DEV_WMAC
+ 
++config ATH79_MACH_GL_MIFI
++	bool "GL MIFI support"
++	select SOC_AR933X
++	select ATH79_DEV_ETH
++	select ATH79_DEV_GPIO_BUTTONS
++	select ATH79_DEV_LEDS_GPIO
++	select ATH79_DEV_M25P80
++	select ATH79_DEV_USB
++	select ATH79_DEV_WMAC
++
+ config ATH79_MACH_GL_AR300
+    bool "GL_AR300 support"
+    select SOC_AR934X
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -79,6 +79,7 @@ obj-$(CONFIG_ATH79_MACH_EPG5000)	+= mach
+ obj-$(CONFIG_ATH79_MACH_ESR1750)	+= mach-esr1750.o
+ obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= mach-f9k1115v2.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR150)	+= mach-gl-ar150.o
++obj-$(CONFIG_ATH79_MACH_GL_MIFI)	+= mach-gl-mifi.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR300)	+= mach-gl-ar300.o
+ obj-$(CONFIG_ATH79_MACH_GL_DOMINO)	+= mach-gl-domino.o
+ obj-$(CONFIG_ATH79_MACH_GL_INET)	+= mach-gl-inet.o
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -68,6 +68,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_EPG5000,		/* EnGenius EPG5000 */
+ 	ATH79_MACH_F9K1115V2,		/* Belkin AC1750DB */
+ 	ATH79_MACH_GL_AR150,	/* GL-AR150 support */
++	ATH79_MACH_GL_MIFI,	    /* GL-MIFI support */
+ 	ATH79_MACH_GL_AR300,		/* GL-AR300 */
+ 	ATH79_MACH_GL_DOMINO,		/* Domino */
+ 	ATH79_MACH_GL_INET,		/* GL-CONNECT GL-INET */
--- a/target/linux/ar71xx/generic/profiles/gli.mk
+++ b/target/linux/ar71xx/generic/profiles/gli.mk
@@ -47,3 +47,12 @@ define Profile/DOMINO/Description
 endef
 
 $(eval $(call Profile,DOMINO))
+
+define Profile/GL-MIFI
+	NAME:=GL-MIFI
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+define Profile/GL-MIFI/Description
+	Configuration of GL-MIFI.
+endef
+$(eval $(call Profile,GL-MIFI))
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
@@ -185,6 +185,10 @@ gl-ar150)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar150:wlan" "phy0tpt"
 	;;
 
+gl-ar300m)
+	ucidef_set_led_wlan "wlan" "WLAN" "gl-ar300m:wlan" "phy0tpt"
+	;;
+
 gl-mifi)
 	ucidef_set_led_netdev "wan" "WAN" "gl_mifi:wan" "eth0"
 	ucidef_set_led_netdev "lan" "LAN" "gl_mifi:lan" "eth1"
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
@@ -377,6 +377,7 @@ alfa-ap96 |\
 alfa-nx |\
 ap83 |\
 gl-ar150 |\
+gl-ar300m |\
 gl-mifi |\
 gl-domino |\
 gl-inet |\
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c
@@ -0,0 +1,183 @@
+/*
+ *  GLI AR300M(D) board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/pci.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define GL_AR300M_GPIO_LED_USB		2
+#define GL_AR300M_GPIO_LED_WLAN		14
+#define GL_AR300M_GPIO_LED_LAN		13
+#define GL_AR300M_GPIO_LED_SYSTEM	12
+#define GL_AR300M_GPIO_BTN_RESET	3
+#define GL_AR300M_GPIO_BTN_LEFT		0
+#define GL_AR300M_GPIO_BTN_RIGHT	1
+
+#define GL_AR300M_KEYS_POLL_INTERVAL        20  /* msecs */
+#define GL_AR300M_KEYS_DEBOUNCE_INTERVAL    (3 * GL_AR300M_KEYS_POLL_INTERVAL)
+
+/* eth0 and eth1 use the same address as wlan0 */
+#define GL_AR300M_MAC0_OFFSET		0x1002
+#define GL_AR300M_MAC1_OFFSET		0x1002
+#define GL_AR300M_WMAC_CALDATA_OFFSET   0x1000
+#define GL_AR300M_PCIE_CALDATA_OFFSET   0x5000
+
+static struct gpio_led gl_ar300m_leds_gpio[] __initdata = {
+    {
+        .name = "gl-ar300m:usbpow",
+        .gpio = GL_AR300M_GPIO_LED_USB,
+        .active_low = 0,
+        .default_state = 1,
+    },
+    {
+        .name = "gl-ar300m:wlan",
+        .gpio = GL_AR300M_GPIO_LED_WLAN,
+        .active_low = 1,
+    },
+    {
+        .name = "gl-ar300m:lan",
+        .gpio = GL_AR300M_GPIO_LED_LAN,
+        .active_low = 1,
+    },
+    {
+        .name = "gl-ar300m:system",
+        .gpio = GL_AR300M_GPIO_LED_SYSTEM,
+        .active_low = 1,
+        .default_state = 1,
+    },
+};
+
+static struct gpio_keys_button gl_ar300m_gpio_keys[] __initdata = {
+    {
+        .desc = "reset",
+        .type = EV_KEY,
+        .code = KEY_RESTART,
+        .debounce_interval = GL_AR300M_KEYS_DEBOUNCE_INTERVAL,
+        .gpio = GL_AR300M_GPIO_BTN_RESET,
+        .active_low = 1,
+    },
+    {
+        .desc = "button right",
+        .type = EV_KEY,
+        .code = BTN_0,
+        .debounce_interval = GL_AR300M_KEYS_DEBOUNCE_INTERVAL,
+        .gpio = GL_AR300M_GPIO_BTN_LEFT,
+        .active_low = 0,
+    },
+    {
+        .desc = "button left",
+        .type = EV_KEY,
+        .code = BTN_1,
+        .debounce_interval = GL_AR300M_KEYS_DEBOUNCE_INTERVAL,
+        .gpio = GL_AR300M_GPIO_BTN_RIGHT,
+        .active_low = 0,
+    },
+};
+
+static struct ath79_spi_controller_data gl_ar300m_spi0_cdata =
+{
+    .cs_type    = ATH79_SPI_CS_TYPE_INTERNAL,
+    .is_flash   = true,
+    .cs_line    = 0,
+};
+
+static struct ath79_spi_controller_data gl_ar300m_spi1_cdata =
+{
+    .cs_type    = ATH79_SPI_CS_TYPE_INTERNAL,
+    .is_flash   = false,
+    .cs_line    = 1,
+};
+
+static struct spi_board_info gl_ar300m_spi_info[] = {
+    {
+        .bus_num    = 0,
+        .chip_select    = 0,
+        .max_speed_hz   = 25000000,
+        .modalias   = "m25p80",
+        .controller_data = &gl_ar300m_spi0_cdata,
+        .platform_data  = NULL,
+    },
+    {
+        .bus_num    = 0,
+        .chip_select    = 1,
+        .max_speed_hz   = 25000000,
+        .modalias   = "ath79-spinand",
+        .controller_data = &gl_ar300m_spi1_cdata,
+        .platform_data  = NULL,
+    }
+};
+
+static struct ath79_spi_platform_data gl_ar300m_spi_data = {
+    .bus_num        = 0,
+    .num_chipselect     = 2,
+};
+
+static void __init gl_ar300m_setup(void)
+{
+    u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+    u8 tmpmac[ETH_ALEN];
+
+    ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+    ath79_register_spi(&gl_ar300m_spi_data, gl_ar300m_spi_info, 2);
+
+    /* register gpio LEDs and keys */
+    ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar300m_leds_gpio),
+                 gl_ar300m_leds_gpio);
+    ath79_register_gpio_keys_polled(-1, GL_AR300M_KEYS_POLL_INTERVAL,
+                    ARRAY_SIZE(gl_ar300m_gpio_keys),
+                    gl_ar300m_gpio_keys);
+
+    ath79_register_mdio(0, 0x0);
+
+    /* WAN */
+    ath79_init_mac(ath79_eth0_data.mac_addr, art + GL_AR300M_MAC0_OFFSET, 0);
+    ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+    ath79_eth0_data.speed = SPEED_100;
+    ath79_eth0_data.duplex = DUPLEX_FULL;
+    ath79_eth0_data.phy_mask = BIT(4);
+    ath79_register_eth(0);
+
+    /* LAN */
+    ath79_init_mac(ath79_eth1_data.mac_addr, art + GL_AR300M_MAC1_OFFSET, 0);
+    ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+    ath79_eth1_data.speed = SPEED_1000;
+    ath79_eth1_data.duplex = DUPLEX_FULL;
+    ath79_switch_data.phy_poll_mask |= BIT(4);
+    ath79_switch_data.phy4_mii_en = 1;
+    ath79_register_eth(1);
+
+    ath79_init_mac(tmpmac, art + GL_AR300M_WMAC_CALDATA_OFFSET + 2, 0);
+    ath79_register_wmac(art + GL_AR300M_WMAC_CALDATA_OFFSET, tmpmac);
+
+    /* enable usb */
+    ath79_register_usb();
+    /* enable pci */
+    ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR300M, "GL-AR300M", "GL-AR300M",
+         gl_ar300m_setup);
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -168,6 +168,15 @@ define Device/gl-ar300
 endef
 TARGET_DEVICES += gl-ar300
 
+define Device/gl-ar300m
+  BOARDNAME = GL-AR300M
+  IMAGE_SIZE = 16000k
+  CONSOLE = ttyS0,115200
+  MTDPARTS = spi0.0:256k(u-boot)ro,64k(u-boot-env),16000k(firmware),64k(art)ro;spi0.1:131072k(ubi)
+endef
+TARGET_DEVICES += gl-ar300m
+
+
 define Device/gl-domino
   BOARDNAME = DOMINO
   IMAGE_SIZE = 16000k
--- a/target/linux/ar71xx/config-3.18
+++ b/target/linux/ar71xx/config-3.18
@@ -71,6 +71,7 @@ CONFIG_ATH79_MACH_F9K1115V2=y
 CONFIG_ATH79_MACH_GL_AR150=y
 CONFIG_ATH79_MACH_GL_MIFI=y
 CONFIG_ATH79_MACH_GL_AR300=y
+CONFIG_ATH79_MACH_GL_AR300M=y
 CONFIG_ATH79_MACH_GL_DOMINO=y
 CONFIG_ATH79_MACH_GL_INET=y
 CONFIG_ATH79_MACH_GS_MINIBOX_V1=y
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -464,6 +464,9 @@ ar71xx_board_detect() {
 	*"GL-AR150")
         name="gl-ar150"
         ;;
+	*"GL-AR300M")
+		name="gl-ar300m"
+		;;
 	*"GL-MIFI")
         name="gl-mifi"
         ;;
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -214,6 +214,7 @@ platform_check_image() {
 	gl-ar150 | \
 	gl-mifi | \
 	gl-ar300 | \
+	gl-ar300m | \
 	gl-domino | \
 	epg5000 | \
 	esr1750 | \
--- a/target/linux/ar71xx/generic/profiles/gli.mk
+++ b/target/linux/ar71xx/generic/profiles/gli.mk
@@ -56,3 +56,13 @@ define Profile/GL-MIFI/Description
 	Configuration of GL-MIFI.
 endef
 $(eval $(call Profile,GL-MIFI))
+
+define Profile/GL-AR300M
+	NAME:=GL-AR300M
+	PACKAGES:= kmod-usb-core kmod-usb2 mod-usb-storage kmod-ledtrig-usbdev kmod-ledtrig-gpio
+endef
+
+define Profile/GL-AR300M/description
+	Package set optimized for the GL-AR300M.
+endef
+$(eval $(call Profile,GL-AR300M))
--- /dev/null
+++ b/target/linux/ar71xx/patches-3.18/917-MIPS-ath79-add-gl_ar300m.patch
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -563,6 +563,16 @@ config ATH79_MACH_GL_AR300
+    select ATH79_DEV_USB
+    select ATH79_DEV_WMAC
+ 
++config ATH79_MACH_GL_AR300M
++   bool "GL_AR300M support"
++   select SOC_QCA953X
++   select ATH79_DEV_ETH
++   select ATH79_DEV_GPIO_BUTTONS
++   select ATH79_DEV_LEDS_GPIO
++   select ATH79_DEV_M25P80
++   select ATH79_DEV_USB
++   select ATH79_DEV_WMAC
++
+ config ATH79_MACH_GL_DOMINO
+    bool "DOMINO support"
+    select SOC_AR933X
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -81,6 +81,7 @@ obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= ma
+ obj-$(CONFIG_ATH79_MACH_GL_AR150)	+= mach-gl-ar150.o
+ obj-$(CONFIG_ATH79_MACH_GL_MIFI)	+= mach-gl-mifi.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR300)	+= mach-gl-ar300.o
++obj-$(CONFIG_ATH79_MACH_GL_AR300M)    += mach-gl-ar300m.o
+ obj-$(CONFIG_ATH79_MACH_GL_DOMINO)	+= mach-gl-domino.o
+ obj-$(CONFIG_ATH79_MACH_GL_INET)	+= mach-gl-inet.o
+ obj-$(CONFIG_ATH79_MACH_GS_MINIBOX_V1)	+= mach-gs-minibox-v1.o
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -70,6 +70,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_GL_AR150,	/* GL-AR150 support */
+ 	ATH79_MACH_GL_MIFI,	    /* GL-MIFI support */
+ 	ATH79_MACH_GL_AR300,		/* GL-AR300 */
++	ATH79_MACH_GL_AR300M,		/* GL-AR300M */
+ 	ATH79_MACH_GL_DOMINO,		/* Domino */
+ 	ATH79_MACH_GL_INET,		/* GL-CONNECT GL-INET */
+ 	ATH79_MACH_GS_MINIBOX_V1,	/* Gainstrong MiniBox V1.0 */
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -157,6 +157,37 @@ alfa_check_image() {
 	return 0
 }
 
+gl_ar300m_is_nand() {
+	local size="$(mtd_get_part_size 'ubi')"
+	case "$size" in
+	132120576)
+		return 0
+		;;
+	*)
+		return 1
+		;;
+	esac
+}
+
+# $(1) image file
+# $(2) board name
+# $(3) magic
+platform_check_image_gl_ar300m() {
+	local board=$2
+	local magic=$3
+
+	if gl_ar300m_is_nand; then
+		nand_do_platform_check $board $1
+		return $?
+	else
+		[ "$magic" != "2705" ] && {
+			echo "Invalid image type."
+			return 1
+		}
+		return 0
+	fi
+}
+
 platform_check_image() {
 	local board=$(ar71xx_board_name)
 	local magic="$(get_magic_word "$1")"
@@ -171,6 +202,10 @@ platform_check_image() {
 		platform_check_image_allnet "$1" && return 0
 		return 1
 		;;
+	gl-ar300m)
+		platform_check_image_gl_ar300m "$1" "$board" "$magic" && return 0
+		return 1
+		;;
 	alfa-ap96 | \
 	alfa-nx | \
 	ap113 | \
@@ -474,10 +509,19 @@ platform_check_image() {
 	return 1
 }
 
+platform_pre_upgrade_gl_ar300m() {
+	if gl_ar300m_is_nand; then
+		nand_do_upgrade "$1"
+	fi
+}
+
 platform_pre_upgrade() {
 	local board=$(ar71xx_board_name)
 
 	case "$board" in
+	gl-ar300m)
+		platform_pre_upgrade_gl_ar300m "$1"
+		;;
 	nbg6716 | \
 	r6100 | \
 	wndr3700v4 | \
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -1078,6 +1078,7 @@ mynet_n600_mtdlayout=mtdparts=spi0.0:256
 mynet_rext_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,7808k(firmware),64k(nvram)ro,64k(ART)ro
 zyx_nbg6716_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(env)ro,64k(RFdata)ro,-(nbu);ar934x-nfc:2048k(zyxel_rfsd),2048k(romd),1024k(header),2048k(kernel),-(ubi)
 qihoo_c301_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env),64k(devdata),64k(devconf),15744k(firmware),64k(warm_start),64k(action_image_config),64k(radiocfg)ro;spi0.1:15360k(upgrade2),1024k(privatedata)
+gl-ar300m-nand_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env),16000k(reserved),64k(art);spi0.1:2048k(kernel),-(ubi)
 
 
 define Image/BuildKernel
@@ -1851,6 +1852,34 @@ define Image/Build/ZyXELNAND
 	$(call Image/Build/SysupgradeNAND,$(2),squashfs,$(KDIR_TMP)/$(2)-kernel.jffs2)
 endef
 
+Image/Build/GLNAND/initramfs=$(call MkuImageLzma/initramfs,$(2),$(3) $(4))
+
+Image/Build/GLNAND/buildkernel=$(call MkuImageLzma,$(2),$(3) $(4))
+
+# $(1): rootfs image suffix
+# $(2): Board name (small caps)
+# $(3): Kernel board specific cmdline
+# $(4): Kernel mtdparts definition
+# $(5): suffix of the configuration file for ubinize
+define Image/Build/GLNAND
+	$(eval kernelsize=$(call mtdpartsize,kernel,$(4)))
+	$(CP) $(KDIR)/root.squashfs-raw $(KDIR_TMP)/root.squashfs
+	echo -ne '\xde\xad\xc0\xde' > $(KDIR_TMP)/jffs2.eof
+	$(call ubinize,ubinize-$(5).ini,$(KDIR_TMP),$(KDIR_TMP)/$(2)-root.ubi,128KiB,2048,)
+
+	( \
+		dd if=$(KDIR_TMP)/vmlinux-$(2).uImage \
+			of=$(call imgname,kernel,$(2)).bin conv=sync; \
+		dd if=$(KDIR_TMP)/$(2)-root.ubi \
+			of=$(call imgname,$(1),$(2)-rootfs).ubi bs=128k conv=sync; \
+	)
+	( \
+		dd if=$(call imgname,kernel,$(2)).bin bs=$(kernelsize) conv=sync; \
+		dd if=$(call imgname,$(1),$(2)-rootfs).ubi \
+	) > $(call imgname,ubi,$(2)).img
+
+	$(call Image/Build/SysupgradeNAND,$(2),squashfs,$(KDIR_TMP)/vmlinux-$(2).uImage)
+endef
 
 Image/Build/OpenMesh/buildkernel=$(call MkuImageLzma,$(2))
 
@@ -2161,6 +2190,8 @@ $(eval $(call SingleProfile,NetgearNAND,
 $(eval $(call SingleProfile,ZyXELNAND,128k,NBG6716,nbg6716,NBG6716,ttyS0,115200,NBG6716,$$(zyx_nbg6716_mtdlayout),mem=256M))
 
 $(eval $(call MultiProfile,WNDR4300,WNDR3700V4 WNDR4300V1))
+
+$(eval $(call SingleProfile,GLNAND,64k,GLAR300MNAND,gl-ar300m,GL-AR300M,ttyS0,115200,$$(gl-ar300m-nand_mtdlayout),gl-ar300m))
 endif # ifeq ($(SUBTARGET),nand)
 
 
--- /dev/null
+++ b/target/linux/ar71xx/image/ubinize-gl-ar300m.ini
@@ -0,0 +1,26 @@
+[rootfs]
+# Volume mode (other option is static)
+mode=ubi
+# Source image
+image=root.squashfs
+# Volume ID in UBI image
+vol_id=0
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs
+# Autoresize volume at first mount
+# vol_flags=autoresize
+
+[rootfs_data]
+# Volume mode (other option is static)
+mode=ubi
+# Volume ID in UBI image
+vol_id=1
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs_data
+# Autoresize volume at first mount
+vol_flags=autoresize
+vol_size=1MiB
--- /dev/null
+++ b/target/linux/ar71xx/nand/profiles/gl-inet.mk
@@ -0,0 +1,17 @@
+#
+# Copyright (C) 2009-2014 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+define Profile/GLAR300MNAND
+	NAME:=GL-AR300M NAND
+	PACKAGES:= kmod-usb-core kmod-usb2 mod-usb-storage \
+		kmod-ledtrig-usbdev kmod-ledtrig-gpio
+endef
+
+define Profile/GLAR300MNAND/description
+	Package set optimized for the GL-AR300M with nand flash.
+endef
+$(eval $(call Profile,GLAR300MNAND))
--- /dev/null
+++ b/target/linux/ar71xx/patches-3.18/908-MIPS-ath79-add-spi-nand-driver.patch
@@ -0,0 +1,52 @@
+Index: linux-3.18.23/drivers/mtd/nand/Kconfig
+===================================================================
+--- linux-3.18.23.orig/drivers/mtd/nand/Kconfig
++++ linux-3.18.23/drivers/mtd/nand/Kconfig
+@@ -536,4 +536,12 @@ config MTD_NAND_AR934X_HW_ECC
+ 	bool "Hardware ECC support for the AR934X NAND Controller (EXPERIMENTAL)"
+ 	depends on MTD_NAND_AR934X
+ 
++config MTD_NAND_ATH79
++      tristate "Nand flash support for Qualcomm-Atheros SoCs 71xx & 9xxx"
++      default n
++      depends on MTD_NAND && (SOC_AR724X || SOC_AR934X || SOC_QCA953X)
++      help
++        Enables the driver for NAND flash controller on Qualcomm-Atheros System on Chips
++        This controller is used on families AR71xx and AR9xxx.
++
+ endif # MTD_NAND
+Index: linux-3.18.23/drivers/mtd/nand/Makefile
+===================================================================
+--- linux-3.18.23.orig/drivers/mtd/nand/Makefile
++++ linux-3.18.23/drivers/mtd/nand/Makefile
+@@ -54,5 +54,6 @@ obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740
+ obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
+ obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
+ obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
++obj-$(CONFIG_MTD_NAND_ATH79)		+= ath79_spinand.o
+ 
+ nand-objs := nand_base.o nand_bbt.o nand_timings.o
+Index: linux-3.18.23/drivers/mtd/nand/nand_ids.c
+===================================================================
+--- linux-3.18.23.orig/drivers/mtd/nand/nand_ids.c
++++ linux-3.18.23/drivers/mtd/nand/nand_ids.c
+@@ -178,6 +178,7 @@ struct nand_manufacturers nand_manuf_ids
+ 	{NAND_MFR_EON, "Eon"},
+ 	{NAND_MFR_SANDISK, "SanDisk"},
+ 	{NAND_MFR_INTEL, "Intel"},
++	{NAND_MFR_GIGADEVICE, "Giga Device"},
+ 	{0x0, "Unknown"}
+ };
+ 
+Index: linux-3.18.23/include/linux/mtd/nand.h
+===================================================================
+--- linux-3.18.23.orig/include/linux/mtd/nand.h
++++ linux-3.18.23/include/linux/mtd/nand.h
+@@ -720,6 +720,7 @@ struct nand_chip {
+ #define NAND_MFR_MICRON		0x2c
+ #define NAND_MFR_AMD		0x01
+ #define NAND_MFR_MACRONIX	0xc2
++#define NAND_MFR_GIGADEVICE	0xc8
+ #define NAND_MFR_EON		0x92
+ #define NAND_MFR_SANDISK	0x45
+ #define NAND_MFR_INTEL		0x89
--- /dev/null
+++ b/target/linux/ar71xx/files/drivers/mtd/nand/ath79_spinand.c
@@ -0,0 +1,864 @@
+/*
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ *
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ *
+ * Copyright (c) 2009-2010 Micron Technology, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/spi/spi.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/mtd/mtd.h>
+
+/* cmd */
+#define CMD_READ			0x13
+#define CMD_READ_RDM			0x03
+#define CMD_PROG_PAGE_LOAD		0x02
+#define CMD_PROG_PAGE			0x84
+#define CMD_PROG_PAGE_EXC		0x10
+#define CMD_ERASE_BLK			0xd8
+#define CMD_WR_ENABLE			0x06
+#define CMD_WR_DISABLE			0x04
+#define CMD_READ_ID			0x9f
+#define CMD_RESET			0xff
+#define CMD_READ_REG			0x0f
+#define CMD_WRITE_REG			0x1f
+
+/* feature/ status reg */
+#define REG_BLOCK_LOCK			0xa0
+#define REG_OTP				0xb0
+#define REG_STATUS			0xc0
+
+/* status */
+#define STATUS_OIP_MASK			0x01
+#define STATUS_READY			(0 << 0)
+#define STATUS_BUSY			(1 << 0)
+
+#define STATUS_E_FAIL_MASK		0x04
+#define STATUS_E_FAIL			(1 << 2)
+
+#define STATUS_P_FAIL_MASK		0x08
+#define STATUS_P_FAIL			(1 << 3)
+
+#define STATUS_ECC_MASK			0x07
+#define STATUS_ECC_ERR_BITS5		0x03
+#define STATUS_ECC_ERR_BITS6		0x04
+#define STATUS_ECC_ERR_BITS7		0x05
+#define STATUS_ECC_ERR_BITS8		0x06
+#define STATUS_ECC_ERROR		0x07
+#define STATUS2ECC(status) 		(((status) >> 4) & STATUS_ECC_MASK)
+
+/* ECC/OTP enable defines */
+#define REG_ECC_MASK			0x10
+#define REG_ECC_OFF			(0 << 4)
+#define REG_ECC_ON			(1 << 4)
+
+#define REG_OTP_EN			(1 << 6)
+#define REG_OTP_PRT			(1 << 7)
+
+/* block lock */
+#define BL_ALL_UNLOCKED			0
+
+#define BLOCK_TO_RA(b)			((b) << 6)
+
+#define BUFSIZE				(10 * 64 * 2048)
+#define CACHE_BUF			2112
+
+struct ath79_spinand_info {
+	struct spi_device	*spi;
+	void			*priv;
+};
+
+struct ath79_spinand_state {
+	uint32_t	col;
+	uint32_t	row;
+	int		buf_ptr;
+	u8		*buf;
+};
+
+struct ath79_spinand_command {
+	u8		cmd;
+	u32		n_addr;		/* Number of address */
+	u8		addr[3];	/* Reg Offset */
+	u32		n_dummy;	/* Dummy use */
+	u32		n_tx;		/* Number of tx bytes */
+	u8		*tx_buf;	/* Tx buf */
+	u32		n_rx;		/* Number of rx bytes */
+	u8		*rx_buf;	/* Rx buf */
+};
+
+static const struct nand_ecclayout ath79_spinand_oob_128 = {
+	.eccbytes = 64,
+	.eccpos = {
+		64, 65, 66, 67, 68, 69, 70, 71,
+		72, 73, 74, 75, 76, 77, 78, 79,
+		80, 81, 82, 83, 84, 85, 86, 87,
+		88, 89, 90, 91, 92, 93, 94, 95,
+		96, 97, 98, 99, 100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127},
+	.oobavail = 48,
+	.oobfree = { {.offset = 16, .length = 48}, }
+};
+
+/* HeYang Tek spi nand */
+static struct nand_ecclayout hyt_spinand_oob_128 = {
+        .eccbytes       = 96,
+        .eccpos         = { 32, 33, 34, 35, 36, 37, 38, 39,
+                            40, 41, 42, 43, 44, 45, 46, 47,
+                            48, 49, 50, 51, 52, 53, 54, 55,
+                            56, 57, 58, 59, 60, 61, 62, 63,
+                            64, 65, 66, 67, 68, 69, 70, 71,
+                            72, 73, 74, 75, 76, 77, 78, 79,
+                            80, 81, 82, 83, 84, 85, 86, 87,
+                            88, 89, 90, 91, 92, 93, 94, 95,
+                            96, 97, 98, 99, 100, 101, 102, 103,
+                            104, 105, 106, 107, 108, 109, 110, 111,
+                            112, 113, 114, 115, 116, 117, 118, 119,
+                            120, 121, 122, 123, 124, 125, 126, 127},
+
+        /* Not including spare regions that are not ECC-ed */
+        .oobavail       = 32,
+        .oobfree        = { { .offset = 0, .length = 32 } },
+};
+
+static u8 badblock_pattern[] = { 0xff, };
+
+static struct nand_bbt_descr ath79_badblock_pattern = {
+	.options = 0,
+	.offs = 0,
+	.len = 1,
+	.pattern = badblock_pattern,
+};
+
+static inline struct ath79_spinand_state *mtd_to_state(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct ath79_spinand_info *info = (struct ath79_spinand_info *)chip->priv;
+	struct ath79_spinand_state *state = (struct ath79_spinand_state *)info->priv;
+
+	return state;
+}
+
+static int ath79_spinand_cmd(struct spi_device *spi, struct ath79_spinand_command *cmd)
+{
+	struct spi_message message;
+	struct spi_transfer x[4];
+	u8 dummy = 0xff;
+
+	spi_message_init(&message);
+	memset(x, 0, sizeof(x));
+
+	x[0].len = 1;
+	x[0].tx_buf = &cmd->cmd;
+	spi_message_add_tail(&x[0], &message);
+
+	if (cmd->n_addr) {
+		x[1].len = cmd->n_addr;
+		x[1].tx_buf = cmd->addr;
+		spi_message_add_tail(&x[1], &message);
+	}
+
+	if (cmd->n_dummy) {
+		x[2].len = cmd->n_dummy;
+		x[2].tx_buf = &dummy;
+		spi_message_add_tail(&x[2], &message);
+	}
+
+	if (cmd->n_tx) {
+		x[3].len = cmd->n_tx;
+		x[3].tx_buf = cmd->tx_buf;
+		spi_message_add_tail(&x[3], &message);
+	}
+
+	if (cmd->n_rx) {
+		x[3].len = cmd->n_rx;
+		x[3].rx_buf = cmd->rx_buf;
+		spi_message_add_tail(&x[3], &message);
+	}
+
+	return spi_sync(spi, &message);
+}
+
+static int ath79_spinand_read_id(struct spi_device *spi_nand, u8 *id)
+{
+	int retval;
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_READ_ID;
+	cmd.n_rx = 3;
+	cmd.rx_buf = id;
+
+	retval = ath79_spinand_cmd(spi_nand, &cmd);
+	if (retval < 0) {
+		dev_err(&spi_nand->dev, "error %d reading id\n", retval);
+		return retval;
+	}
+
+	/* GD conflict with cell info rules */
+	id[2] = 0;
+
+	return retval;
+}
+
+static int ath79_spinand_read_status(struct spi_device *spi_nand, uint8_t *status)
+{
+	struct ath79_spinand_command cmd = {0};
+	int ret;
+
+	cmd.cmd = CMD_READ_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_STATUS;
+	cmd.n_rx = 1;
+	cmd.rx_buf = status;
+
+	ret = ath79_spinand_cmd(spi_nand, &cmd);
+	if (ret < 0)
+		dev_err(&spi_nand->dev, "err: %d read status register\n", ret);
+
+	return ret;
+}
+
+#define MAX_WAIT_JIFFIES  (120 * HZ)
+static int __ath79_wait_till_ready(struct spi_device *spi_nand, u8 *status)
+{
+	unsigned long deadline;
+
+	deadline = jiffies + MAX_WAIT_JIFFIES;
+	do {
+		if (ath79_spinand_read_status(spi_nand, status))
+			return -1;
+		else if ((*status & STATUS_OIP_MASK) == STATUS_READY)
+			break;
+
+		cond_resched();
+	} while (!time_after_eq(jiffies, deadline));
+
+	return 0;
+}
+
+static int ath79_wait_till_ready(struct spi_device *spi_nand)
+{
+	u8 stat = 0;
+
+	if (__ath79_wait_till_ready(spi_nand, &stat))
+		return -1;
+
+	if ((stat & STATUS_OIP_MASK) == STATUS_READY)
+		return 0;
+
+	return -1;
+}
+
+static int ath79_spinand_get_otp(struct spi_device *spi_nand, u8 *otp)
+{
+	struct ath79_spinand_command cmd = {0};
+	int retval;
+
+	cmd.cmd = CMD_READ_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_OTP;
+	cmd.n_rx = 1;
+	cmd.rx_buf = otp;
+
+	retval = ath79_spinand_cmd(spi_nand, &cmd);
+	if (retval < 0)
+		dev_err(&spi_nand->dev, "error %d get otp\n", retval);
+
+	return retval;
+}
+
+static int ath79_spinand_set_otp(struct spi_device *spi_nand, u8 *otp)
+{
+	int retval;
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_WRITE_REG,
+	cmd.n_addr = 1,
+	cmd.addr[0] = REG_OTP,
+	cmd.n_tx = 1,
+	cmd.tx_buf = otp,
+
+	retval = ath79_spinand_cmd(spi_nand, &cmd);
+	if (retval < 0)
+		dev_err(&spi_nand->dev, "error %d set otp\n", retval);
+
+	return retval;
+}
+
+static int ath79_spinand_enable_ecc(struct spi_device *spi_nand)
+{
+	u8 otp = 0;
+
+	if (ath79_spinand_get_otp(spi_nand, &otp))
+		return -1;
+
+	if ((otp & REG_ECC_MASK) == REG_ECC_ON)
+		return 0;
+
+	otp |= REG_ECC_ON;
+	if (ath79_spinand_set_otp(spi_nand, &otp))
+		return -1;
+
+	return ath79_spinand_get_otp(spi_nand, &otp);
+}
+
+static int ath79_spinand_disable_ecc(struct spi_device *spi_nand)
+{
+	u8 otp = 0;
+
+	if (ath79_spinand_get_otp(spi_nand, &otp))
+		return -1;
+
+	if ((otp & REG_ECC_MASK) == REG_ECC_OFF)
+		return 0;
+
+	otp &= ~REG_ECC_MASK;
+	if (ath79_spinand_set_otp(spi_nand, &otp))
+		return -1;
+
+	return ath79_spinand_get_otp(spi_nand, &otp);
+}
+
+static int ath79_spinand_write_enable(struct spi_device *spi_nand)
+{
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_WR_ENABLE;
+
+	return ath79_spinand_cmd(spi_nand, &cmd);
+}
+
+static int ath79_spinand_read_page_to_cache(struct spi_device *spi_nand, u32 page_id)
+{
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_READ;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(page_id >> 16);
+	cmd.addr[1] = (u8)(page_id >> 8);
+	cmd.addr[2] = (u8)(page_id >> 0);
+
+	return ath79_spinand_cmd(spi_nand, &cmd);
+}
+
+static int ath79_spinand_read_from_cache(struct spi_device *spi_nand,
+		u32 offset, u32 len, u8 *rbuf)
+{
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_READ_RDM;
+	cmd.n_addr = 3;
+	cmd.addr[0] = 0;
+	cmd.addr[1] = (u8)(offset >> 8);
+	cmd.addr[2] = (u8)(offset >> 0);
+	cmd.n_dummy = 0;
+	cmd.n_rx = len;
+	cmd.rx_buf = rbuf;
+
+	return ath79_spinand_cmd(spi_nand, &cmd);
+}
+
+static int ath79_spinand_read_page(struct spi_device *spi_nand, u32 page_id,
+		u32 offset, u32 len, u8 *rbuf)
+{
+	int ret;
+	u8 status = 0;
+
+	ret = ath79_spinand_read_page_to_cache(spi_nand, page_id);
+	if (ret < 0) {
+		dev_err(&spi_nand->dev, "Read page to cache failed!\n");
+		return ret;
+	}
+
+	if (__ath79_wait_till_ready(spi_nand, &status)) {
+		dev_err(&spi_nand->dev, "WAIT timedout!\n");
+		return -EBUSY;
+	}
+
+	if ((status & STATUS_OIP_MASK) != STATUS_READY)
+		return -EBUSY;
+
+	if (STATUS2ECC(status) == STATUS_ECC_ERROR) {
+		dev_err(&spi_nand->dev,
+			"ecc error, page=%d\n", page_id);
+
+		return -1;
+	}
+
+	ret = ath79_spinand_read_from_cache(spi_nand, offset, len, rbuf);
+	if (ret < 0) {
+		dev_err(&spi_nand->dev, "read from cache failed!!\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ath79_spinand_program_data_to_cache(struct spi_device *spi_nand,
+		u32 offset, u32 len, u8 *wbuf)
+{
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_PROG_PAGE_LOAD;
+	cmd.n_addr = 2;
+	cmd.addr[0] = 0;
+	cmd.addr[1] = 0;;
+	cmd.n_tx = len;
+	cmd.tx_buf = wbuf;
+
+	return ath79_spinand_cmd(spi_nand, &cmd);
+}
+
+static int ath79_spinand_program_execute(struct spi_device *spi_nand, u32 page_id)
+{
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_PROG_PAGE_EXC;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(page_id >> 16);
+	cmd.addr[1] = (u8)(page_id >> 8);
+	cmd.addr[2] = (u8)(page_id >> 0);
+
+	return ath79_spinand_cmd(spi_nand, &cmd);
+}
+
+static int ath79_spinand_program_page(struct spi_device *spi_nand,
+		u32 page_id, u32 offset, u32 len, u8 *buf)
+{
+	int retval;
+	u8 status = 0;
+	uint8_t *wbuf;
+	unsigned int i, j;
+
+	wbuf = devm_kzalloc(&spi_nand->dev, CACHE_BUF, GFP_KERNEL);
+	if (!wbuf) {
+		dev_err(&spi_nand->dev, "No memory\n");
+		return -ENOMEM;
+	}
+
+	if (ath79_spinand_read_page(spi_nand, page_id, 0, CACHE_BUF, wbuf)) {
+		devm_kfree(&spi_nand->dev, wbuf);
+		return -1;
+	}
+
+	for (i = offset, j = 0; i < len; i++, j++)
+		wbuf[i] &= buf[j];
+
+	retval = ath79_spinand_program_data_to_cache(spi_nand, offset,
+						     len, wbuf);
+
+	devm_kfree(&spi_nand->dev, wbuf);
+
+	if (retval < 0) {
+		dev_err(&spi_nand->dev, "program data to cache failed\n");
+		return retval;
+	}
+
+	retval = ath79_spinand_write_enable(spi_nand);
+	if (retval < 0) {
+		dev_err(&spi_nand->dev, "write enable failed!!\n");
+		return retval;
+	}
+
+	if (ath79_wait_till_ready(spi_nand)) {
+		dev_err(&spi_nand->dev, "wait timedout!!!\n");
+		return -EBUSY;
+	}
+
+	retval = ath79_spinand_program_execute(spi_nand, page_id);
+	if (retval < 0) {
+		dev_err(&spi_nand->dev, "program execute failed\n");
+		return retval;
+	}
+
+	if (__ath79_wait_till_ready(spi_nand, &status)) {
+		dev_err(&spi_nand->dev, "wait timedout!!!\n");
+		return -EBUSY;
+	}
+
+	if ((status & STATUS_OIP_MASK) != STATUS_READY)
+		return -EBUSY;
+
+	if ((status & STATUS_P_FAIL_MASK) == STATUS_P_FAIL) {
+		dev_err(&spi_nand->dev,
+			"program error, page %d\n", page_id);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ath79_spinand_erase_block_erase(struct spi_device *spi_nand, u32 block_id)
+{
+	struct ath79_spinand_command cmd = {0};
+	u32 row = BLOCK_TO_RA(block_id);
+
+	cmd.cmd = CMD_ERASE_BLK;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(row >> 16);
+	cmd.addr[1] = (u8)(row >> 8);
+	cmd.addr[2] = (u8)(row >> 0);
+
+	return ath79_spinand_cmd(spi_nand, &cmd);
+}
+
+static int ath79_spinand_erase_block(struct mtd_info *mtd,
+		struct spi_device *spi_nand, u32 page)
+{
+	int retval;
+	u8 status = 0;
+	u32 block_id = page >> (mtd->erasesize_shift - mtd->writesize_shift);
+
+	retval = ath79_spinand_write_enable(spi_nand);
+	if (retval < 0) {
+		dev_err(&spi_nand->dev, "write enable failed!\n");
+		return retval;
+	}
+
+	if (ath79_wait_till_ready(spi_nand)) {
+		dev_err(&spi_nand->dev, "wait timedout!\n");
+		return -EBUSY;
+	}
+
+	retval = ath79_spinand_erase_block_erase(spi_nand, block_id);
+	if (retval < 0) {
+		dev_err(&spi_nand->dev, "erase block failed!\n");
+		return retval;
+	}
+
+	if (__ath79_wait_till_ready(spi_nand, &status)) {
+		dev_err(&spi_nand->dev, "wait timedout!\n");
+		return -EBUSY;
+	}
+
+	if ((status & STATUS_OIP_MASK) != STATUS_READY)
+		return -EBUSY;
+
+	if ((status & STATUS_E_FAIL_MASK) == STATUS_E_FAIL) {
+		dev_err(&spi_nand->dev,
+			"erase error, block %d\n", block_id);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void ath79_spinand_write_page_hwecc(struct mtd_info *mtd,
+		struct nand_chip *chip, const uint8_t *buf)
+{
+	chip->write_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+}
+
+static int ath79_spinand_read_page_hwecc(struct mtd_info *mtd,
+		struct nand_chip *chip, uint8_t *buf, int page)
+{
+	u8 status;
+	uint8_t *p = buf;
+	struct ath79_spinand_info *info =
+			(struct ath79_spinand_info *)chip->priv;
+	struct spi_device *spi_nand = info->spi;
+
+	chip->read_buf(mtd, p, chip->ecc.size * chip->ecc.steps);
+
+	if (__ath79_wait_till_ready(spi_nand, &status)) {
+		dev_err(&spi_nand->dev, "wait timedout!\n");
+		return -EBUSY;
+	}
+
+	if ((status & STATUS_OIP_MASK) != STATUS_READY)
+		return -EBUSY;
+
+	if (STATUS2ECC(status) == STATUS_ECC_ERROR) {
+		pr_info("%s: ECC error\n", __func__);
+		mtd->ecc_stats.failed++;
+	} else if (STATUS2ECC(status) >= STATUS_ECC_ERR_BITS7) {
+		pr_debug("%s: ECC error %d corrected\n",
+			 __func__, STATUS2ECC(status));
+		mtd->ecc_stats.corrected++;
+	}
+
+	return 0;
+}
+
+static void ath79_spinand_select_chip(struct mtd_info *mtd, int dev)
+{
+}
+
+static uint8_t ath79_spinand_read_byte(struct mtd_info *mtd)
+{
+	struct ath79_spinand_state *state = mtd_to_state(mtd);
+
+	return state->buf[state->buf_ptr++];
+}
+
+static int ath79_spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct ath79_spinand_info *info = (struct ath79_spinand_info *)chip->priv;
+	unsigned long timeo = jiffies;
+	u8 status;
+
+	if (chip->state == FL_ERASING)
+		timeo += (HZ * 400) / 1000;
+	else
+		timeo += (HZ * 20) / 1000;
+
+	while (time_before(jiffies, timeo)) {
+		if (ath79_spinand_read_status(info->spi, &status))
+			return -1;
+
+		if ((status & STATUS_OIP_MASK) == STATUS_READY)
+			return 0;
+
+		cond_resched();
+	}
+	return 0;
+}
+
+static void ath79_spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct ath79_spinand_state *state = mtd_to_state(mtd);
+
+	memcpy(state->buf + state->buf_ptr, buf, len);
+	state->buf_ptr += len;
+}
+
+static void ath79_spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct ath79_spinand_state *state = mtd_to_state(mtd);
+
+	memcpy(buf, state->buf + state->buf_ptr, len);
+	state->buf_ptr += len;
+}
+
+static void ath79_spinand_reset(struct spi_device *spi_nand)
+{
+	struct ath79_spinand_command cmd = {0};
+
+	cmd.cmd = CMD_RESET;
+
+	if (ath79_spinand_cmd(spi_nand, &cmd) < 0)
+		pr_info("ath79_spinand reset failed!\n");
+
+	/* elapse 1ms before issuing any other command */
+	udelay(1000);
+
+	if (ath79_wait_till_ready(spi_nand))
+		dev_err(&spi_nand->dev, "wait timedout!\n");
+}
+
+static void ath79_spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
+		int column, int page)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct ath79_spinand_info *info = (struct ath79_spinand_info *)chip->priv;
+	struct ath79_spinand_state *state = (struct ath79_spinand_state *)info->priv;
+
+	switch (command) {
+	case NAND_CMD_READ1:
+	case NAND_CMD_READ0:
+		state->buf_ptr = 0;
+		ath79_spinand_read_page(info->spi, page, 0x0,
+					mtd->writesize + mtd->oobsize,
+					state->buf);
+		break;
+	case NAND_CMD_READOOB:
+		state->buf_ptr = 0;
+		ath79_spinand_read_page(info->spi, page, mtd->writesize,
+					mtd->oobsize, state->buf);
+		break;
+	case NAND_CMD_RNDOUT:
+		state->buf_ptr = column;
+		break;
+	case NAND_CMD_READID:
+		state->buf_ptr = 0;
+		ath79_spinand_read_id(info->spi, (u8 *)state->buf);
+		break;
+	case NAND_CMD_PARAM:
+		state->buf_ptr = 0;
+		break;
+	/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+		ath79_spinand_erase_block(mtd, info->spi, page);
+		break;
+	/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+		break;
+	/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN:
+		state->col = column;
+		state->row = page;
+		state->buf_ptr = 0;
+		break;
+	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG:
+		ath79_spinand_program_page(info->spi, state->row, state->col,
+					   state->buf_ptr, state->buf);
+		break;
+	case NAND_CMD_STATUS:
+		ath79_spinand_get_otp(info->spi, state->buf);
+		if (!(state->buf[0] & REG_OTP_PRT))
+			state->buf[0] = REG_OTP_PRT;
+		state->buf_ptr = 0;
+		break;
+	/* RESET command */
+	case NAND_CMD_RESET:
+		if (ath79_wait_till_ready(info->spi))
+			dev_err(&info->spi->dev, "WAIT timedout!!!\n");
+
+		/* a minimum of 250us must elapse before issuing RESET cmd*/
+		udelay(250);
+		ath79_spinand_reset(info->spi);
+		break;
+	default:
+		dev_err(&mtd->dev, "Unknown CMD: 0x%x\n", command);
+	}
+}
+
+static int ath79_spinand_lock_block(struct spi_device *spi_nand, u8 lock)
+{
+	struct ath79_spinand_command cmd = {0};
+	int ret;
+
+	cmd.cmd = CMD_WRITE_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_BLOCK_LOCK;
+	cmd.n_tx = 1;
+	cmd.tx_buf = &lock;
+
+	ret = ath79_spinand_cmd(spi_nand, &cmd);
+	if (ret < 0)
+		dev_err(&spi_nand->dev, "error %d lock block\n", ret);
+
+	return ret;
+}
+
+static int ath79_spinand_init_size(struct mtd_info *mtd, struct nand_chip *this, u8 *id_data)
+{
+        return NAND_BUSWIDTH_16;
+}
+
+static int ath79_spinand_probe(struct spi_device *spi_nand)
+{
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	struct ath79_spinand_info *info;
+	struct ath79_spinand_state *state;
+	u8 id[3];
+
+	info  = devm_kzalloc(&spi_nand->dev, sizeof(struct ath79_spinand_info),
+			GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->spi = spi_nand;
+
+	ath79_spinand_lock_block(spi_nand, BL_ALL_UNLOCKED);
+	ath79_spinand_disable_ecc(spi_nand);
+
+	state = devm_kzalloc(&spi_nand->dev, sizeof(struct ath79_spinand_state),
+			     GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	info->priv	= state;
+	state->buf_ptr	= 0;
+	state->buf	= devm_kzalloc(&spi_nand->dev, BUFSIZE, GFP_KERNEL);
+	if (!state->buf)
+		return -ENOMEM;
+
+	chip = devm_kzalloc(&spi_nand->dev, sizeof(struct nand_chip),
+			    GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->ecc.mode	= NAND_ECC_HW;
+	chip->ecc.size	= 512;
+	chip->ecc.strength = 1;
+
+	ath79_spinand_read_id(spi_nand, id);
+	if (id[1] == 0x59) {
+		chip->ecc.bytes	= 24;
+		chip->ecc.layout = (void *)&hyt_spinand_oob_128;
+	} else {
+		chip->ecc.bytes	= 16;
+		chip->ecc.layout = (void *)&ath79_spinand_oob_128;
+	}
+
+	chip->badblock_pattern = &ath79_badblock_pattern;
+	chip->ecc.read_page = ath79_spinand_read_page_hwecc;
+	chip->ecc.write_page = ath79_spinand_write_page_hwecc;
+
+	chip->priv	= info;
+	chip->read_buf	= ath79_spinand_read_buf;
+	chip->write_buf	= ath79_spinand_write_buf;
+	chip->read_byte	= ath79_spinand_read_byte;
+	chip->cmdfunc	= ath79_spinand_cmdfunc;
+	chip->waitfunc	= ath79_spinand_wait;
+	chip->options	= NAND_CACHEPRG | NAND_NO_SUBPAGE_WRITE | NAND_BUSWIDTH_16;
+	chip->select_chip = ath79_spinand_select_chip;
+	chip->init_size = ath79_spinand_init_size;
+
+	mtd = devm_kzalloc(&spi_nand->dev, sizeof(struct mtd_info), GFP_KERNEL);
+	if (!mtd)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi_nand->dev, mtd);
+
+	mtd->priv		= chip;
+	mtd->name		= dev_name(&spi_nand->dev);
+	mtd->oobsize		= 128;
+	mtd->writesize_shift	= 11;
+	mtd->writesize		= (1 << mtd->writesize_shift);
+	mtd->writesize_mask	= (mtd->writesize - 1);
+	mtd->erasesize_shift	= 17;
+	mtd->erasesize		= (1 << mtd->erasesize_shift);
+	mtd->erasesize_mask	= (mtd->erasesize - 1);
+	mtd->owner		= THIS_MODULE;
+
+	if (nand_scan(mtd, 1))
+		return -ENXIO;
+
+	ath79_spinand_enable_ecc(spi_nand);
+
+	return mtd_device_parse_register(mtd, NULL, NULL, NULL, 0);
+}
+
+static int ath79_spinand_remove(struct spi_device *spi)
+{
+	mtd_device_unregister(dev_get_drvdata(&spi->dev));
+
+	return 0;
+}
+
+static struct spi_driver ath79_spinand_driver = {
+	.driver = {
+		.name		= "ath79-spinand",
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= ath79_spinand_probe,
+	.remove		= ath79_spinand_remove,
+};
+
+module_spi_driver(ath79_spinand_driver);
+
+MODULE_DESCRIPTION("SPI NAND driver for Giga Device");
+MODULE_LICENSE("GPL v2");
--- a/target/linux/ar71xx/nand/config-default
+++ b/target/linux/ar71xx/nand/config-default
@@ -90,6 +90,7 @@ CONFIG_MTD_NAND=y
 CONFIG_MTD_NAND_AR934X=y
 CONFIG_MTD_NAND_AR934X_HW_ECC=y
 CONFIG_MTD_NAND_ECC=y
+CONFIG_MTD_NAND_ATH79=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_SM_COMMON is not set
 # CONFIG_MTD_SPLIT_SEAMA_FW is not set
--- a/target/linux/ar71xx/config-3.18.orig	2017-10-19 18:23:02.583642090 -0400
+++ b/target/linux/ar71xx/config-3.18	2017-10-19 21:24:00.470223692 -0400
@@ -348,3 +350,4 @@
 CONFIG_TICK_CPU_ACCOUNTING=y
 CONFIG_USB_SUPPORT=y
 CONFIG_ZONE_DMA_FLAG=0
+# CONFIG_MTD_NAND_ATH79 is not set
--- /dev/null	2017-10-11 14:40:33.204414021 -0400
+++ b/target/linux/ar71xx/patches-3.18/916-MIPS-ath79-add-gl_mifi_driver.patch	2017-10-17 15:23:04.250761136 -0400
@@ -0,0 +1,194 @@
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -1078,6 +1078,7 @@
+ 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x06, 0x7A) },
+ 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x06, 0x7B) },
+ 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x06, 0x7C) },
++	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x06, 0x7D) },
+ 
+ 
+ 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V640) },
+@@ -2032,6 +2033,11 @@
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD200, 0xff, 0xff, 0xff) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_6802, 0xff, 0xff, 0xff) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD300, 0xff, 0xff, 0xff) },
++	{ USB_DEVICE(0x05C6, 0x9090) },              //For Quectell UC15
++	{ USB_DEVICE(0x05C6, 0x9003) },              //For Quectel UC20
++	{ USB_DEVICE(0x05C6, 0x9215) },             //For Quectel EC20
++	{ USB_DEVICE(0x2c7c, 0x0125) },             //For Quectel EC25 EC20 R2.0
++	{ USB_DEVICE(ZTE_VENDOR_ID, 0x0016) }, //For ZTE ME3620
+ 	{ } /* Terminating entry */
+ };
+ MODULE_DEVICE_TABLE(usb, option_ids);
+@@ -2066,6 +2072,7 @@
+ #ifdef CONFIG_PM
+ 	.suspend           = usb_wwan_suspend,
+ 	.resume            = usb_wwan_resume,
++	.reset_resume      = usb_wwan_resume,
+ #endif
+ };
+ 
+@@ -2146,6 +2153,11 @@
+ 	struct usb_wwan_intf_private *data;
+ 	struct option_private *priv;
+ 
++    if (serial->dev->descriptor.idVendor == HUAWEI_VENDOR_ID) {
++		if ( 0 != (serial->dev->config->desc.bmAttributes & 0x20)){
++			usb_enable_autosuspend(serial->dev);
++		}
++	}
+ 	data = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+@@ -2170,6 +2182,15 @@
+ 	}
+ 	spin_lock_init(&data->susp_lock);
+ 
++	//Quectel UC20's interface 4 can be used as USB Network device
++	if (serial->dev->descriptor.idVendor == 0x05C6 && serial->dev->descriptor.idProduct ==0x9003 &&
++		serial->interface->cur_altsetting->desc.bInterfaceNumber == 4)
++		return -ENODEV;
++	//Quectel EC20's interface 4 can be used as USB Network device
++	if (serial->dev->descriptor.idVendor == 0x05C6 && serial->dev->descriptor.idProduct ==0x9215 &&
++		serial->interface->cur_altsetting->desc.bInterfaceNumber == 4)
++		return -ENODEV;
++
+ 	usb_set_serial_data(serial, data);
+ 
+ 	return 0;
+--- a/drivers/usb/serial/qcserial.c
++++ b/drivers/usb/serial/qcserial.c
+@@ -90,7 +90,6 @@ static const struct usb_device_id id_tab
+ 	{USB_DEVICE(0x03f0, 0x241d)},	/* HP Gobi 2000 QDL device (VP412) */
+ 	{USB_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
+ 	{USB_DEVICE(0x05c6, 0x9214)},	/* Acer Gobi 2000 QDL device (VP413) */
+-	{USB_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
+ 	{USB_DEVICE(0x05c6, 0x9264)},	/* Asus Gobi 2000 QDL device (VR305) */
+ 	{USB_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
+ 	{USB_DEVICE(0x05c6, 0x9234)},	/* Top Global Gobi 2000 QDL device (VR306) */
+--- a/drivers/usb/serial/usb-wwan.h
++++ b/drivers/usb/serial/usb-wwan.h
+@@ -30,6 +30,8 @@ extern int usb_wwan_resume(struct usb_se
+ #define N_OUT_URB 4
+ #define IN_BUFLEN 4096
+ #define OUT_BUFLEN 4096
++#define HW_bcdUSB 0x0110
++#define HUAWEI_VENDOR_ID 0x12d1
+ 
+ struct usb_wwan_intf_private {
+ 	spinlock_t susp_lock;
+--- a/drivers/usb/serial/usb_wwan.c
++++ b/drivers/usb/serial/usb_wwan.c
+@@ -186,6 +186,7 @@ int usb_wwan_write(struct tty_struct *tt
+ 	int i;
+ 	int left, todo;
+ 	struct urb *this_urb = NULL;	/* spurious */
++	struct usb_host_endpoint *ep=NULL;
+ 	int err;
+ 	unsigned long flags;
+ 
+@@ -222,6 +223,16 @@ int usb_wwan_write(struct tty_struct *tt
+ 		memcpy(this_urb->transfer_buffer, buf, todo);
+ 		this_urb->transfer_buffer_length = todo;
+ 
++		if((HUAWEI_VENDOR_ID == port->serial->dev->descriptor.idVendor)
++				&& (HW_bcdUSB != port->serial->dev->descriptor.bcdUSB)){
++					ep = usb_pipe_endpoint(this_urb->dev, this_urb->pipe);
++					if(ep && (0 != this_urb->transfer_buffer_length)
++							&& (0 == this_urb->transfer_buffer_length %
++								ep->desc.wMaxPacketSize)){
++									this_urb->transfer_flags |= URB_ZERO_PACKET;
++					}
++		}
++
+ 		spin_lock_irqsave(&intfdata->susp_lock, flags);
+ 		if (intfdata->suspended) {
+ 			usb_anchor_urb(this_urb, &portdata->delayed);
+@@ -471,6 +482,13 @@ static struct urb *usb_wwan_setup_urb(st
+ 			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
+ 			  buf, len, callback, ctx);
+ 
++	if (dir == USB_DIR_OUT) {
++		struct usb_device_descriptor *desc = &serial->dev->descriptor;
++		if (desc->idVendor == 0x05C6 && (desc->idProduct == 0x9003 || desc->idProduct ==
++					0x9090 || desc->idProduct == 0x9215))
++			urb->transfer_flags |= URB_ZERO_PACKET;
++	}
++
+ 	return urb;
+ }
+ 
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -554,7 +554,6 @@ static const struct usb_device_id produc
+ 	{QMI_FIXED_INTF(0x05c6, 0x8000, 7)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x8001, 6)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x9000, 4)},
+-	{QMI_FIXED_INTF(0x05c6, 0x9003, 4)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x9005, 2)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x900a, 4)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x900b, 2)},
+@@ -789,6 +788,8 @@ static const struct usb_device_id produc
+ 	{QMI_FIXED_INTF(0x413c, 0x81a4, 8)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a8, 8)},	/* Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a9, 8)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
++	{QMI_FIXED_INTF(0x05c6, 0x9003, 4)},	/* Quectel UC20 */
++	{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},	/* Quectel EC20 */
+ 
+ 	/* 4. Gobi 1000 devices */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9212)},	/* Acer Gobi Modem Device */
+@@ -818,7 +819,6 @@ static const struct usb_device_id produc
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9225)},	/* Sony Gobi 2000 Modem device (N0279, VU730) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9245)},	/* Samsung Gobi 2000 Modem device (VL176) */
+ 	{QMI_GOBI_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
+-	{QMI_GOBI_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9235)},	/* Top Global Gobi 2000 Modem device (VR306) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9275)},	/* iRex Technologies Gobi 2000 Modem device (VR307) */
+@@ -827,7 +827,6 @@ static const struct usb_device_id produc
+ 	{QMI_GOBI_DEVICE(0x1199, 0x68a9)},	/* Sierra Wireless Modem */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9001)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9002)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+-	{QMI_GOBI_DEVICE(0x1199, 0x9003)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9004)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9005)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9006)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+--- a/drivers/usb/class/cdc-wdm.c
++++ b/drivers/usb/class/cdc-wdm.c
+@@ -848,6 +848,18 @@ static int wdm_create(struct usb_interfa
+ 		goto err;
+ 	else
+ 		dev_info(&intf->dev, "%s: USB WDM device\n", dev_name(intf->usb_dev));
++		/* add Quectel auto connect feature */
++		usb_control_msg(
++			interface_to_usbdev(intf),
++			usb_sndctrlpipe(interface_to_usbdev(intf), 0),
++			0x22, //SET_CONTROL_LINE_STATE_REQUEST,
++			0x21, //SET_CONTROL_LINE_STATE_REQUEST_TYPE,
++			0x01, //CONTROL_DTR,
++			cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber),
++			NULL,
++			0,
++			100
++		);
+ out:
+ 	return rv;
+ err:
+@@ -962,6 +974,17 @@ static void wdm_disconnect(struct usb_in
+ 	usb_deregister_dev(intf, &wdm_class);
+ 	desc = wdm_find_device(intf);
+ 	mutex_lock(&wdm_mutex);
++	usb_control_msg(
++		interface_to_usbdev(intf),
++		usb_sndctrlpipe(interface_to_usbdev(intf), 0),
++		0x22, //SET_CONTROL_LINE_STATE_REQUEST,
++		0x21, //SET_CONTROL_LINE_STATE_REQUEST_TYPE,
++		0, // DTR not present
++		cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber),
++		NULL,
++		0,
++		100
++	);
+ 
+ 	/* the spinlock makes sure no new urbs are generated in the callbacks */
+ 	spin_lock_irqsave(&desc->iuspin, flags);
--- a/package/boot/uboot-envtools/files/ar71xx
+++ b/package/boot/uboot-envtools/files/ar71xx
@@ -18,6 +18,7 @@ all0258n | \
 cap4200ag | \
 carambola2 | \
 eap300v2 | \
+gl-ar300m | \
 hornet-ub | \
 hornet-ub-x2 | \
 mr600 | \
--- a/target/linux/ar71xx/base-files/etc/diag.sh
+++ b/target/linux/ar71xx/base-files/etc/diag.sh
@@ -371,6 +371,9 @@ set_state() {
 	done)
 		status_led_on
 		case $(ar71xx_board_name) in
+		gl-ar300m)
+			fw_printenv lc >/dev/null 2>&1 && fw_setenv "bootcount" 0
+			;;
 		qihoo-c301)
 			local n=$(fw_printenv activeregion | cut -d = -f 2)
 			fw_setenv "image${n}trynum" 0
diff --git a/target/linux/generic/config-3.18 b/target/linux/generic/config-3.18
index 6038692b7e..95d244a436 100644
--- a/target/linux/generic/config-3.18
+++ b/target/linux/generic/config-3.18
@@ -2057,7 +2057,7 @@ CONFIG_MII=y
 # CONFIG_MINIX_SUBPARTITION is not set
 # CONFIG_MIPS_ALCHEMY is not set
 # CONFIG_MIPS_COBALT is not set
-# CONFIG_MIPS_FPU_EMULATOR is not set
+CONFIG_MIPS_FPU_EMULATOR=y
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_O32_FP64_SUPPORT is not set
 # CONFIG_MIPS_PARAVIRT is not set
--- a/target/linux/generic/config-3.18	2017-02-23 16:31:59.631911320 -0500
+++ b/target/linux/generic/config-3.18	2017-03-09 12:37:26.762682027 -0500
@@ -702,7 +702,7 @@
 # CONFIG_CRYPTO_ANUBIS is not set
 # CONFIG_CRYPTO_ARC4 is not set
 # CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_BLKCIPHER is not set
+CONFIG_CRYPTO_BLKCIPHER=y
 # CONFIG_CRYPTO_BLOWFISH is not set
 # CONFIG_CRYPTO_CAMELLIA is not set
 # CONFIG_CRYPTO_CAST5 is not set
--- a/target/linux/generic/config-3.18	2017-02-23 16:31:59.631911320 -0500
+++ b/target/linux/generic/config-3.18	2017-03-09 12:37:26.762682027 -0500
@@ -2488,7 +2488,7 @@
 # CONFIG_NET_TCPPROBE is not set
 # CONFIG_NET_TEAM is not set
 # CONFIG_NET_TULIP is not set
-# CONFIG_NET_UDP_TUNNEL is not set
+CONFIG_NET_UDP_TUNNEL=y
 CONFIG_NET_VENDOR_3COM=y
 CONFIG_NET_VENDOR_8390=y
 CONFIG_NET_VENDOR_ADAPTEC=y
--- /dev/null	2017-09-02 14:33:48.061030748 -0400
+++ b/target/linux/ar71xx/patches-3.18/918-add-support-for-heyangtek-spi-nand-flash.patch	2017-09-05 23:06:37.725725742 -0400
@@ -0,0 +1,30 @@
+--- a/drivers/mtd/nand/nand_ids.c
++++ b/drivers/mtd/nand/nand_ids.c
+@@ -78,7 +78,8 @@ struct nand_flash_dev nand_flash_ids[] =
+ 	LEGACY_ID_NAND("NAND 128MiB 1,8V 16-bit", 0x72, 128, SZ_16K, SP_OPTIONS16),
+ 	LEGACY_ID_NAND("NAND 128MiB 1,8V 16-bit", 0x49, 128, SZ_16K, SP_OPTIONS16),
+ 	LEGACY_ID_NAND("NAND 128MiB 3,3V 16-bit", 0x74, 128, SZ_16K, SP_OPTIONS16),
+-	LEGACY_ID_NAND("NAND 128MiB 3,3V 16-bit", 0x59, 128, SZ_16K, SP_OPTIONS16),
++	/* LEGACY_ID_NAND("NAND 128MiB 3,3V 16-bit", 0x59, 128, SZ_16K, SP_OPTIONS16), */
++	EXTENDED_ID_NAND("NAND 128MiB 1,8V 16-bit", 0x59, 128, LP_OPTIONS16),
+ 
+ 	LEGACY_ID_NAND("NAND 256MiB 3,3V 8-bit", 0x71, 256, SZ_16K, SP_OPTIONS),
+ 
+@@ -179,6 +180,7 @@ struct nand_manufacturers nand_manuf_ids
+ 	{NAND_MFR_SANDISK, "SanDisk"},
+ 	{NAND_MFR_INTEL, "Intel"},
+ 	{NAND_MFR_GIGADEVICE, "Giga Device"},
++	{NAND_MFR_HEYANGTEK, "HeYang Tek"},
+ 	{0x0, "Unknown"}
+ };
+ 
+--- a/include/linux/mtd/nand.h
++++ b/include/linux/mtd/nand.h
+@@ -721,6 +721,7 @@ struct nand_chip {
+ #define NAND_MFR_AMD		0x01
+ #define NAND_MFR_MACRONIX	0xc2
+ #define NAND_MFR_GIGADEVICE	0xc8
++#define NAND_MFR_HEYANGTEK	0xc9
+ #define NAND_MFR_EON		0x92
+ #define NAND_MFR_SANDISK	0x45
+ #define NAND_MFR_INTEL		0x89
--- /dev/null	2017-09-02 14:33:48.061030748 -0400
+++ b/target/linux/ar71xx/patches-3.18/919-MIPS-ath79-add-gl_usb-support.patch	2017-09-05 23:06:37.725725742 -0400
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -543,6 +543,16 @@ config ATH79_MACH_GL_AR150
+    select ATH79_DEV_USB
+    select ATH79_DEV_WMAC
+ 
++config ATH79_MACH_GL_USB150
++   bool "GL USB nano router support"
++   select SOC_AR933X
++   select ATH79_DEV_ETH
++   select ATH79_DEV_GPIO_BUTTONS
++   select ATH79_DEV_LEDS_GPIO
++   select ATH79_DEV_M25P80
++   select ATH79_DEV_USB
++   select ATH79_DEV_WMAC
++
+ config ATH79_MACH_GL_MIFI
+ 	bool "GL MIFI support"
+ 	select SOC_AR933X
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -79,6 +79,7 @@ obj-$(CONFIG_ATH79_MACH_EPG5000)	+= mach
+ obj-$(CONFIG_ATH79_MACH_ESR1750)	+= mach-esr1750.o
+ obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= mach-f9k1115v2.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR150)	+= mach-gl-ar150.o
++obj-$(CONFIG_ATH79_MACH_GL_USB150)       += mach-gl-usb150.o
+ obj-$(CONFIG_ATH79_MACH_GL_MIFI)	+= mach-gl-mifi.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR300)	+= mach-gl-ar300.o
+ obj-$(CONFIG_ATH79_MACH_GL_AR300M)    += mach-gl-ar300m.o
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -68,6 +68,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_EPG5000,		/* EnGenius EPG5000 */
+ 	ATH79_MACH_F9K1115V2,		/* Belkin AC1750DB */
+ 	ATH79_MACH_GL_AR150,	/* GL-AR150 support */
++	ATH79_MACH_GL_USB150,	/* GL-USB150 nano router support */
+ 	ATH79_MACH_GL_MIFI,	    /* GL-MIFI support */
+ 	ATH79_MACH_GL_AR300,		/* GL-AR300 */
+ 	ATH79_MACH_GL_AR300M,		/* GL-AR300M */
--- /dev/null	2017-10-11 14:40:33.204414021 -0400
+++ b/target/linux/ar71xx/patches-3.18/920-use-qmi-driver-from-kernel-4.9.10.patch	2017-10-17 17:05:15.352114188 -0400
@@ -0,0 +1,746 @@
+--- a/drivers/net/usb/qmi_wwan.c	2017-10-17 16:50:20.295545655 -0400
++++ b/drivers/net/usb/qmi_wwan.c	2017-10-17 16:59:25.504098830 -0400
+@@ -14,7 +14,9 @@
+ #include <linux/netdevice.h>
+ #include <linux/ethtool.h>
+ #include <linux/etherdevice.h>
++#include <linux/if_arp.h>
+ #include <linux/mii.h>
++#include <linux/rtnetlink.h>
+ #include <linux/usb.h>
+ #include <linux/usb/cdc.h>
+ #include <linux/usb/usbnet.h>
+@@ -48,14 +50,109 @@
+ struct qmi_wwan_state {
+ 	struct usb_driver *subdriver;
+ 	atomic_t pmcount;
+-	unsigned long unused;
++	unsigned long flags;
+ 	struct usb_interface *control;
+ 	struct usb_interface *data;
+ };
+ 
++enum qmi_wwan_flags {
++	QMI_WWAN_FLAG_RAWIP = 1 << 0,
++};
++
++enum qmi_wwan_quirks {
++	QMI_WWAN_QUIRK_DTR = 1 << 0,	/* needs "set DTR" request */
++};
++
++static void qmi_wwan_netdev_setup(struct net_device *net)
++{
++	struct usbnet *dev = netdev_priv(net);
++	struct qmi_wwan_state *info = (void *)&dev->data;
++
++	if (info->flags & QMI_WWAN_FLAG_RAWIP) {
++		net->header_ops      = NULL;  /* No header */
++		net->type            = ARPHRD_NONE;
++		net->hard_header_len = 0;
++		net->addr_len        = 0;
++		net->flags           = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
++		netdev_dbg(net, "mode: raw IP\n");
++	} else if (!net->header_ops) { /* don't bother if already set */
++		ether_setup(net);
++		netdev_dbg(net, "mode: Ethernet\n");
++	}
++
++	/* recalculate buffers after changing hard_header_len */
++	usbnet_change_mtu(net, net->mtu);
++}
++
++static ssize_t raw_ip_show(struct device *d, struct device_attribute *attr, char *buf)
++{
++	struct usbnet *dev = netdev_priv(to_net_dev(d));
++	struct qmi_wwan_state *info = (void *)&dev->data;
++
++	return sprintf(buf, "%c\n", info->flags & QMI_WWAN_FLAG_RAWIP ? 'Y' : 'N');
++}
++
++static ssize_t raw_ip_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
++{
++	struct usbnet *dev = netdev_priv(to_net_dev(d));
++	struct qmi_wwan_state *info = (void *)&dev->data;
++	bool enable;
++	int ret;
++
++	if (strtobool(buf, &enable))
++		return -EINVAL;
++
++	/* no change? */
++	if (enable == (info->flags & QMI_WWAN_FLAG_RAWIP))
++		return len;
++
++	if (!rtnl_trylock())
++		return restart_syscall();
++
++	/* we don't want to modify a running netdev */
++	if (netif_running(dev->net)) {
++		netdev_err(dev->net, "Cannot change a running device\n");
++		ret = -EBUSY;
++		goto err;
++	}
++
++	/* let other drivers deny the change */
++	ret = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE, dev->net);
++	ret = notifier_to_errno(ret);
++	if (ret) {
++		netdev_err(dev->net, "Type change was refused\n");
++		goto err;
++	}
++
++	if (enable)
++		info->flags |= QMI_WWAN_FLAG_RAWIP;
++	else
++		info->flags &= ~QMI_WWAN_FLAG_RAWIP;
++	qmi_wwan_netdev_setup(dev->net);
++	call_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev->net);
++	ret = len;
++err:
++	rtnl_unlock();
++	return ret;
++}
++
++static DEVICE_ATTR_RW(raw_ip);
++
++static struct attribute *qmi_wwan_sysfs_attrs[] = {
++	&dev_attr_raw_ip.attr,
++	NULL,
++};
++
++static struct attribute_group qmi_wwan_sysfs_attr_group = {
++	.name = "qmi",
++	.attrs = qmi_wwan_sysfs_attrs,
++};
++
+ /* default ethernet address used by the modem */
+ static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+ 
++static const u8 buggy_fw_addr[ETH_ALEN] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};
++
+ /* Make up an ethernet header if the packet doesn't have one.
+  *
+  * A firmware bug common among several devices cause them to send raw
+@@ -78,6 +175,8 @@
+  */
+ static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+ {
++	struct qmi_wwan_state *info = (void *)&dev->data;
++	bool rawip = info->flags & QMI_WWAN_FLAG_RAWIP;
+ 	__be16 proto;
+ 
+ 	/* This check is no longer done by usbnet */
+@@ -92,21 +191,31 @@
+ 		proto = htons(ETH_P_IPV6);
+ 		break;
+ 	case 0x00:
++		if (rawip)
++			return 0;
+ 		if (is_multicast_ether_addr(skb->data))
+ 			return 1;
+ 		/* possibly bogus destination - rewrite just in case */
+ 		skb_reset_mac_header(skb);
+ 		goto fix_dest;
+ 	default:
++		if (rawip)
++			return 0;
+ 		/* pass along other packets without modifications */
+ 		return 1;
+ 	}
++	if (rawip) {
++		skb->dev = dev->net; /* normally set by eth_type_trans */
++		skb->protocol = proto;
++		return 1;
++	}
++
+ 	if (skb_headroom(skb) < ETH_HLEN)
+ 		return 0;
+ 	skb_push(skb, ETH_HLEN);
+ 	skb_reset_mac_header(skb);
+ 	eth_hdr(skb)->h_proto = proto;
+-	memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
++	eth_zero_addr(eth_hdr(skb)->h_source);
+ fix_dest:
+ 	memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+ 	return 1;
+@@ -221,17 +330,31 @@
+ 	return rv;
+ }
+ 
++/* Send CDC SetControlLineState request, setting or clearing the DTR.
++ * "Required for Autoconnect and 9x30 to wake up" according to the
++ * GobiNet driver. The requirement has been verified on an MDM9230
++ * based Sierra Wireless MC7455
++ */
++static int qmi_wwan_change_dtr(struct usbnet *dev, bool on)
++{
++	u8 intf = dev->intf->cur_altsetting->desc.bInterfaceNumber;
++
++	return usbnet_write_cmd(dev, USB_CDC_REQ_SET_CONTROL_LINE_STATE,
++				USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
++				on ? 0x01 : 0x00, intf, NULL, 0);
++}
++
+ static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)
+ {
+ 	int status = -1;
+ 	u8 *buf = intf->cur_altsetting->extra;
+ 	int len = intf->cur_altsetting->extralen;
+ 	struct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;
+-	struct usb_cdc_union_desc *cdc_union = NULL;
+-	struct usb_cdc_ether_desc *cdc_ether = NULL;
+-	u32 found = 0;
++	struct usb_cdc_union_desc *cdc_union;
++	struct usb_cdc_ether_desc *cdc_ether;
+ 	struct usb_driver *driver = driver_of(intf);
+ 	struct qmi_wwan_state *info = (void *)&dev->data;
++	struct usb_cdc_parsed_header hdr;
+ 
+ 	BUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <
+ 		      sizeof(struct qmi_wwan_state)));
+@@ -241,63 +364,9 @@
+ 	info->data = intf;
+ 
+ 	/* and a number of CDC descriptors */
+-	while (len > 3) {
+-		struct usb_descriptor_header *h = (void *)buf;
+-
+-		/* ignore any misplaced descriptors */
+-		if (h->bDescriptorType != USB_DT_CS_INTERFACE)
+-			goto next_desc;
+-
+-		/* buf[2] is CDC descriptor subtype */
+-		switch (buf[2]) {
+-		case USB_CDC_HEADER_TYPE:
+-			if (found & 1 << USB_CDC_HEADER_TYPE) {
+-				dev_dbg(&intf->dev, "extra CDC header\n");
+-				goto err;
+-			}
+-			if (h->bLength != sizeof(struct usb_cdc_header_desc)) {
+-				dev_dbg(&intf->dev, "CDC header len %u\n",
+-					h->bLength);
+-				goto err;
+-			}
+-			break;
+-		case USB_CDC_UNION_TYPE:
+-			if (found & 1 << USB_CDC_UNION_TYPE) {
+-				dev_dbg(&intf->dev, "extra CDC union\n");
+-				goto err;
+-			}
+-			if (h->bLength != sizeof(struct usb_cdc_union_desc)) {
+-				dev_dbg(&intf->dev, "CDC union len %u\n",
+-					h->bLength);
+-				goto err;
+-			}
+-			cdc_union = (struct usb_cdc_union_desc *)buf;
+-			break;
+-		case USB_CDC_ETHERNET_TYPE:
+-			if (found & 1 << USB_CDC_ETHERNET_TYPE) {
+-				dev_dbg(&intf->dev, "extra CDC ether\n");
+-				goto err;
+-			}
+-			if (h->bLength != sizeof(struct usb_cdc_ether_desc)) {
+-				dev_dbg(&intf->dev, "CDC ether len %u\n",
+-					h->bLength);
+-				goto err;
+-			}
+-			cdc_ether = (struct usb_cdc_ether_desc *)buf;
+-			break;
+-		}
+-
+-		/* Remember which CDC functional descriptors we've seen.  Works
+-		 * for all types we care about, of which USB_CDC_ETHERNET_TYPE
+-		 * (0x0f) is the highest numbered
+-		 */
+-		if (buf[2] < 32)
+-			found |= 1 << buf[2];
+-
+-next_desc:
+-		len -= h->bLength;
+-		buf += h->bLength;
+-	}
++	cdc_parse_cdc_header(&hdr, intf, buf, len);
++	cdc_union = hdr.usb_cdc_union_desc;
++	cdc_ether = hdr.usb_cdc_ether_desc;
+ 
+ 	/* Use separate control and data interfaces if we found a CDC Union */
+ 	if (cdc_union) {
+@@ -309,7 +378,10 @@
+ 				"bogus CDC Union: master=%u, slave=%u\n",
+ 				cdc_union->bMasterInterface0,
+ 				cdc_union->bSlaveInterface0);
+-			goto err;
++
++			/* ignore and continue... */
++			cdc_union = NULL;
++			info->data = intf;
+ 		}
+ 	}
+ 
+@@ -332,10 +404,35 @@
+ 		usb_driver_release_interface(driver, info->data);
+ 	}
+ 
+-	/* Never use the same address on both ends of the link, even
+-	 * if the buggy firmware told us to.
++	/* disabling remote wakeup on MDM9x30 devices has the same
++	 * effect as clearing DTR. The device will not respond to QMI
++	 * requests until we set DTR again.  This is similar to a
++	 * QMI_CTL SYNC request, clearing a lot of firmware state
++	 * including the client ID allocations.
++	 *
++	 * Our usage model allows a session to span multiple
++	 * open/close events, so we must prevent the firmware from
++	 * clearing out state the clients might need.
++	 *
++	 * MDM9x30 is the first QMI chipset with USB3 support. Abuse
++	 * this fact to enable the quirk for all USB3 devices.
++	 *
++	 * There are also chipsets with the same "set DTR" requirement
++	 * but without USB3 support.  Devices based on these chips
++	 * need a quirk flag in the device ID table.
+ 	 */
+-	if (ether_addr_equal(dev->net->dev_addr, default_modem_addr))
++	if (dev->driver_info->data & QMI_WWAN_QUIRK_DTR ||
++	    le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {
++		qmi_wwan_manage_power(dev, 1);
++		qmi_wwan_change_dtr(dev, true);
++	}
++
++	/* Never use the same address on both ends of the link, even if the
++	 * buggy firmware told us to. Or, if device is assigned the well-known
++	 * buggy firmware MAC address, replace it with a random address,
++	 */
++	if (ether_addr_equal(dev->net->dev_addr, default_modem_addr) ||
++	    ether_addr_equal(dev->net->dev_addr, buggy_fw_addr))
+ 		eth_hw_addr_random(dev->net);
+ 
+ 	/* make MAC addr easily distinguishable from an IP header */
+@@ -344,6 +441,7 @@
+ 		dev->net->dev_addr[0] &= 0xbf;	/* clear "IP" bit */
+ 	}
+ 	dev->net->netdev_ops = &qmi_wwan_netdev_ops;
++	dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
+ err:
+ 	return status;
+ }
+@@ -357,6 +455,12 @@
+ 	if (info->subdriver && info->subdriver->disconnect)
+ 		info->subdriver->disconnect(info->control);
+ 
++	/* disable MDM9x30 quirk */
++	if (le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {
++		qmi_wwan_change_dtr(dev, false);
++		qmi_wwan_manage_power(dev, 0);
++	}
++
+ 	/* allow user to unbind using either control or data */
+ 	if (intf == info->control)
+ 		other = info->data;
+@@ -431,6 +535,16 @@
+ 	.rx_fixup       = qmi_wwan_rx_fixup,
+ };
+ 
++static const struct driver_info	qmi_wwan_info_quirk_dtr = {
++	.description	= "WWAN/QMI device",
++	.flags		= FLAG_WWAN,
++	.bind		= qmi_wwan_bind,
++	.unbind		= qmi_wwan_unbind,
++	.manage_power	= qmi_wwan_manage_power,
++	.rx_fixup       = qmi_wwan_rx_fixup,
++	.data           = QMI_WWAN_QUIRK_DTR,
++};
++
+ #define HUAWEI_VENDOR_ID	0x12D1
+ 
+ /* map QMI/wwan function by a fixed interface number */
+@@ -438,6 +552,11 @@
+ 	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+ 	.driver_info = (unsigned long)&qmi_wwan_info
+ 
++/* devices requiring "set DTR" quirk */
++#define QMI_QUIRK_SET_DTR(vend, prod, num) \
++	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
++	.driver_info = (unsigned long)&qmi_wwan_info_quirk_dtr
++
+ /* Gobi 1000 QMI/wwan interface number is 3 according to qcserial */
+ #define QMI_GOBI1K_DEVICE(vend, prod) \
+ 	QMI_FIXED_INTF(vend, prod, 3)
+@@ -542,6 +661,7 @@
+ 
+ 	/* 3. Combined interface devices matching on interface number */
+ 	{QMI_FIXED_INTF(0x0408, 0xea42, 4)},	/* Yota / Megafon M100-1 */
++	{QMI_FIXED_INTF(0x05c6, 0x6001, 3)},	/* 4G LTE usb-modem U901 */
+ 	{QMI_FIXED_INTF(0x05c6, 0x7000, 0)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x7001, 1)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x7002, 1)},
+@@ -554,6 +674,7 @@
+ 	{QMI_FIXED_INTF(0x05c6, 0x8000, 7)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x8001, 6)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x9000, 4)},
++	{QMI_FIXED_INTF(0x05c6, 0x9003, 4)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x9005, 2)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x900a, 4)},
+ 	{QMI_FIXED_INTF(0x05c6, 0x900b, 2)},
+@@ -758,6 +879,7 @@
+ 	{QMI_FIXED_INTF(0x1199, 0x901c, 8)},    /* Sierra Wireless EM7700 */
+ 	{QMI_FIXED_INTF(0x1199, 0x901f, 8)},    /* Sierra Wireless EM7355 */
+ 	{QMI_FIXED_INTF(0x1199, 0x9041, 8)},	/* Sierra Wireless MC7305/MC7355 */
++	{QMI_FIXED_INTF(0x1199, 0x9041, 10)},	/* Sierra Wireless MC7305/MC7355 */
+ 	{QMI_FIXED_INTF(0x1199, 0x9051, 8)},	/* Netgear AirCard 340U */
+ 	{QMI_FIXED_INTF(0x1199, 0x9053, 8)},	/* Sierra Wireless Modem */
+ 	{QMI_FIXED_INTF(0x1199, 0x9054, 8)},	/* Sierra Wireless Modem */
+@@ -777,6 +899,7 @@
+ 	{QMI_FIXED_INTF(0x1bbb, 0x0203, 2)},	/* Alcatel L800MA */
+ 	{QMI_FIXED_INTF(0x2357, 0x0201, 4)},	/* TP-LINK HSUPA Modem MA180 */
+ 	{QMI_FIXED_INTF(0x2357, 0x9000, 4)},	/* TP-LINK MA260 */
++	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1040, 2)},	/* Telit LE922A */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},	/* Telit LE920 */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1201, 2)},	/* Telit LE920 */
+ 	{QMI_FIXED_INTF(0x1c9e, 0x9b01, 3)},	/* XS Stick W100-2 from 4G Systems */
+@@ -789,13 +912,21 @@
+ 	{QMI_FIXED_INTF(0x0b3c, 0xc00b, 4)},	/* Olivetti Olicard 500 */
+ 	{QMI_FIXED_INTF(0x1e2d, 0x0060, 4)},	/* Cinterion PLxx */
+ 	{QMI_FIXED_INTF(0x1e2d, 0x0053, 4)},	/* Cinterion PHxx,PXxx */
++	{QMI_FIXED_INTF(0x1e2d, 0x0082, 4)},	/* Cinterion PHxx,PXxx (2 RmNet) */
++	{QMI_FIXED_INTF(0x1e2d, 0x0082, 5)},	/* Cinterion PHxx,PXxx (2 RmNet) */
++	{QMI_FIXED_INTF(0x1e2d, 0x0083, 4)},	/* Cinterion PHxx,PXxx (1 RmNet + USB Audio)*/
+ 	{QMI_FIXED_INTF(0x413c, 0x81a2, 8)},	/* Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a3, 8)},	/* Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a4, 8)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a8, 8)},	/* Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a9, 8)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
+-	{QMI_FIXED_INTF(0x05c6, 0x9003, 4)},	/* Quectel UC20 */
+-	{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},	/* Quectel EC20 */
++	{QMI_FIXED_INTF(0x413c, 0x81b1, 8)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card */
++	{QMI_FIXED_INTF(0x413c, 0x81b3, 8)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
++	{QMI_FIXED_INTF(0x03f0, 0x4e1d, 8)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
++	{QMI_FIXED_INTF(0x22de, 0x9061, 3)},	/* WeTelecom WPD-600N */
++	{QMI_FIXED_INTF(0x1e0e, 0x9001, 5)},	/* SIMCom 7230E */
++	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0125, 4)},	/* Quectel EC25, EC20 R2.0  Mini PCIe */
++	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0121, 4)},	/* Quectel EC21 Mini PCIe */
+ 
+ 	/* 4. Gobi 1000 devices */
+ 	{QMI_GOBI1K_DEVICE(0x05c6, 0x9212)},	/* Acer Gobi Modem Device */
+@@ -825,6 +956,8 @@
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9225)},	/* Sony Gobi 2000 Modem device (N0279, VU730) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9245)},	/* Samsung Gobi 2000 Modem device (VL176) */
+ 	{QMI_GOBI_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
++	{QMI_GOBI_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
++	{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},	/* Quectel EC20 Mini PCIe */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9235)},	/* Top Global Gobi 2000 Modem device (VR306) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9275)},	/* iRex Technologies Gobi 2000 Modem device (VR307) */
+@@ -833,6 +966,7 @@
+ 	{QMI_GOBI_DEVICE(0x1199, 0x68a9)},	/* Sierra Wireless Modem */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9001)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9002)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
++	{QMI_GOBI_DEVICE(0x1199, 0x9003)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9004)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9005)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+ 	{QMI_GOBI_DEVICE(0x1199, 0x9006)},	/* Sierra Wireless Gobi 2000 Modem device (VT773) */
+@@ -855,10 +989,24 @@
+ };
+ MODULE_DEVICE_TABLE(usb, products);
+ 
++static bool quectel_ec20_detected(struct usb_interface *intf)
++{
++	struct usb_device *dev = interface_to_usbdev(intf);
++
++	if (dev->actconfig &&
++	    le16_to_cpu(dev->descriptor.idVendor) == 0x05c6 &&
++	    le16_to_cpu(dev->descriptor.idProduct) == 0x9215 &&
++	    dev->actconfig->desc.bNumInterfaces == 5)
++		return true;
++
++	return false;
++}
++
+ static int qmi_wwan_probe(struct usb_interface *intf,
+ 			  const struct usb_device_id *prod)
+ {
+ 	struct usb_device_id *id = (struct usb_device_id *)prod;
++	struct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;
+ 
+ 	/* Workaround to enable dynamic IDs.  This disables usbnet
+ 	 * blacklisting functionality.  Which, if required, can be
+@@ -870,6 +1018,12 @@
+ 		id->driver_info = (unsigned long)&qmi_wwan_info;
+ 	}
+ 
++	/* Quectel EC20 quirk where we've QMI on interface 4 instead of 0 */
++	if (quectel_ec20_detected(intf) && desc->bInterfaceNumber == 0) {
++		dev_dbg(&intf->dev, "Quectel EC20 quirk, skipping interface 0\n");
++		return -ENODEV;
++	}
++
+ 	return usbnet_probe(intf, id);
+ }
+ 
+--- a/drivers/net/usb/usbnet.c
++++ b/drivers/net/usb/usbnet.c
+@@ -324,7 +324,10 @@ void usbnet_skb_return (struct usbnet *d
+ 		return;
+ 	}
+ 
+-	skb->protocol = eth_type_trans (skb, dev->net);
++	/* only update if unset to allow minidriver rx_fixupp override */
++	if (skb->protocol == 0)
++		skb->protocol = eth_type_trans (skb, dev->net);
++
+ 	dev->net->stats.rx_packets++;
+ 	dev->net->stats.rx_bytes += skb->len;
+ 
+--- a/drivers/usb/core/message.c
++++ b/drivers/usb/core/message.c
+@@ -12,6 +12,7 @@
+ #include <linux/nls.h>
+ #include <linux/device.h>
+ #include <linux/scatterlist.h>
++#include <linux/usb/cdc.h>
+ #include <linux/usb/quirks.h>
+ #include <linux/usb/hcd.h>	/* for usbcore internals */
+ #include <asm/byteorder.h>
+@@ -1990,3 +1991,156 @@ int usb_driver_set_configuration(struct
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(usb_driver_set_configuration);
++
++/**
++ * cdc_parse_cdc_header - parse the extra headers present in CDC devices
++ * @hdr: the place to put the results of the parsing
++ * @intf: the interface for which parsing is requested
++ * @buffer: pointer to the extra headers to be parsed
++ * @buflen: length of the extra headers
++ *
++ * This evaluates the extra headers present in CDC devices which
++ * bind the interfaces for data and control and provide details
++ * about the capabilities of the device.
++ *
++ * Return: number of descriptors parsed or -EINVAL
++ * if the header is contradictory beyond salvage
++ */
++
++int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,
++				struct usb_interface *intf,
++				u8 *buffer,
++				int buflen)
++{
++	/* duplicates are ignored */
++	struct usb_cdc_union_desc *union_header = NULL;
++
++	/* duplicates are not tolerated */
++	struct usb_cdc_header_desc *header = NULL;
++	struct usb_cdc_ether_desc *ether = NULL;
++	struct usb_cdc_mdlm_detail_desc *detail = NULL;
++	struct usb_cdc_mdlm_desc *desc = NULL;
++
++	unsigned int elength;
++	int cnt = 0;
++
++	memset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));
++	hdr->phonet_magic_present = false;
++	while (buflen > 0) {
++		elength = buffer[0];
++		if (!elength) {
++			dev_err(&intf->dev, "skipping garbage byte\n");
++			elength = 1;
++			goto next_desc;
++		}
++		if (buffer[1] != USB_DT_CS_INTERFACE) {
++			dev_err(&intf->dev, "skipping garbage\n");
++			goto next_desc;
++		}
++
++		switch (buffer[2]) {
++		case USB_CDC_UNION_TYPE: /* we've found it */
++			if (elength < sizeof(struct usb_cdc_union_desc))
++				goto next_desc;
++			if (union_header) {
++				dev_err(&intf->dev, "More than one union descriptor, skipping ...\n");
++				goto next_desc;
++			}
++			union_header = (struct usb_cdc_union_desc *)buffer;
++			break;
++		case USB_CDC_COUNTRY_TYPE:
++			if (elength < sizeof(struct usb_cdc_country_functional_desc))
++				goto next_desc;
++			hdr->usb_cdc_country_functional_desc =
++				(struct usb_cdc_country_functional_desc *)buffer;
++			break;
++		case USB_CDC_HEADER_TYPE:
++			if (elength != sizeof(struct usb_cdc_header_desc))
++				goto next_desc;
++			if (header)
++				return -EINVAL;
++			header = (struct usb_cdc_header_desc *)buffer;
++			break;
++		case USB_CDC_ACM_TYPE:
++			if (elength < sizeof(struct usb_cdc_acm_descriptor))
++				goto next_desc;
++			hdr->usb_cdc_acm_descriptor =
++				(struct usb_cdc_acm_descriptor *)buffer;
++			break;
++		case USB_CDC_ETHERNET_TYPE:
++			if (elength != sizeof(struct usb_cdc_ether_desc))
++				goto next_desc;
++			if (ether)
++				return -EINVAL;
++			ether = (struct usb_cdc_ether_desc *)buffer;
++			break;
++		case USB_CDC_CALL_MANAGEMENT_TYPE:
++			if (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))
++				goto next_desc;
++			hdr->usb_cdc_call_mgmt_descriptor =
++				(struct usb_cdc_call_mgmt_descriptor *)buffer;
++			break;
++		case USB_CDC_DMM_TYPE:
++			if (elength < sizeof(struct usb_cdc_dmm_desc))
++				goto next_desc;
++			hdr->usb_cdc_dmm_desc =
++				(struct usb_cdc_dmm_desc *)buffer;
++			break;
++		case USB_CDC_MDLM_TYPE:
++			if (elength < sizeof(struct usb_cdc_mdlm_desc *))
++				goto next_desc;
++			if (desc)
++				return -EINVAL;
++			desc = (struct usb_cdc_mdlm_desc *)buffer;
++			break;
++		case USB_CDC_MDLM_DETAIL_TYPE:
++			if (elength < sizeof(struct usb_cdc_mdlm_detail_desc *))
++				goto next_desc;
++			if (detail)
++				return -EINVAL;
++			detail = (struct usb_cdc_mdlm_detail_desc *)buffer;
++			break;
++		case USB_CDC_NCM_TYPE:
++			if (elength < sizeof(struct usb_cdc_ncm_desc))
++				goto next_desc;
++			hdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;
++			break;
++		case USB_CDC_MBIM_TYPE:
++			if (elength < sizeof(struct usb_cdc_mbim_desc))
++				goto next_desc;
++
++			hdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;
++			break;
++		case USB_CDC_MBIM_EXTENDED_TYPE:
++			if (elength < sizeof(struct usb_cdc_mbim_extended_desc))
++				break;
++			hdr->usb_cdc_mbim_extended_desc =
++				(struct usb_cdc_mbim_extended_desc *)buffer;
++			break;
++		case CDC_PHONET_MAGIC_NUMBER:
++			hdr->phonet_magic_present = true;
++			break;
++		default:
++			/*
++			 * there are LOTS more CDC descriptors that
++			 * could legitimately be found here.
++			 */
++			dev_dbg(&intf->dev, "Ignoring descriptor: type %02x, length %ud\n",
++					buffer[2], elength);
++			goto next_desc;
++		}
++		cnt++;
++next_desc:
++		buflen -= elength;
++		buffer += elength;
++	}
++	hdr->usb_cdc_union_desc = union_header;
++	hdr->usb_cdc_header_desc = header;
++	hdr->usb_cdc_mdlm_detail_desc = detail;
++	hdr->usb_cdc_mdlm_desc = desc;
++	hdr->usb_cdc_ether_desc = ether;
++	return cnt;
++}
++
++EXPORT_SYMBOL(cdc_parse_cdc_header);
++
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -1987,6 +1987,10 @@ static int option_attach(struct usb_seri
+ 	if (serial->dev->descriptor.idVendor == 0x05C6 && serial->dev->descriptor.idProduct ==0x9215 &&
+ 		serial->interface->cur_altsetting->desc.bInterfaceNumber == 4)
+ 		return -ENODEV;
++	//Quectel EC20/EC25 R2.0's interface 4 can be used as USB Network device
++	if (serial->dev->descriptor.idVendor == 0x2C7C && serial->dev->descriptor.idProduct ==0x0125 &&
++		serial->interface->cur_altsetting->desc.bInterfaceNumber == 4)
++		return -ENODEV;
+ 
+ 	usb_set_serial_data(serial, data);
+ 
+--- /dev/null
++++ b/include/linux/usb/cdc.h
+@@ -0,0 +1,51 @@
++/*
++ * USB CDC common helpers
++ *
++ * Copyright (c) 2015 Oliver Neukum <oneukum@suse.com>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 as published by the Free Software Foundation.
++ */
++#ifndef __LINUX_USB_CDC_H
++#define __LINUX_USB_CDC_H
++
++#include <uapi/linux/usb/cdc.h>
++
++/*
++ * inofficial magic numbers
++ */
++
++#define CDC_PHONET_MAGIC_NUMBER		0xAB
++
++/*
++ * parsing CDC headers
++ */
++
++struct usb_cdc_parsed_header {
++	struct usb_cdc_union_desc *usb_cdc_union_desc;
++	struct usb_cdc_header_desc *usb_cdc_header_desc;
++
++	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
++	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
++	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
++	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
++	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
++	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
++	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
++	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
++	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
++	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
++	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
++	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
++
++	bool phonet_magic_present;
++};
++
++struct usb_interface;
++int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,
++				struct usb_interface *intf,
++				u8 *buffer,
++				int buflen);
++
++#endif /* __LINUX_USB_CDC_H */
+--- a/include/uapi/linux/usb/cdc.h
++++ b/include/uapi/linux/usb/cdc.h
+@@ -6,8 +6,8 @@
+  * firmware based USB peripherals.
+  */
+ 
+-#ifndef __LINUX_USB_CDC_H
+-#define __LINUX_USB_CDC_H
++#ifndef __UAPI_LINUX_USB_CDC_H
++#define __UAPI_LINUX_USB_CDC_H
+ 
+ #include <linux/types.h>
+ 
+@@ -444,4 +444,4 @@ struct usb_cdc_ncm_ndp_input_size {
+ #define USB_CDC_NCM_CRC_NOT_APPENDED			0x00
+ #define USB_CDC_NCM_CRC_APPENDED			0x01
+ 
+-#endif /* __LINUX_USB_CDC_H */
++#endif /* __UAPI_LINUX_USB_CDC_H */
--- /dev/null	2017-09-02 14:33:48.061030748 -0400
+++ b/target/linux/ar71xx/patches-3.18/921-ar300m-support-FM-PN-spinand.patch	2017-09-05 23:06:37.725725742 -0400
@@ -0,0 +1,63 @@
+--- a/drivers/mtd/nand/ath79_spinand.c
++++ b/drivers/mtd/nand/ath79_spinand.c
+@@ -203,6 +203,8 @@ static int ath79_spinand_read_id(struct
+ 	struct ath79_spinand_command cmd = {0};
+ 
+ 	cmd.cmd = CMD_READ_ID;
++	cmd.n_addr = 1;
++	cmd.addr[0] = 0x00;
+ 	cmd.n_rx = 3;
+ 	cmd.rx_buf = id;
+ 
+@@ -213,6 +215,10 @@ static int ath79_spinand_read_id(struct
+ 	}
+ 
+ 	/* GD conflict with cell info rules */
++	if((id[0]==0xb1)&&(id[1]==0x48)&&(id[2]==0xc8)){
++	id[0]=0xc8;
++	id[1]=0xb1;
++	}
+ 	id[2] = 0;
+ 
+ 	return retval;
+@@ -681,9 +687,9 @@ static void ath79_spinand_cmdfunc(struct
+ 					state->buf);
+ 		break;
+ 	case NAND_CMD_READOOB:
+-		state->buf_ptr = 0;
+-		ath79_spinand_read_page(info->spi, page, mtd->writesize,
+-					mtd->oobsize, state->buf);
++		state->buf_ptr = mtd->writesize;
++		ath79_spinand_read_page(info->spi, page, 0x0,/*mtd->writesize,*/
++					mtd->writesize + mtd->oobsize, state->buf);
+ 		break;
+ 	case NAND_CMD_RNDOUT:
+ 		state->buf_ptr = column;
+--- a/drivers/mtd/nand/nand_ids.c
++++ b/drivers/mtd/nand/nand_ids.c
+@@ -104,6 +104,7 @@ struct nand_flash_dev nand_flash_ids[] =
+ 	EXTENDED_ID_NAND("NAND 128MiB 3,3V 8-bit",  0xF1, 128, LP_OPTIONS),
+ 	EXTENDED_ID_NAND("NAND 128MiB 3,3V 8-bit",  0xD1, 128, LP_OPTIONS),
+ 	EXTENDED_ID_NAND("NAND 128MiB 1,8V 16-bit", 0xB1, 128, LP_OPTIONS16),
++	EXTENDED_ID_NAND("NAND 128MiB 3,3V 16-bit", 0xE1, 128, LP_OPTIONS16),
+ 	EXTENDED_ID_NAND("NAND 128MiB 3,3V 16-bit", 0xC1, 128, LP_OPTIONS16),
+ 	EXTENDED_ID_NAND("NAND 128MiB 1,8V 16-bit", 0xAD, 128, LP_OPTIONS16),
+ 
+@@ -181,6 +182,7 @@ struct nand_manufacturers nand_manuf_ids
+ 	{NAND_MFR_INTEL, "Intel"},
+ 	{NAND_MFR_GIGADEVICE, "Giga Device"},
+ 	{NAND_MFR_HEYANGTEK, "HeYang Tek"},
++	{NAND_MFR_FWDEVICE, "FW Device"},
+ 	{0x0, "Unknown"}
+ };
+ 
+--- a/include/linux/mtd/nand.h
++++ b/include/linux/mtd/nand.h
+@@ -722,6 +722,7 @@ struct nand_chip {
+ #define NAND_MFR_MACRONIX	0xc2
+ #define NAND_MFR_GIGADEVICE	0xc8
+ #define NAND_MFR_HEYANGTEK	0xc9
++#define NAND_MFR_FWDEVICE	0xA1
+ #define NAND_MFR_EON		0x92
+ #define NAND_MFR_SANDISK	0x45
+ #define NAND_MFR_INTEL		0x89
--- /dev/null	2017-09-02 14:33:48.061030748 -0400
+++ b/target/linux/ar71xx/patches-3.18/922-EC25-EC20-R2.0-set-rawip-by-default.patch	2017-09-05 23:06:37.725725742 -0400
@@ -0,0 +1,40 @@
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -997,11 +997,26 @@ static bool quectel_ec20_detected(struct
+ 	return false;
+ }
+ 
++static void quectel_ec25_ec20_R2_setrawip(struct usb_interface *intf)
++{
++	struct usbnet *dev = usb_get_intfdata(intf);
++	struct qmi_wwan_state *info = (void *)&dev->data;
++	
++	struct usb_device *dev_id = interface_to_usbdev(intf);
++
++	if (le16_to_cpu(dev_id->descriptor.idVendor) == 0x2c7c &&
++		le16_to_cpu(dev_id->descriptor.idProduct) == 0x0125){
++		info->flags |= QMI_WWAN_FLAG_RAWIP;
++	 qmi_wwan_netdev_setup(dev->net);
++	}
++}
++
+ static int qmi_wwan_probe(struct usb_interface *intf,
+ 			  const struct usb_device_id *prod)
+ {
+ 	struct usb_device_id *id = (struct usb_device_id *)prod;
+ 	struct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;
++	int status;
+ 
+ 	/* Workaround to enable dynamic IDs.  This disables usbnet
+ 	 * blacklisting functionality.  Which, if required, can be
+@@ -1019,7 +1034,9 @@ static int qmi_wwan_probe(struct usb_int
+ 		return -ENODEV;
+ 	}
+ 
+-	return usbnet_probe(intf, id);
++	status=usbnet_probe(intf, id);
++	quectel_ec25_ec20_R2_setrawip(intf);
++	return status;
+ }
+ 
+ static struct usb_driver qmi_wwan_driver = {
--- /dev/null	2017-09-02 14:33:48.061030748 -0400
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c	2017-09-05 23:16:55.813180784 -0400
@@ -0,0 +1,101 @@
+/*
+ *  GL USB nano router support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_USB_GPIO_LED_WLAN	   0
+#define GL_USB_GPIO_LED_LAN		   13
+#define GL_USB_GPIO_LAN_RESET	7
+
+#define GL_USB_GPIO_BTN_RESET	   11
+
+#define GL_USB_KEYS_POLL_INTERVAL   20	/* msecs */
+#define GL_USB_KEYS_DEBOUNCE_INTERVAL	(3 * GL_USB_KEYS_POLL_INTERVAL)
+
+#define GL_USB_MAC0_OFFSET	0x0000
+#define GL_USB_CALDATA_OFFSET	0x1000
+#define GL_USB_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_usb_leds_gpio[] __initdata = {
+	{
+		.name = "gl-usb150:wlan",
+		.gpio = GL_USB_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-usb150:pow",
+		.gpio = GL_USB_GPIO_LED_LAN,
+		.active_low = 0,
+		.default_state = 1,
+	},
+	{
+	    .name = "gl-usb150:resetlan",
+		.gpio = GL_USB_GPIO_LAN_RESET,
+		.active_low = 0,
+		.default_state = 0,
+	},
+};
+
+static struct gpio_keys_button gl_usb_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_USB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_USB_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init gl_usb_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_usb_leds_gpio),
+				 gl_usb_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_USB_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_usb_gpio_keys),
+					gl_usb_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_USB_MAC0_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_USB_CALDATA_OFFSET, art + GL_USB_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_USB150, "GL-USB150", "GL-USB150",gl_usb_setup);
--- a/target/linux/ar71xx/config-3.18	2017-03-14 14:22:27.773587532 -0400
+++ b/target/linux/ar71xx/config-3.18	2017-09-05 23:22:08.805316406 -0400
@@ -75,6 +75,7 @@
 CONFIG_ATH79_MACH_GL_AR300M=y
 CONFIG_ATH79_MACH_GL_DOMINO=y
 CONFIG_ATH79_MACH_GL_INET=y
+CONFIG_ATH79_MACH_GL_USB150=y
 CONFIG_ATH79_MACH_GS_MINIBOX_V1=y
 CONFIG_ATH79_MACH_GS_OOLITE=y
 CONFIG_ATH79_MACH_HIWIFI_HC6361=y
@@ -267,6 +268,7 @@
 CONFIG_MDIO_BOARDINFO=y
 CONFIG_MICREL_PHY=y
 CONFIG_MIPS=y
+CONFIG_MIPS_FPU_EMULATOR=y
 # CONFIG_MIPS_HUGE_TLB_SUPPORT is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_MIPS_MACHINE=y
@@ -328,7 +330,7 @@
 CONFIG_SOC_AR934X=y
 CONFIG_SOC_QCA953X=y
 CONFIG_SOC_QCA955X=y
-# CONFIG_SOC_QCA956X is not set
+CONFIG_SOC_QCA956X=y
 CONFIG_SPI=y
 CONFIG_SPI_AP83=y
 CONFIG_SPI_ATH79=y
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/01_leds
@@ -184,7 +184,9 @@ dlan-pro-1200-ac)
 gl-ar150)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl_ar150:wlan" "phy0tpt"
 	;;
-
+gl-usb150)
+	ucidef_set_led_wlan "wlan" "WLAN" "gl-usb150:wlan" "phy0tpt"
+	;;
 gl-ar300m)
 	ucidef_set_led_wlan "wlan" "WLAN" "gl-ar300m:wlan" "phy0tpt"
 	;;
--- a/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ar71xx/base-files/etc/uci-defaults/02_network
@@ -331,6 +331,7 @@ cap4200ag |\
 eap300v2 |\
 eap7660d |\
 el-mini |\
+gl-usb150 |\
 loco-m-xw |\
 mr600 |\
 mr600v2 |\
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -470,6 +470,9 @@ ar71xx_board_detect() {
 	*"GL-MIFI")
         name="gl-mifi"
         ;;
+	*"GL-USB150")
+		name="gl-usb150"
+		;;
 	*"EnGenius EPG5000")
 		name="epg5000"
 		;;
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -251,6 +251,7 @@ platform_check_image() {
 	gl-ar300 | \
 	gl-ar300m | \
 	gl-domino | \
+	gl-usb150 | \
 	epg5000 | \
 	esr1750 | \
 	esr900 | \
--- a/target/linux/ar71xx/generic/profiles/gli.mk
+++ b/target/linux/ar71xx/generic/profiles/gli.mk
@@ -50,7 +50,7 @@ $(eval $(call Profile,DOMINO))
 
 define Profile/GL-MIFI
 	NAME:=GL-MIFI
-	PACKAGES:=kmod-usb-core kmod-usb2
+	PACKAGES:=kmod-usb-core kmod-usb2 kmod-usb-net
 endef
 define Profile/GL-MIFI/Description
 	Configuration of GL-MIFI.
@@ -66,3 +66,15 @@ define Profile/GL-AR300M/description
 	Package set optimized for the GL-AR300M.
 endef
 $(eval $(call Profile,GL-AR300M))
+
+define Profile/GL-USB150
+	NAME:=GL-USB150
+	PACKAGES:=kmod-usb-core kmod-usb2 kmod-ledtrig-gpio
+endef
+
+define Profile/GL-USB150/Description
+	Configuration of GL USB150 nano router
+endef
+
+$(eval $(call Profile,GL-USB150))
+
--- a/target/linux/ar71xx/image/Makefile
+++ b/target/linux/ar71xx/image/Makefile
@@ -152,6 +152,14 @@ define Device/gl-ar150
 endef
 TARGET_DEVICES += gl-ar150
 
+define Device/gl-usb150
+  BOARDNAME = GL-USB150
+  IMAGE_SIZE = 16000k
+  CONSOLE = ttyATH0,115200
+  MTDPARTS = spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,16000k(firmware),64k(art)ro
+endef
+TARGET_DEVICES += gl-usb150
+
 define Device/gl-mifi
   BOARDNAME = GL-MIFI
   IMAGE_SIZE = 16000k
